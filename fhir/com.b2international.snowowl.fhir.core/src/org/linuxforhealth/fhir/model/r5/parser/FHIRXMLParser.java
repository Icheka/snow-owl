/*
 * (C) Copyright IBM Corp. 2019, 2022
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package org.linuxforhealth.fhir.model.r5.parser;

import static org.linuxforhealth.fhir.model.util.XMLSupport.*;

import java.io.InputStream;
import java.io.Reader;
import java.util.Stack;
import java.util.StringJoiner;

import javax.annotation.Generated;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;

import org.linuxforhealth.fhir.core.ResourceType;
import org.linuxforhealth.fhir.model.parser.exception.FHIRParserException;
import org.linuxforhealth.fhir.model.r5.resource.*;
import org.linuxforhealth.fhir.model.r5.type.*;
import org.linuxforhealth.fhir.model.r5.type.Boolean;
import org.linuxforhealth.fhir.model.r5.type.Integer;
import org.linuxforhealth.fhir.model.r5.type.String;
import org.linuxforhealth.fhir.model.r5.type.code.*;
import org.linuxforhealth.fhir.model.util.XMLSupport.StreamReaderDelegate;

//import net.jcip.annotations.NotThreadSafe;

/*
 * Modifications:
 * 
 * - Remove case for "MetadataResource" and "CanonicalResource"
 */

//@NotThreadSafe
@Generated("org.linuxforhealth.fhir.tools.CodeGenerator")
public class FHIRXMLParser extends FHIRAbstractParser {
    public static boolean DEBUG = false;

    private final Stack<java.lang.String> stack = new Stack<>();

    FHIRXMLParser() {
        // only visible to subclasses or classes/interfaces in the same package (e.g. FHIRParser)
    }

    @SuppressWarnings("unchecked")
    @Override
    public <T extends Resource> T parse(InputStream in) throws FHIRParserException {
        try (StreamReaderDelegate delegate = createStreamReaderDelegate(in)) {
            reset();
            while (delegate.hasNext()) {
                int eventType = delegate.next();
                switch (eventType) {
                case XMLStreamReader.START_ELEMENT:
                    requireNamespace(delegate, FHIR_NS_URI);
                    return (T) parseResource(getResourceType(delegate), delegate, -1);
                }
            }
            throw new XMLStreamException("Unexpected end of stream");
        } catch (Exception e) {
            throw new FHIRParserException(e.getMessage(), getPath(), e);
        }
    }

    @SuppressWarnings("unchecked")
    @Override
    public <T extends Resource> T parse(Reader reader) throws FHIRParserException {
        try (StreamReaderDelegate delegate = createStreamReaderDelegate(reader)) {
            reset();
            while (delegate.hasNext()) {
                int eventType = delegate.next();
                switch (eventType) {
                case XMLStreamReader.START_ELEMENT:
                    requireNamespace(delegate, FHIR_NS_URI);
                    return (T) parseResource(getResourceType(delegate), delegate, -1);
                }
            }
            throw new XMLStreamException("Unexpected end of stream");
        } catch (Exception e) {
            throw new FHIRParserException(e.getMessage(), getPath(), e);
        }
    }

    private void reset() {
        stack.clear();
    }

    private Resource parseResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        if (isResourceContainer(elementName)) {
            reader.nextTag();
        }
        java.lang.String resourceType = getResourceType(reader);
        switch (resourceType) {
        case "Account":
            return parseAccount(elementName, reader, elementIndex);
        case "ActivityDefinition":
            return parseActivityDefinition(elementName, reader, elementIndex);
        case "ActorDefinition":
            return parseActorDefinition(elementName, reader, elementIndex);
        case "AdministrableProductDefinition":
            return parseAdministrableProductDefinition(elementName, reader, elementIndex);
        case "AdverseEvent":
            return parseAdverseEvent(elementName, reader, elementIndex);
        case "AllergyIntolerance":
            return parseAllergyIntolerance(elementName, reader, elementIndex);
        case "Appointment":
            return parseAppointment(elementName, reader, elementIndex);
        case "AppointmentResponse":
            return parseAppointmentResponse(elementName, reader, elementIndex);
        case "ArtifactAssessment":
            return parseArtifactAssessment(elementName, reader, elementIndex);
        case "AuditEvent":
            return parseAuditEvent(elementName, reader, elementIndex);
        case "Basic":
            return parseBasic(elementName, reader, elementIndex);
        case "Binary":
            return parseBinary(elementName, reader, elementIndex);
        case "BiologicallyDerivedProduct":
            return parseBiologicallyDerivedProduct(elementName, reader, elementIndex);
        case "BiologicallyDerivedProductDispense":
            return parseBiologicallyDerivedProductDispense(elementName, reader, elementIndex);
        case "BodyStructure":
            return parseBodyStructure(elementName, reader, elementIndex);
        case "Bundle":
            return parseBundle(elementName, reader, elementIndex);
        case "CapabilityStatement":
            return parseCapabilityStatement(elementName, reader, elementIndex);
        case "CarePlan":
            return parseCarePlan(elementName, reader, elementIndex);
        case "CareTeam":
            return parseCareTeam(elementName, reader, elementIndex);
        case "ChargeItem":
            return parseChargeItem(elementName, reader, elementIndex);
        case "ChargeItemDefinition":
            return parseChargeItemDefinition(elementName, reader, elementIndex);
        case "Citation":
            return parseCitation(elementName, reader, elementIndex);
        case "Claim":
            return parseClaim(elementName, reader, elementIndex);
        case "ClaimResponse":
            return parseClaimResponse(elementName, reader, elementIndex);
        case "ClinicalImpression":
            return parseClinicalImpression(elementName, reader, elementIndex);
        case "ClinicalUseDefinition":
            return parseClinicalUseDefinition(elementName, reader, elementIndex);
        case "CodeSystem":
            return parseCodeSystem(elementName, reader, elementIndex);
        case "Communication":
            return parseCommunication(elementName, reader, elementIndex);
        case "CommunicationRequest":
            return parseCommunicationRequest(elementName, reader, elementIndex);
        case "CompartmentDefinition":
            return parseCompartmentDefinition(elementName, reader, elementIndex);
        case "Composition":
            return parseComposition(elementName, reader, elementIndex);
        case "ConceptMap":
            return parseConceptMap(elementName, reader, elementIndex);
        case "Condition":
            return parseCondition(elementName, reader, elementIndex);
        case "ConditionDefinition":
            return parseConditionDefinition(elementName, reader, elementIndex);
        case "Consent":
            return parseConsent(elementName, reader, elementIndex);
        case "Contract":
            return parseContract(elementName, reader, elementIndex);
        case "Coverage":
            return parseCoverage(elementName, reader, elementIndex);
        case "CoverageEligibilityRequest":
            return parseCoverageEligibilityRequest(elementName, reader, elementIndex);
        case "CoverageEligibilityResponse":
            return parseCoverageEligibilityResponse(elementName, reader, elementIndex);
        case "DetectedIssue":
            return parseDetectedIssue(elementName, reader, elementIndex);
        case "Device":
            return parseDevice(elementName, reader, elementIndex);
        case "DeviceAssociation":
            return parseDeviceAssociation(elementName, reader, elementIndex);
        case "DeviceDefinition":
            return parseDeviceDefinition(elementName, reader, elementIndex);
        case "DeviceDispense":
            return parseDeviceDispense(elementName, reader, elementIndex);
        case "DeviceMetric":
            return parseDeviceMetric(elementName, reader, elementIndex);
        case "DeviceRequest":
            return parseDeviceRequest(elementName, reader, elementIndex);
        case "DeviceUsage":
            return parseDeviceUsage(elementName, reader, elementIndex);
        case "DiagnosticReport":
            return parseDiagnosticReport(elementName, reader, elementIndex);
        case "DocumentReference":
            return parseDocumentReference(elementName, reader, elementIndex);
        case "Encounter":
            return parseEncounter(elementName, reader, elementIndex);
        case "EncounterHistory":
            return parseEncounterHistory(elementName, reader, elementIndex);
        case "Endpoint":
            return parseEndpoint(elementName, reader, elementIndex);
        case "EnrollmentRequest":
            return parseEnrollmentRequest(elementName, reader, elementIndex);
        case "EnrollmentResponse":
            return parseEnrollmentResponse(elementName, reader, elementIndex);
        case "EpisodeOfCare":
            return parseEpisodeOfCare(elementName, reader, elementIndex);
        case "EventDefinition":
            return parseEventDefinition(elementName, reader, elementIndex);
        case "Evidence":
            return parseEvidence(elementName, reader, elementIndex);
        case "EvidenceReport":
            return parseEvidenceReport(elementName, reader, elementIndex);
        case "EvidenceVariable":
            return parseEvidenceVariable(elementName, reader, elementIndex);
        case "ExampleScenario":
            return parseExampleScenario(elementName, reader, elementIndex);
        case "ExplanationOfBenefit":
            return parseExplanationOfBenefit(elementName, reader, elementIndex);
        case "FamilyMemberHistory":
            return parseFamilyMemberHistory(elementName, reader, elementIndex);
        case "Flag":
            return parseFlag(elementName, reader, elementIndex);
        case "FormularyItem":
            return parseFormularyItem(elementName, reader, elementIndex);
        case "GenomicStudy":
            return parseGenomicStudy(elementName, reader, elementIndex);
        case "Goal":
            return parseGoal(elementName, reader, elementIndex);
        case "GraphDefinition":
            return parseGraphDefinition(elementName, reader, elementIndex);
        case "Group":
            return parseGroup(elementName, reader, elementIndex);
        case "GuidanceResponse":
            return parseGuidanceResponse(elementName, reader, elementIndex);
        case "HealthcareService":
            return parseHealthcareService(elementName, reader, elementIndex);
        case "ImagingSelection":
            return parseImagingSelection(elementName, reader, elementIndex);
        case "ImagingStudy":
            return parseImagingStudy(elementName, reader, elementIndex);
        case "Immunization":
            return parseImmunization(elementName, reader, elementIndex);
        case "ImmunizationEvaluation":
            return parseImmunizationEvaluation(elementName, reader, elementIndex);
        case "ImmunizationRecommendation":
            return parseImmunizationRecommendation(elementName, reader, elementIndex);
        case "ImplementationGuide":
            return parseImplementationGuide(elementName, reader, elementIndex);
        case "Ingredient":
            return parseIngredient(elementName, reader, elementIndex);
        case "InsurancePlan":
            return parseInsurancePlan(elementName, reader, elementIndex);
        case "InventoryItem":
            return parseInventoryItem(elementName, reader, elementIndex);
        case "InventoryReport":
            return parseInventoryReport(elementName, reader, elementIndex);
        case "Invoice":
            return parseInvoice(elementName, reader, elementIndex);
        case "Library":
            return parseLibrary(elementName, reader, elementIndex);
        case "Linkage":
            return parseLinkage(elementName, reader, elementIndex);
        case "List":
            return parseList(elementName, reader, elementIndex);
        case "Location":
            return parseLocation(elementName, reader, elementIndex);
        case "ManufacturedItemDefinition":
            return parseManufacturedItemDefinition(elementName, reader, elementIndex);
        case "Measure":
            return parseMeasure(elementName, reader, elementIndex);
        case "MeasureReport":
            return parseMeasureReport(elementName, reader, elementIndex);
        case "Medication":
            return parseMedication(elementName, reader, elementIndex);
        case "MedicationAdministration":
            return parseMedicationAdministration(elementName, reader, elementIndex);
        case "MedicationDispense":
            return parseMedicationDispense(elementName, reader, elementIndex);
        case "MedicationKnowledge":
            return parseMedicationKnowledge(elementName, reader, elementIndex);
        case "MedicationRequest":
            return parseMedicationRequest(elementName, reader, elementIndex);
        case "MedicationStatement":
            return parseMedicationStatement(elementName, reader, elementIndex);
        case "MedicinalProductDefinition":
            return parseMedicinalProductDefinition(elementName, reader, elementIndex);
        case "MessageDefinition":
            return parseMessageDefinition(elementName, reader, elementIndex);
        case "MessageHeader":
            return parseMessageHeader(elementName, reader, elementIndex);
        case "MolecularSequence":
            return parseMolecularSequence(elementName, reader, elementIndex);
        case "NamingSystem":
            return parseNamingSystem(elementName, reader, elementIndex);
        case "NutritionIntake":
            return parseNutritionIntake(elementName, reader, elementIndex);
        case "NutritionOrder":
            return parseNutritionOrder(elementName, reader, elementIndex);
        case "NutritionProduct":
            return parseNutritionProduct(elementName, reader, elementIndex);
        case "Observation":
            return parseObservation(elementName, reader, elementIndex);
        case "ObservationDefinition":
            return parseObservationDefinition(elementName, reader, elementIndex);
        case "OperationDefinition":
            return parseOperationDefinition(elementName, reader, elementIndex);
        case "OperationOutcome":
            return parseOperationOutcome(elementName, reader, elementIndex);
        case "Organization":
            return parseOrganization(elementName, reader, elementIndex);
        case "OrganizationAffiliation":
            return parseOrganizationAffiliation(elementName, reader, elementIndex);
        case "PackagedProductDefinition":
            return parsePackagedProductDefinition(elementName, reader, elementIndex);
        case "Parameters":
            return parseParameters(elementName, reader, elementIndex);
        case "Patient":
            return parsePatient(elementName, reader, elementIndex);
        case "PaymentNotice":
            return parsePaymentNotice(elementName, reader, elementIndex);
        case "PaymentReconciliation":
            return parsePaymentReconciliation(elementName, reader, elementIndex);
        case "Permission":
            return parsePermission(elementName, reader, elementIndex);
        case "Person":
            return parsePerson(elementName, reader, elementIndex);
        case "PlanDefinition":
            return parsePlanDefinition(elementName, reader, elementIndex);
        case "Practitioner":
            return parsePractitioner(elementName, reader, elementIndex);
        case "PractitionerRole":
            return parsePractitionerRole(elementName, reader, elementIndex);
        case "Procedure":
            return parseProcedure(elementName, reader, elementIndex);
        case "Provenance":
            return parseProvenance(elementName, reader, elementIndex);
        case "Questionnaire":
            return parseQuestionnaire(elementName, reader, elementIndex);
        case "QuestionnaireResponse":
            return parseQuestionnaireResponse(elementName, reader, elementIndex);
        case "RegulatedAuthorization":
            return parseRegulatedAuthorization(elementName, reader, elementIndex);
        case "RelatedPerson":
            return parseRelatedPerson(elementName, reader, elementIndex);
        case "RequestOrchestration":
            return parseRequestOrchestration(elementName, reader, elementIndex);
        case "Requirements":
            return parseRequirements(elementName, reader, elementIndex);
        case "ResearchStudy":
            return parseResearchStudy(elementName, reader, elementIndex);
        case "ResearchSubject":
            return parseResearchSubject(elementName, reader, elementIndex);
        case "RiskAssessment":
            return parseRiskAssessment(elementName, reader, elementIndex);
        case "Schedule":
            return parseSchedule(elementName, reader, elementIndex);
        case "SearchParameter":
            return parseSearchParameter(elementName, reader, elementIndex);
        case "ServiceRequest":
            return parseServiceRequest(elementName, reader, elementIndex);
        case "Slot":
            return parseSlot(elementName, reader, elementIndex);
        case "Specimen":
            return parseSpecimen(elementName, reader, elementIndex);
        case "SpecimenDefinition":
            return parseSpecimenDefinition(elementName, reader, elementIndex);
        case "StructureDefinition":
            return parseStructureDefinition(elementName, reader, elementIndex);
        case "StructureMap":
            return parseStructureMap(elementName, reader, elementIndex);
        case "Subscription":
            return parseSubscription(elementName, reader, elementIndex);
        case "SubscriptionStatus":
            return parseSubscriptionStatus(elementName, reader, elementIndex);
        case "SubscriptionTopic":
            return parseSubscriptionTopic(elementName, reader, elementIndex);
        case "Substance":
            return parseSubstance(elementName, reader, elementIndex);
        case "SubstanceDefinition":
            return parseSubstanceDefinition(elementName, reader, elementIndex);
        case "SubstanceNucleicAcid":
            return parseSubstanceNucleicAcid(elementName, reader, elementIndex);
        case "SubstancePolymer":
            return parseSubstancePolymer(elementName, reader, elementIndex);
        case "SubstanceProtein":
            return parseSubstanceProtein(elementName, reader, elementIndex);
        case "SubstanceReferenceInformation":
            return parseSubstanceReferenceInformation(elementName, reader, elementIndex);
        case "SubstanceSourceMaterial":
            return parseSubstanceSourceMaterial(elementName, reader, elementIndex);
        case "SupplyDelivery":
            return parseSupplyDelivery(elementName, reader, elementIndex);
        case "SupplyRequest":
            return parseSupplyRequest(elementName, reader, elementIndex);
        case "Task":
            return parseTask(elementName, reader, elementIndex);
        case "TerminologyCapabilities":
            return parseTerminologyCapabilities(elementName, reader, elementIndex);
        case "TestPlan":
            return parseTestPlan(elementName, reader, elementIndex);
        case "TestReport":
            return parseTestReport(elementName, reader, elementIndex);
        case "TestScript":
            return parseTestScript(elementName, reader, elementIndex);
        case "Transport":
            return parseTransport(elementName, reader, elementIndex);
        case "ValueSet":
            return parseValueSet(elementName, reader, elementIndex);
        case "VerificationResult":
            return parseVerificationResult(elementName, reader, elementIndex);
        case "VisionPrescription":
            return parseVisionPrescription(elementName, reader, elementIndex);
        }
        return null;
    }

    private Account parseAccount(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.Builder builder = Account.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, subjectElementIndex = 0, coverageElementIndex = 0, guarantorElementIndex = 0, diagnosisElementIndex = 0, procedureElementIndex = 0, relatedAccountElementIndex = 0, balanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((AccountStatus) parseString(AccountStatus.builder(), "status", reader, -1));
                    break;
                case "billingStatus":
                    position = checkElementOrder("billingStatus", 10, position, false);
                    builder.billingStatus(parseCodeableConcept("billingStatus", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "servicePeriod":
                    position = checkElementOrder("servicePeriod", 14, position, false);
                    builder.servicePeriod(parsePeriod("servicePeriod", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 15, position, true);
                    builder.coverage(parseAccountCoverage("coverage", reader, coverageElementIndex++));
                    break;
                case "owner":
                    position = checkElementOrder("owner", 16, position, false);
                    builder.owner(parseReference("owner", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 17, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "guarantor":
                    position = checkElementOrder("guarantor", 18, position, true);
                    builder.guarantor(parseAccountGuarantor("guarantor", reader, guarantorElementIndex++));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 19, position, true);
                    builder.diagnosis(parseAccountDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 20, position, true);
                    builder.procedure(parseAccountProcedure("procedure", reader, procedureElementIndex++));
                    break;
                case "relatedAccount":
                    position = checkElementOrder("relatedAccount", 21, position, true);
                    builder.relatedAccount(parseAccountRelatedAccount("relatedAccount", reader, relatedAccountElementIndex++));
                    break;
                case "currency":
                    position = checkElementOrder("currency", 22, position, false);
                    builder.currency(parseCodeableConcept("currency", reader, -1));
                    break;
                case "balance":
                    position = checkElementOrder("balance", 23, position, true);
                    builder.balance(parseAccountBalance("balance", reader, balanceElementIndex++));
                    break;
                case "calculatedAt":
                    position = checkElementOrder("calculatedAt", 24, position, false);
                    builder.calculatedAt(parseInstant("calculatedAt", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Account.Balance parseAccountBalance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.Balance.Builder builder = Account.Balance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "aggregate":
                    position = checkElementOrder("aggregate", 2, position, false);
                    builder.aggregate(parseCodeableConcept("aggregate", reader, -1));
                    break;
                case "term":
                    position = checkElementOrder("term", 3, position, false);
                    builder.term(parseCodeableConcept("term", reader, -1));
                    break;
                case "estimate":
                    position = checkElementOrder("estimate", 4, position, false);
                    builder.estimate(parseBoolean("estimate", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 5, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Account.Coverage parseAccountCoverage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.Coverage.Builder builder = Account.Coverage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 2, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 3, position, false);
                    builder.priority((PositiveInt) parseInteger(PositiveInt.builder(), "priority", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Account.Diagnosis parseAccountDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.Diagnosis.Builder builder = Account.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, packageCodeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 3, position, false);
                    builder.condition(parseCodeableReference("condition", reader, -1));
                    break;
                case "dateOfDiagnosis":
                    position = checkElementOrder("dateOfDiagnosis", 4, position, false);
                    builder.dateOfDiagnosis(parseDateTime("dateOfDiagnosis", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "onAdmission":
                    position = checkElementOrder("onAdmission", 6, position, false);
                    builder.onAdmission(parseBoolean("onAdmission", reader, -1));
                    break;
                case "packageCode":
                    position = checkElementOrder("packageCode", 7, position, true);
                    builder.packageCode(parseCodeableConcept("packageCode", reader, packageCodeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Account.Guarantor parseAccountGuarantor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.Guarantor.Builder builder = Account.Guarantor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "party":
                    position = checkElementOrder("party", 2, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                case "onHold":
                    position = checkElementOrder("onHold", 3, position, false);
                    builder.onHold(parseBoolean("onHold", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Account.Procedure parseAccountProcedure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.Procedure.Builder builder = Account.Procedure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, packageCodeElementIndex = 0, deviceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableReference("code", reader, -1));
                    break;
                case "dateOfService":
                    position = checkElementOrder("dateOfService", 4, position, false);
                    builder.dateOfService(parseDateTime("dateOfService", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "packageCode":
                    position = checkElementOrder("packageCode", 6, position, true);
                    builder.packageCode(parseCodeableConcept("packageCode", reader, packageCodeElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 7, position, true);
                    builder.device(parseReference("device", reader, deviceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Account.RelatedAccount parseAccountRelatedAccount(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.RelatedAccount.Builder builder = Account.RelatedAccount.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 2, position, false);
                    builder.relationship(parseCodeableConcept("relationship", reader, -1));
                    break;
                case "account":
                    position = checkElementOrder("account", 3, position, false);
                    builder.account(parseReference("account", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ActivityDefinition parseActivityDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ActivityDefinition.Builder builder = ActivityDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, libraryElementIndex = 0, participantElementIndex = 0, dosageElementIndex = 0, bodySiteElementIndex = 0, specimenRequirementElementIndex = 0, observationRequirementElementIndex = 0, observationResultRequirementElementIndex = 0, dynamicValueElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 14, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "subjectCanonical":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject((Canonical) parseUri(Canonical.builder(), "subjectCanonical", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 18, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 19, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 20, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 21, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 22, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 23, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 24, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 25, position, false);
                    builder.usage((Markdown) parseString(Markdown.builder(), "usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 26, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 27, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 28, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 29, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 30, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 31, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 32, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 33, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 34, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 35, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 36, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "library":
                    position = checkElementOrder("library", 37, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 38, position, false);
                    builder.kind((ActivityDefinitionKind) parseString(ActivityDefinitionKind.builder(), "kind", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 39, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 40, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 41, position, false);
                    builder.intent((RequestIntent) parseString(RequestIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 42, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 43, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 44, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "timingAge":
                    position = checkElementOrder("timing[x]", 44, position, false);
                    builder.timing((Age) parseQuantity(Age.builder(), "timingAge", reader, -1));
                    break;
                case "timingRange":
                    position = checkElementOrder("timing[x]", 44, position, false);
                    builder.timing(parseRange("timingRange", reader, -1));
                    break;
                case "timingDuration":
                    position = checkElementOrder("timing[x]", 44, position, false);
                    builder.timing((Duration) parseQuantity(Duration.builder(), "timingDuration", reader, -1));
                    break;
                case "asNeededBoolean":
                    position = checkElementOrder("asNeeded[x]", 45, position, false);
                    builder.asNeeded(parseBoolean("asNeededBoolean", reader, -1));
                    break;
                case "asNeededCodeableConcept":
                    position = checkElementOrder("asNeeded[x]", 45, position, false);
                    builder.asNeeded(parseCodeableConcept("asNeededCodeableConcept", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 46, position, false);
                    builder.location(parseCodeableReference("location", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 47, position, true);
                    builder.participant(parseActivityDefinitionParticipant("participant", reader, participantElementIndex++));
                    break;
                case "productReference":
                    position = checkElementOrder("product[x]", 48, position, false);
                    builder.product(parseReference("productReference", reader, -1));
                    break;
                case "productCodeableConcept":
                    position = checkElementOrder("product[x]", 48, position, false);
                    builder.product(parseCodeableConcept("productCodeableConcept", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 49, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 50, position, true);
                    builder.dosage(parseDosage("dosage", reader, dosageElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 51, position, true);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "specimenRequirement":
                    position = checkElementOrder("specimenRequirement", 52, position, true);
                    builder.specimenRequirement((Canonical) parseUri(Canonical.builder(), "specimenRequirement", reader, specimenRequirementElementIndex++));
                    break;
                case "observationRequirement":
                    position = checkElementOrder("observationRequirement", 53, position, true);
                    builder.observationRequirement((Canonical) parseUri(Canonical.builder(), "observationRequirement", reader, observationRequirementElementIndex++));
                    break;
                case "observationResultRequirement":
                    position = checkElementOrder("observationResultRequirement", 54, position, true);
                    builder.observationResultRequirement((Canonical) parseUri(Canonical.builder(), "observationResultRequirement", reader, observationResultRequirementElementIndex++));
                    break;
                case "transform":
                    position = checkElementOrder("transform", 55, position, false);
                    builder.transform((Canonical) parseUri(Canonical.builder(), "transform", reader, -1));
                    break;
                case "dynamicValue":
                    position = checkElementOrder("dynamicValue", 56, position, true);
                    builder.dynamicValue(parseActivityDefinitionDynamicValue("dynamicValue", reader, dynamicValueElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ActivityDefinition.DynamicValue parseActivityDefinitionDynamicValue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ActivityDefinition.DynamicValue.Builder builder = ActivityDefinition.DynamicValue.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ActivityDefinition.Participant parseActivityDefinitionParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ActivityDefinition.Participant.Builder builder = ActivityDefinition.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ActivityParticipantType) parseString(ActivityParticipantType.builder(), "type", reader, -1));
                    break;
                case "typeCanonical":
                    position = checkElementOrder("typeCanonical", 3, position, false);
                    builder.typeCanonical((Canonical) parseUri(Canonical.builder(), "typeCanonical", reader, -1));
                    break;
                case "typeReference":
                    position = checkElementOrder("typeReference", 4, position, false);
                    builder.typeReference(parseReference("typeReference", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 5, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "function":
                    position = checkElementOrder("function", 6, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ActorDefinition parseActorDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ActorDefinition.Builder builder = ActorDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, referenceElementIndex = 0, derivedFromElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 25, position, false);
                    builder.type((ExampleScenarioActorType) parseString(ExampleScenarioActorType.builder(), "type", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 26, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 27, position, true);
                    builder.reference((Url) parseUri(Url.builder(), "reference", reader, referenceElementIndex++));
                    break;
                case "capabilities":
                    position = checkElementOrder("capabilities", 28, position, false);
                    builder.capabilities((Canonical) parseUri(Canonical.builder(), "capabilities", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 29, position, true);
                    builder.derivedFrom((Canonical) parseUri(Canonical.builder(), "derivedFrom", reader, derivedFromElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Address parseAddress(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Address.Builder builder = Address.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, lineElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 1, position, false);
                    builder.use((AddressUse) parseString(AddressUse.builder(), "use", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((AddressType) parseString(AddressType.builder(), "type", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 3, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "line":
                    position = checkElementOrder("line", 4, position, true);
                    builder.line(parseString("line", reader, lineElementIndex++));
                    break;
                case "city":
                    position = checkElementOrder("city", 5, position, false);
                    builder.city(parseString("city", reader, -1));
                    break;
                case "district":
                    position = checkElementOrder("district", 6, position, false);
                    builder.district(parseString("district", reader, -1));
                    break;
                case "state":
                    position = checkElementOrder("state", 7, position, false);
                    builder.state(parseString("state", reader, -1));
                    break;
                case "postalCode":
                    position = checkElementOrder("postalCode", 8, position, false);
                    builder.postalCode(parseString("postalCode", reader, -1));
                    break;
                case "country":
                    position = checkElementOrder("country", 9, position, false);
                    builder.country(parseString("country", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition parseAdministrableProductDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.Builder builder = AdministrableProductDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, formOfElementIndex = 0, producedFromElementIndex = 0, ingredientElementIndex = 0, propertyElementIndex = 0, routeOfAdministrationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "formOf":
                    position = checkElementOrder("formOf", 10, position, true);
                    builder.formOf(parseReference("formOf", reader, formOfElementIndex++));
                    break;
                case "administrableDoseForm":
                    position = checkElementOrder("administrableDoseForm", 11, position, false);
                    builder.administrableDoseForm(parseCodeableConcept("administrableDoseForm", reader, -1));
                    break;
                case "unitOfPresentation":
                    position = checkElementOrder("unitOfPresentation", 12, position, false);
                    builder.unitOfPresentation(parseCodeableConcept("unitOfPresentation", reader, -1));
                    break;
                case "producedFrom":
                    position = checkElementOrder("producedFrom", 13, position, true);
                    builder.producedFrom(parseReference("producedFrom", reader, producedFromElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 14, position, true);
                    builder.ingredient(parseCodeableConcept("ingredient", reader, ingredientElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 15, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 16, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "property":
                    position = checkElementOrder("property", 17, position, true);
                    builder.property(parseAdministrableProductDefinitionProperty("property", reader, propertyElementIndex++));
                    break;
                case "routeOfAdministration":
                    position = checkElementOrder("routeOfAdministration", 18, position, true);
                    builder.routeOfAdministration(parseAdministrableProductDefinitionRouteOfAdministration("routeOfAdministration", reader, routeOfAdministrationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition.Property parseAdministrableProductDefinitionProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.Property.Builder builder = AdministrableProductDefinition.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 4, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition.RouteOfAdministration parseAdministrableProductDefinitionRouteOfAdministration(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.RouteOfAdministration.Builder builder = AdministrableProductDefinition.RouteOfAdministration.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetSpeciesElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "firstDose":
                    position = checkElementOrder("firstDose", 3, position, false);
                    builder.firstDose(parseQuantity("firstDose", reader, -1));
                    break;
                case "maxSingleDose":
                    position = checkElementOrder("maxSingleDose", 4, position, false);
                    builder.maxSingleDose(parseQuantity("maxSingleDose", reader, -1));
                    break;
                case "maxDosePerDay":
                    position = checkElementOrder("maxDosePerDay", 5, position, false);
                    builder.maxDosePerDay(parseQuantity("maxDosePerDay", reader, -1));
                    break;
                case "maxDosePerTreatmentPeriod":
                    position = checkElementOrder("maxDosePerTreatmentPeriod", 6, position, false);
                    builder.maxDosePerTreatmentPeriod(parseRatio("maxDosePerTreatmentPeriod", reader, -1));
                    break;
                case "maxTreatmentPeriod":
                    position = checkElementOrder("maxTreatmentPeriod", 7, position, false);
                    builder.maxTreatmentPeriod((Duration) parseQuantity(Duration.builder(), "maxTreatmentPeriod", reader, -1));
                    break;
                case "targetSpecies":
                    position = checkElementOrder("targetSpecies", 8, position, true);
                    builder.targetSpecies(parseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies("targetSpecies", reader, targetSpeciesElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition.RouteOfAdministration.TargetSpecies parseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.Builder builder = AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, withdrawalPeriodElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "withdrawalPeriod":
                    position = checkElementOrder("withdrawalPeriod", 3, position, true);
                    builder.withdrawalPeriod(parseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod("withdrawalPeriod", reader, withdrawalPeriodElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.WithdrawalPeriod parseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.WithdrawalPeriod.Builder builder = AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.WithdrawalPeriod.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "tissue":
                    position = checkElementOrder("tissue", 2, position, false);
                    builder.tissue(parseCodeableConcept("tissue", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseQuantity("value", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 4, position, false);
                    builder.supportingInformation(parseString("supportingInformation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent parseAdverseEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.Builder builder = AdverseEvent.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, resultingEffectElementIndex = 0, outcomeElementIndex = 0, participantElementIndex = 0, studyElementIndex = 0, suspectEntityElementIndex = 0, contributingFactorElementIndex = 0, preventiveActionElementIndex = 0, mitigatingActionElementIndex = 0, supportingInfoElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((AdverseEventStatus) parseString(AdverseEventStatus.builder(), "status", reader, -1));
                    break;
                case "actuality":
                    position = checkElementOrder("actuality", 10, position, false);
                    builder.actuality((AdverseEventActuality) parseString(AdverseEventActuality.builder(), "actuality", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 12, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "detected":
                    position = checkElementOrder("detected", 16, position, false);
                    builder.detected(parseDateTime("detected", reader, -1));
                    break;
                case "recordedDate":
                    position = checkElementOrder("recordedDate", 17, position, false);
                    builder.recordedDate(parseDateTime("recordedDate", reader, -1));
                    break;
                case "resultingEffect":
                    position = checkElementOrder("resultingEffect", 18, position, true);
                    builder.resultingEffect(parseReference("resultingEffect", reader, resultingEffectElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 19, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "seriousness":
                    position = checkElementOrder("seriousness", 20, position, false);
                    builder.seriousness(parseCodeableConcept("seriousness", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 21, position, true);
                    builder.outcome(parseCodeableConcept("outcome", reader, outcomeElementIndex++));
                    break;
                case "recorder":
                    position = checkElementOrder("recorder", 22, position, false);
                    builder.recorder(parseReference("recorder", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 23, position, true);
                    builder.participant(parseAdverseEventParticipant("participant", reader, participantElementIndex++));
                    break;
                case "study":
                    position = checkElementOrder("study", 24, position, true);
                    builder.study(parseReference("study", reader, studyElementIndex++));
                    break;
                case "expectedInResearchStudy":
                    position = checkElementOrder("expectedInResearchStudy", 25, position, false);
                    builder.expectedInResearchStudy(parseBoolean("expectedInResearchStudy", reader, -1));
                    break;
                case "suspectEntity":
                    position = checkElementOrder("suspectEntity", 26, position, true);
                    builder.suspectEntity(parseAdverseEventSuspectEntity("suspectEntity", reader, suspectEntityElementIndex++));
                    break;
                case "contributingFactor":
                    position = checkElementOrder("contributingFactor", 27, position, true);
                    builder.contributingFactor(parseAdverseEventContributingFactor("contributingFactor", reader, contributingFactorElementIndex++));
                    break;
                case "preventiveAction":
                    position = checkElementOrder("preventiveAction", 28, position, true);
                    builder.preventiveAction(parseAdverseEventPreventiveAction("preventiveAction", reader, preventiveActionElementIndex++));
                    break;
                case "mitigatingAction":
                    position = checkElementOrder("mitigatingAction", 29, position, true);
                    builder.mitigatingAction(parseAdverseEventMitigatingAction("mitigatingAction", reader, mitigatingActionElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 30, position, true);
                    builder.supportingInfo(parseAdverseEventSupportingInfo("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 31, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent.ContributingFactor parseAdverseEventContributingFactor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.ContributingFactor.Builder builder = AdverseEvent.ContributingFactor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent.MitigatingAction parseAdverseEventMitigatingAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.MitigatingAction.Builder builder = AdverseEvent.MitigatingAction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent.Participant parseAdverseEventParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.Participant.Builder builder = AdverseEvent.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent.PreventiveAction parseAdverseEventPreventiveAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.PreventiveAction.Builder builder = AdverseEvent.PreventiveAction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent.SupportingInfo parseAdverseEventSupportingInfo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.SupportingInfo.Builder builder = AdverseEvent.SupportingInfo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent.SuspectEntity parseAdverseEventSuspectEntity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.SuspectEntity.Builder builder = AdverseEvent.SuspectEntity.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "instanceCodeableConcept":
                    position = checkElementOrder("instance[x]", 2, position, false);
                    builder.instance(parseCodeableConcept("instanceCodeableConcept", reader, -1));
                    break;
                case "instanceReference":
                    position = checkElementOrder("instance[x]", 2, position, false);
                    builder.instance(parseReference("instanceReference", reader, -1));
                    break;
                case "causality":
                    position = checkElementOrder("causality", 3, position, false);
                    builder.causality(parseAdverseEventSuspectEntityCausality("causality", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent.SuspectEntity.Causality parseAdverseEventSuspectEntityCausality(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.SuspectEntity.Causality.Builder builder = AdverseEvent.SuspectEntity.Causality.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "assessmentMethod":
                    position = checkElementOrder("assessmentMethod", 2, position, false);
                    builder.assessmentMethod(parseCodeableConcept("assessmentMethod", reader, -1));
                    break;
                case "entityRelatedness":
                    position = checkElementOrder("entityRelatedness", 3, position, false);
                    builder.entityRelatedness(parseCodeableConcept("entityRelatedness", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 4, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AllergyIntolerance parseAllergyIntolerance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AllergyIntolerance.Builder builder = AllergyIntolerance.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, participantElementIndex = 0, noteElementIndex = 0, reactionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "clinicalStatus":
                    position = checkElementOrder("clinicalStatus", 9, position, false);
                    builder.clinicalStatus(parseCodeableConcept("clinicalStatus", reader, -1));
                    break;
                case "verificationStatus":
                    position = checkElementOrder("verificationStatus", 10, position, false);
                    builder.verificationStatus(parseCodeableConcept("verificationStatus", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 12, position, true);
                    builder.category((AllergyIntoleranceCategory) parseString(AllergyIntoleranceCategory.builder(), "category", reader, categoryElementIndex++));
                    break;
                case "criticality":
                    position = checkElementOrder("criticality", 13, position, false);
                    builder.criticality((AllergyIntoleranceCriticality) parseString(AllergyIntoleranceCriticality.builder(), "criticality", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 14, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 15, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 16, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "onsetDateTime":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseDateTime("onsetDateTime", reader, -1));
                    break;
                case "onsetAge":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset((Age) parseQuantity(Age.builder(), "onsetAge", reader, -1));
                    break;
                case "onsetPeriod":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parsePeriod("onsetPeriod", reader, -1));
                    break;
                case "onsetRange":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseRange("onsetRange", reader, -1));
                    break;
                case "onsetString":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseString("onsetString", reader, -1));
                    break;
                case "recordedDate":
                    position = checkElementOrder("recordedDate", 18, position, false);
                    builder.recordedDate(parseDateTime("recordedDate", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 19, position, true);
                    builder.participant(parseAllergyIntoleranceParticipant("participant", reader, participantElementIndex++));
                    break;
                case "lastOccurrence":
                    position = checkElementOrder("lastOccurrence", 20, position, false);
                    builder.lastOccurrence(parseDateTime("lastOccurrence", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 21, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "reaction":
                    position = checkElementOrder("reaction", 22, position, true);
                    builder.reaction(parseAllergyIntoleranceReaction("reaction", reader, reactionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AllergyIntolerance.Participant parseAllergyIntoleranceParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AllergyIntolerance.Participant.Builder builder = AllergyIntolerance.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AllergyIntolerance.Reaction parseAllergyIntoleranceReaction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AllergyIntolerance.Reaction.Builder builder = AllergyIntolerance.Reaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, manifestationElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "substance":
                    position = checkElementOrder("substance", 2, position, false);
                    builder.substance(parseCodeableConcept("substance", reader, -1));
                    break;
                case "manifestation":
                    position = checkElementOrder("manifestation", 3, position, true);
                    builder.manifestation(parseCodeableReference("manifestation", reader, manifestationElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "onset":
                    position = checkElementOrder("onset", 5, position, false);
                    builder.onset(parseDateTime("onset", reader, -1));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 6, position, false);
                    builder.severity((AllergyIntoleranceSeverity) parseString(AllergyIntoleranceSeverity.builder(), "severity", reader, -1));
                    break;
                case "exposureRoute":
                    position = checkElementOrder("exposureRoute", 7, position, false);
                    builder.exposureRoute(parseCodeableConcept("exposureRoute", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 8, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Annotation parseAnnotation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Annotation.Builder builder = Annotation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "authorReference":
                    position = checkElementOrder("author[x]", 1, position, false);
                    builder.author(parseReference("authorReference", reader, -1));
                    break;
                case "authorString":
                    position = checkElementOrder("author[x]", 1, position, false);
                    builder.author(parseString("authorString", reader, -1));
                    break;
                case "time":
                    position = checkElementOrder("time", 2, position, false);
                    builder.time(parseDateTime("time", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 3, position, false);
                    builder.text((Markdown) parseString(Markdown.builder(), "text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Appointment parseAppointment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Appointment.Builder builder = Appointment.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, classElementIndex = 0, serviceCategoryElementIndex = 0, serviceTypeElementIndex = 0, specialtyElementIndex = 0, reasonElementIndex = 0, replacesElementIndex = 0, virtualServiceElementIndex = 0, supportingInformationElementIndex = 0, requestedPeriodElementIndex = 0, slotElementIndex = 0, accountElementIndex = 0, noteElementIndex = 0, patientInstructionElementIndex = 0, basedOnElementIndex = 0, participantElementIndex = 0, recurrenceTemplateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((AppointmentStatus) parseString(AppointmentStatus.builder(), "status", reader, -1));
                    break;
                case "cancellationReason":
                    position = checkElementOrder("cancellationReason", 10, position, false);
                    builder.cancellationReason(parseCodeableConcept("cancellationReason", reader, -1));
                    break;
                case "class":
                    position = checkElementOrder("class", 11, position, true);
                    builder.clazz(parseCodeableConcept("class", reader, classElementIndex++));
                    break;
                case "serviceCategory":
                    position = checkElementOrder("serviceCategory", 12, position, true);
                    builder.serviceCategory(parseCodeableConcept("serviceCategory", reader, serviceCategoryElementIndex++));
                    break;
                case "serviceType":
                    position = checkElementOrder("serviceType", 13, position, true);
                    builder.serviceType(parseCodeableReference("serviceType", reader, serviceTypeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 14, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "appointmentType":
                    position = checkElementOrder("appointmentType", 15, position, false);
                    builder.appointmentType(parseCodeableConcept("appointmentType", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 16, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 17, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 19, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "virtualService":
                    position = checkElementOrder("virtualService", 20, position, true);
                    builder.virtualService(parseVirtualServiceDetail("virtualService", reader, virtualServiceElementIndex++));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 21, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "previousAppointment":
                    position = checkElementOrder("previousAppointment", 22, position, false);
                    builder.previousAppointment(parseReference("previousAppointment", reader, -1));
                    break;
                case "originatingAppointment":
                    position = checkElementOrder("originatingAppointment", 23, position, false);
                    builder.originatingAppointment(parseReference("originatingAppointment", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 24, position, false);
                    builder.start(parseInstant("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 25, position, false);
                    builder.end(parseInstant("end", reader, -1));
                    break;
                case "minutesDuration":
                    position = checkElementOrder("minutesDuration", 26, position, false);
                    builder.minutesDuration((PositiveInt) parseInteger(PositiveInt.builder(), "minutesDuration", reader, -1));
                    break;
                case "requestedPeriod":
                    position = checkElementOrder("requestedPeriod", 27, position, true);
                    builder.requestedPeriod(parsePeriod("requestedPeriod", reader, requestedPeriodElementIndex++));
                    break;
                case "slot":
                    position = checkElementOrder("slot", 28, position, true);
                    builder.slot(parseReference("slot", reader, slotElementIndex++));
                    break;
                case "account":
                    position = checkElementOrder("account", 29, position, true);
                    builder.account(parseReference("account", reader, accountElementIndex++));
                    break;
                case "created":
                    position = checkElementOrder("created", 30, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "cancellationDate":
                    position = checkElementOrder("cancellationDate", 31, position, false);
                    builder.cancellationDate(parseDateTime("cancellationDate", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 32, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "patientInstruction":
                    position = checkElementOrder("patientInstruction", 33, position, true);
                    builder.patientInstruction(parseCodeableReference("patientInstruction", reader, patientInstructionElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 34, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 35, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 36, position, true);
                    builder.participant(parseAppointmentParticipant("participant", reader, participantElementIndex++));
                    break;
                case "recurrenceId":
                    position = checkElementOrder("recurrenceId", 37, position, false);
                    builder.recurrenceId((PositiveInt) parseInteger(PositiveInt.builder(), "recurrenceId", reader, -1));
                    break;
                case "occurrenceChanged":
                    position = checkElementOrder("occurrenceChanged", 38, position, false);
                    builder.occurrenceChanged(parseBoolean("occurrenceChanged", reader, -1));
                    break;
                case "recurrenceTemplate":
                    position = checkElementOrder("recurrenceTemplate", 39, position, true);
                    builder.recurrenceTemplate(parseAppointmentRecurrenceTemplate("recurrenceTemplate", reader, recurrenceTemplateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Appointment.Participant parseAppointmentParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Appointment.Participant.Builder builder = Appointment.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 4, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                case "required":
                    position = checkElementOrder("required", 5, position, false);
                    builder.required(parseBoolean("required", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 6, position, false);
                    builder.status((ParticipationStatus) parseString(ParticipationStatus.builder(), "status", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Appointment.RecurrenceTemplate parseAppointmentRecurrenceTemplate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Appointment.RecurrenceTemplate.Builder builder = Appointment.RecurrenceTemplate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, occurrenceDateElementIndex = 0, excludingDateElementIndex = 0, excludingRecurrenceIdElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "timezone":
                    position = checkElementOrder("timezone", 2, position, false);
                    builder.timezone(parseCodeableConcept("timezone", reader, -1));
                    break;
                case "recurrenceType":
                    position = checkElementOrder("recurrenceType", 3, position, false);
                    builder.recurrenceType(parseCodeableConcept("recurrenceType", reader, -1));
                    break;
                case "lastOccurrenceDate":
                    position = checkElementOrder("lastOccurrenceDate", 4, position, false);
                    builder.lastOccurrenceDate(parseDate("lastOccurrenceDate", reader, -1));
                    break;
                case "occurrenceCount":
                    position = checkElementOrder("occurrenceCount", 5, position, false);
                    builder.occurrenceCount((PositiveInt) parseInteger(PositiveInt.builder(), "occurrenceCount", reader, -1));
                    break;
                case "occurrenceDate":
                    position = checkElementOrder("occurrenceDate", 6, position, true);
                    builder.occurrenceDate(parseDate("occurrenceDate", reader, occurrenceDateElementIndex++));
                    break;
                case "weeklyTemplate":
                    position = checkElementOrder("weeklyTemplate", 7, position, false);
                    builder.weeklyTemplate(parseAppointmentRecurrenceTemplateWeeklyTemplate("weeklyTemplate", reader, -1));
                    break;
                case "monthlyTemplate":
                    position = checkElementOrder("monthlyTemplate", 8, position, false);
                    builder.monthlyTemplate(parseAppointmentRecurrenceTemplateMonthlyTemplate("monthlyTemplate", reader, -1));
                    break;
                case "yearlyTemplate":
                    position = checkElementOrder("yearlyTemplate", 9, position, false);
                    builder.yearlyTemplate(parseAppointmentRecurrenceTemplateYearlyTemplate("yearlyTemplate", reader, -1));
                    break;
                case "excludingDate":
                    position = checkElementOrder("excludingDate", 10, position, true);
                    builder.excludingDate(parseDate("excludingDate", reader, excludingDateElementIndex++));
                    break;
                case "excludingRecurrenceId":
                    position = checkElementOrder("excludingRecurrenceId", 11, position, true);
                    builder.excludingRecurrenceId((PositiveInt) parseInteger(PositiveInt.builder(), "excludingRecurrenceId", reader, excludingRecurrenceIdElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Appointment.RecurrenceTemplate.MonthlyTemplate parseAppointmentRecurrenceTemplateMonthlyTemplate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Appointment.RecurrenceTemplate.MonthlyTemplate.Builder builder = Appointment.RecurrenceTemplate.MonthlyTemplate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "dayOfMonth":
                    position = checkElementOrder("dayOfMonth", 2, position, false);
                    builder.dayOfMonth((PositiveInt) parseInteger(PositiveInt.builder(), "dayOfMonth", reader, -1));
                    break;
                case "nthWeekOfMonth":
                    position = checkElementOrder("nthWeekOfMonth", 3, position, false);
                    builder.nthWeekOfMonth(parseCoding("nthWeekOfMonth", reader, -1));
                    break;
                case "dayOfWeek":
                    position = checkElementOrder("dayOfWeek", 4, position, false);
                    builder.dayOfWeek(parseCoding("dayOfWeek", reader, -1));
                    break;
                case "monthInterval":
                    position = checkElementOrder("monthInterval", 5, position, false);
                    builder.monthInterval((PositiveInt) parseInteger(PositiveInt.builder(), "monthInterval", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Appointment.RecurrenceTemplate.WeeklyTemplate parseAppointmentRecurrenceTemplateWeeklyTemplate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Appointment.RecurrenceTemplate.WeeklyTemplate.Builder builder = Appointment.RecurrenceTemplate.WeeklyTemplate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "monday":
                    position = checkElementOrder("monday", 2, position, false);
                    builder.monday(parseBoolean("monday", reader, -1));
                    break;
                case "tuesday":
                    position = checkElementOrder("tuesday", 3, position, false);
                    builder.tuesday(parseBoolean("tuesday", reader, -1));
                    break;
                case "wednesday":
                    position = checkElementOrder("wednesday", 4, position, false);
                    builder.wednesday(parseBoolean("wednesday", reader, -1));
                    break;
                case "thursday":
                    position = checkElementOrder("thursday", 5, position, false);
                    builder.thursday(parseBoolean("thursday", reader, -1));
                    break;
                case "friday":
                    position = checkElementOrder("friday", 6, position, false);
                    builder.friday(parseBoolean("friday", reader, -1));
                    break;
                case "saturday":
                    position = checkElementOrder("saturday", 7, position, false);
                    builder.saturday(parseBoolean("saturday", reader, -1));
                    break;
                case "sunday":
                    position = checkElementOrder("sunday", 8, position, false);
                    builder.sunday(parseBoolean("sunday", reader, -1));
                    break;
                case "weekInterval":
                    position = checkElementOrder("weekInterval", 9, position, false);
                    builder.weekInterval((PositiveInt) parseInteger(PositiveInt.builder(), "weekInterval", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Appointment.RecurrenceTemplate.YearlyTemplate parseAppointmentRecurrenceTemplateYearlyTemplate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Appointment.RecurrenceTemplate.YearlyTemplate.Builder builder = Appointment.RecurrenceTemplate.YearlyTemplate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "yearInterval":
                    position = checkElementOrder("yearInterval", 2, position, false);
                    builder.yearInterval((PositiveInt) parseInteger(PositiveInt.builder(), "yearInterval", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AppointmentResponse parseAppointmentResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AppointmentResponse.Builder builder = AppointmentResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, participantTypeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "appointment":
                    position = checkElementOrder("appointment", 9, position, false);
                    builder.appointment(parseReference("appointment", reader, -1));
                    break;
                case "proposedNewTime":
                    position = checkElementOrder("proposedNewTime", 10, position, false);
                    builder.proposedNewTime(parseBoolean("proposedNewTime", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 11, position, false);
                    builder.start(parseInstant("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 12, position, false);
                    builder.end(parseInstant("end", reader, -1));
                    break;
                case "participantType":
                    position = checkElementOrder("participantType", 13, position, true);
                    builder.participantType(parseCodeableConcept("participantType", reader, participantTypeElementIndex++));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 14, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                case "participantStatus":
                    position = checkElementOrder("participantStatus", 15, position, false);
                    builder.participantStatus((ParticipantStatus) parseString(ParticipantStatus.builder(), "participantStatus", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 16, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                case "recurring":
                    position = checkElementOrder("recurring", 17, position, false);
                    builder.recurring(parseBoolean("recurring", reader, -1));
                    break;
                case "occurrenceDate":
                    position = checkElementOrder("occurrenceDate", 18, position, false);
                    builder.occurrenceDate(parseDate("occurrenceDate", reader, -1));
                    break;
                case "recurrenceId":
                    position = checkElementOrder("recurrenceId", 19, position, false);
                    builder.recurrenceId((PositiveInt) parseInteger(PositiveInt.builder(), "recurrenceId", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ArtifactAssessment parseArtifactAssessment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ArtifactAssessment.Builder builder = ArtifactAssessment.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 9, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "citeAsReference":
                    position = checkElementOrder("citeAs[x]", 10, position, false);
                    builder.citeAs(parseReference("citeAsReference", reader, -1));
                    break;
                case "citeAsMarkdown":
                    position = checkElementOrder("citeAs[x]", 10, position, false);
                    builder.citeAs((Markdown) parseString(Markdown.builder(), "citeAsMarkdown", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 11, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 12, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 13, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 14, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "artifactReference":
                    position = checkElementOrder("artifact[x]", 15, position, false);
                    builder.artifact(parseReference("artifactReference", reader, -1));
                    break;
                case "artifactCanonical":
                    position = checkElementOrder("artifact[x]", 15, position, false);
                    builder.artifact((Canonical) parseUri(Canonical.builder(), "artifactCanonical", reader, -1));
                    break;
                case "artifactUri":
                    position = checkElementOrder("artifact[x]", 15, position, false);
                    builder.artifact(parseUri("artifactUri", reader, -1));
                    break;
                case "content":
                    position = checkElementOrder("content", 16, position, true);
                    builder.content(parseArtifactAssessmentContent("content", reader, contentElementIndex++));
                    break;
                case "workflowStatus":
                    position = checkElementOrder("workflowStatus", 17, position, false);
                    builder.workflowStatus((WorkflowStatus) parseString(WorkflowStatus.builder(), "workflowStatus", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 18, position, false);
                    builder.disposition((Disposition) parseString(Disposition.builder(), "disposition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ArtifactAssessment.Content parseArtifactAssessmentContent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ArtifactAssessment.Content.Builder builder = ArtifactAssessment.Content.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, classifierElementIndex = 0, pathElementIndex = 0, relatedArtifactElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "informationType":
                    position = checkElementOrder("informationType", 2, position, false);
                    builder.informationType((InformationType) parseString(InformationType.builder(), "informationType", reader, -1));
                    break;
                case "summary":
                    position = checkElementOrder("summary", 3, position, false);
                    builder.summary((Markdown) parseString(Markdown.builder(), "summary", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 5, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 6, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 7, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "path":
                    position = checkElementOrder("path", 8, position, true);
                    builder.path(parseUri("path", reader, pathElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 9, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "freeToShare":
                    position = checkElementOrder("freeToShare", 10, position, false);
                    builder.freeToShare(parseBoolean("freeToShare", reader, -1));
                    break;
                case "component":
                    position = checkElementOrder("component", 11, position, true);
                    builder.component(parseArtifactAssessmentContent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Attachment parseAttachment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Attachment.Builder builder = Attachment.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "contentType":
                    position = checkElementOrder("contentType", 1, position, false);
                    builder.contentType((Code) parseString(Code.builder(), "contentType", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 3, position, false);
                    builder.data(parseBase64Binary("data", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 4, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                case "size":
                    position = checkElementOrder("size", 5, position, false);
                    builder.size(parseInteger64("size", reader, -1));
                    break;
                case "hash":
                    position = checkElementOrder("hash", 6, position, false);
                    builder.hash(parseBase64Binary("hash", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 7, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "creation":
                    position = checkElementOrder("creation", 8, position, false);
                    builder.creation(parseDateTime("creation", reader, -1));
                    break;
                case "height":
                    position = checkElementOrder("height", 9, position, false);
                    builder.height((PositiveInt) parseInteger(PositiveInt.builder(), "height", reader, -1));
                    break;
                case "width":
                    position = checkElementOrder("width", 10, position, false);
                    builder.width((PositiveInt) parseInteger(PositiveInt.builder(), "width", reader, -1));
                    break;
                case "frames":
                    position = checkElementOrder("frames", 11, position, false);
                    builder.frames((PositiveInt) parseInteger(PositiveInt.builder(), "frames", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 12, position, false);
                    builder.duration(parseDecimal("duration", reader, -1));
                    break;
                case "pages":
                    position = checkElementOrder("pages", 13, position, false);
                    builder.pages((PositiveInt) parseInteger(PositiveInt.builder(), "pages", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent parseAuditEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Builder builder = AuditEvent.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, categoryElementIndex = 0, authorizationElementIndex = 0, basedOnElementIndex = 0, agentElementIndex = 0, entityElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 8, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "action":
                    position = checkElementOrder("action", 10, position, false);
                    builder.action((AuditEventAction) parseString(AuditEventAction.builder(), "action", reader, -1));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 11, position, false);
                    builder.severity((AuditEventSeverity) parseString(AuditEventSeverity.builder(), "severity", reader, -1));
                    break;
                case "occurredPeriod":
                    position = checkElementOrder("occurred[x]", 12, position, false);
                    builder.occurred(parsePeriod("occurredPeriod", reader, -1));
                    break;
                case "occurredDateTime":
                    position = checkElementOrder("occurred[x]", 12, position, false);
                    builder.occurred(parseDateTime("occurredDateTime", reader, -1));
                    break;
                case "recorded":
                    position = checkElementOrder("recorded", 13, position, false);
                    builder.recorded(parseInstant("recorded", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 14, position, false);
                    builder.outcome(parseAuditEventOutcome("outcome", reader, -1));
                    break;
                case "authorization":
                    position = checkElementOrder("authorization", 15, position, true);
                    builder.authorization(parseCodeableConcept("authorization", reader, authorizationElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 16, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 17, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 18, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "agent":
                    position = checkElementOrder("agent", 19, position, true);
                    builder.agent(parseAuditEventAgent("agent", reader, agentElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 20, position, false);
                    builder.source(parseAuditEventSource("source", reader, -1));
                    break;
                case "entity":
                    position = checkElementOrder("entity", 21, position, true);
                    builder.entity(parseAuditEventEntity("entity", reader, entityElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Agent parseAuditEventAgent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Agent.Builder builder = AuditEvent.Agent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, roleElementIndex = 0, policyElementIndex = 0, authorizationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, true);
                    builder.role(parseCodeableConcept("role", reader, roleElementIndex++));
                    break;
                case "who":
                    position = checkElementOrder("who", 4, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "requestor":
                    position = checkElementOrder("requestor", 5, position, false);
                    builder.requestor(parseBoolean("requestor", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 6, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "policy":
                    position = checkElementOrder("policy", 7, position, true);
                    builder.policy(parseUri("policy", reader, policyElementIndex++));
                    break;
                case "networkReference":
                    position = checkElementOrder("network[x]", 8, position, false);
                    builder.network(parseReference("networkReference", reader, -1));
                    break;
                case "networkUri":
                    position = checkElementOrder("network[x]", 8, position, false);
                    builder.network(parseUri("networkUri", reader, -1));
                    break;
                case "networkString":
                    position = checkElementOrder("network[x]", 8, position, false);
                    builder.network(parseString("networkString", reader, -1));
                    break;
                case "authorization":
                    position = checkElementOrder("authorization", 9, position, true);
                    builder.authorization(parseCodeableConcept("authorization", reader, authorizationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Entity parseAuditEventEntity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Entity.Builder builder = AuditEvent.Entity.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, securityLabelElementIndex = 0, detailElementIndex = 0, agentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "what":
                    position = checkElementOrder("what", 2, position, false);
                    builder.what(parseReference("what", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "securityLabel":
                    position = checkElementOrder("securityLabel", 4, position, true);
                    builder.securityLabel(parseCodeableConcept("securityLabel", reader, securityLabelElementIndex++));
                    break;
                case "query":
                    position = checkElementOrder("query", 5, position, false);
                    builder.query(parseBase64Binary("query", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 6, position, true);
                    builder.detail(parseAuditEventEntityDetail("detail", reader, detailElementIndex++));
                    break;
                case "agent":
                    position = checkElementOrder("agent", 7, position, true);
                    builder.agent(parseAuditEventAgent("agent", reader, agentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Entity.Detail parseAuditEventEntityDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Entity.Detail.Builder builder = AuditEvent.Entity.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Outcome parseAuditEventOutcome(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Outcome.Builder builder = AuditEvent.Outcome.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCoding("code", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 3, position, true);
                    builder.detail(parseCodeableConcept("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Source parseAuditEventSource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Source.Builder builder = AuditEvent.Source.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "site":
                    position = checkElementOrder("site", 2, position, false);
                    builder.site(parseReference("site", reader, -1));
                    break;
                case "observer":
                    position = checkElementOrder("observer", 3, position, false);
                    builder.observer(parseReference("observer", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Availability parseAvailability(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Availability.Builder builder = Availability.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, availableTimeElementIndex = 0, notAvailableTimeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "availableTime":
                    position = checkElementOrder("availableTime", 1, position, true);
                    builder.availableTime(parseElement("availableTime", reader, availableTimeElementIndex++));
                    break;
                case "notAvailableTime":
                    position = checkElementOrder("notAvailableTime", 2, position, true);
                    builder.notAvailableTime(parseElement("notAvailableTime", reader, notAvailableTimeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

	private Base64Binary parseBase64Binary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Base64Binary.Builder builder = Base64Binary.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Basic parseBasic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Basic.Builder builder = Basic.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 10, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 11, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 12, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Binary parseBinary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Binary.Builder builder = Binary.builder();
        builder.setValidating(validating);
        int position = -1;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "contentType":
                    position = checkElementOrder("contentType", 4, position, false);
                    builder.contentType((Code) parseString(Code.builder(), "contentType", reader, -1));
                    break;
                case "securityContext":
                    position = checkElementOrder("securityContext", 5, position, false);
                    builder.securityContext(parseReference("securityContext", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 6, position, false);
                    builder.data(parseBase64Binary("data", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProduct parseBiologicallyDerivedProduct(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProduct.Builder builder = BiologicallyDerivedProduct.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, parentElementIndex = 0, requestElementIndex = 0, identifierElementIndex = 0, processingFacilityElementIndex = 0, propertyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "productCategory":
                    position = checkElementOrder("productCategory", 8, position, false);
                    builder.productCategory(parseCoding("productCategory", reader, -1));
                    break;
                case "productCode":
                    position = checkElementOrder("productCode", 9, position, false);
                    builder.productCode(parseCodeableConcept("productCode", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 10, position, true);
                    builder.parent(parseReference("parent", reader, parentElementIndex++));
                    break;
                case "request":
                    position = checkElementOrder("request", 11, position, true);
                    builder.request(parseReference("request", reader, requestElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 12, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "biologicalSourceEvent":
                    position = checkElementOrder("biologicalSourceEvent", 13, position, false);
                    builder.biologicalSourceEvent(parseIdentifier("biologicalSourceEvent", reader, -1));
                    break;
                case "processingFacility":
                    position = checkElementOrder("processingFacility", 14, position, true);
                    builder.processingFacility(parseReference("processingFacility", reader, processingFacilityElementIndex++));
                    break;
                case "division":
                    position = checkElementOrder("division", 15, position, false);
                    builder.division(parseString("division", reader, -1));
                    break;
                case "productStatus":
                    position = checkElementOrder("productStatus", 16, position, false);
                    builder.productStatus(parseCoding("productStatus", reader, -1));
                    break;
                case "expirationDate":
                    position = checkElementOrder("expirationDate", 17, position, false);
                    builder.expirationDate(parseDateTime("expirationDate", reader, -1));
                    break;
                case "collection":
                    position = checkElementOrder("collection", 18, position, false);
                    builder.collection(parseBiologicallyDerivedProductCollection("collection", reader, -1));
                    break;
                case "storageTempRequirements":
                    position = checkElementOrder("storageTempRequirements", 19, position, false);
                    builder.storageTempRequirements(parseRange("storageTempRequirements", reader, -1));
                    break;
                case "property":
                    position = checkElementOrder("property", 20, position, true);
                    builder.property(parseBiologicallyDerivedProductProperty("property", reader, propertyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProduct.Collection parseBiologicallyDerivedProductCollection(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProduct.Collection.Builder builder = BiologicallyDerivedProduct.Collection.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "collector":
                    position = checkElementOrder("collector", 2, position, false);
                    builder.collector(parseReference("collector", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                case "collectedDateTime":
                    position = checkElementOrder("collected[x]", 4, position, false);
                    builder.collected(parseDateTime("collectedDateTime", reader, -1));
                    break;
                case "collectedPeriod":
                    position = checkElementOrder("collected[x]", 4, position, false);
                    builder.collected(parsePeriod("collectedPeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProduct.Property parseBiologicallyDerivedProductProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProduct.Property.Builder builder = BiologicallyDerivedProduct.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProductDispense parseBiologicallyDerivedProductDispense(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProductDispense.Builder builder = BiologicallyDerivedProductDispense.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, performerElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((BiologicallyDerivedProductDispenseStatus) parseString(BiologicallyDerivedProductDispenseStatus.builder(), "status", reader, -1));
                    break;
                case "originRelationshipType":
                    position = checkElementOrder("originRelationshipType", 12, position, false);
                    builder.originRelationshipType(parseCodeableConcept("originRelationshipType", reader, -1));
                    break;
                case "product":
                    position = checkElementOrder("product", 13, position, false);
                    builder.product(parseReference("product", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 14, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "matchStatus":
                    position = checkElementOrder("matchStatus", 15, position, false);
                    builder.matchStatus(parseCodeableConcept("matchStatus", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 16, position, true);
                    builder.performer(parseBiologicallyDerivedProductDispensePerformer("performer", reader, performerElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 17, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 18, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "preparedDate":
                    position = checkElementOrder("preparedDate", 19, position, false);
                    builder.preparedDate(parseDateTime("preparedDate", reader, -1));
                    break;
                case "whenHandedOver":
                    position = checkElementOrder("whenHandedOver", 20, position, false);
                    builder.whenHandedOver(parseDateTime("whenHandedOver", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 21, position, false);
                    builder.destination(parseReference("destination", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 22, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "usageInstruction":
                    position = checkElementOrder("usageInstruction", 23, position, false);
                    builder.usageInstruction(parseString("usageInstruction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProductDispense.Performer parseBiologicallyDerivedProductDispensePerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProductDispense.Performer.Builder builder = BiologicallyDerivedProductDispense.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BodyStructure parseBodyStructure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BodyStructure.Builder builder = BodyStructure.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, includedStructureElementIndex = 0, excludedStructureElementIndex = 0, imageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "morphology":
                    position = checkElementOrder("morphology", 10, position, false);
                    builder.morphology(parseCodeableConcept("morphology", reader, -1));
                    break;
                case "includedStructure":
                    position = checkElementOrder("includedStructure", 11, position, true);
                    builder.includedStructure(parseBodyStructureIncludedStructure("includedStructure", reader, includedStructureElementIndex++));
                    break;
                case "excludedStructure":
                    position = checkElementOrder("excludedStructure", 12, position, true);
                    builder.excludedStructure(parseBodyStructureIncludedStructure("excludedStructure", reader, excludedStructureElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 13, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "image":
                    position = checkElementOrder("image", 14, position, true);
                    builder.image(parseAttachment("image", reader, imageElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 15, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BodyStructure.IncludedStructure parseBodyStructureIncludedStructure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BodyStructure.IncludedStructure.Builder builder = BodyStructure.IncludedStructure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, bodyLandmarkOrientationElementIndex = 0, spatialReferenceElementIndex = 0, qualifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "structure":
                    position = checkElementOrder("structure", 2, position, false);
                    builder.structure(parseCodeableConcept("structure", reader, -1));
                    break;
                case "laterality":
                    position = checkElementOrder("laterality", 3, position, false);
                    builder.laterality(parseCodeableConcept("laterality", reader, -1));
                    break;
                case "bodyLandmarkOrientation":
                    position = checkElementOrder("bodyLandmarkOrientation", 4, position, true);
                    builder.bodyLandmarkOrientation(parseBodyStructureIncludedStructureBodyLandmarkOrientation("bodyLandmarkOrientation", reader, bodyLandmarkOrientationElementIndex++));
                    break;
                case "spatialReference":
                    position = checkElementOrder("spatialReference", 5, position, true);
                    builder.spatialReference(parseReference("spatialReference", reader, spatialReferenceElementIndex++));
                    break;
                case "qualifier":
                    position = checkElementOrder("qualifier", 6, position, true);
                    builder.qualifier(parseCodeableConcept("qualifier", reader, qualifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BodyStructure.IncludedStructure.BodyLandmarkOrientation parseBodyStructureIncludedStructureBodyLandmarkOrientation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BodyStructure.IncludedStructure.BodyLandmarkOrientation.Builder builder = BodyStructure.IncludedStructure.BodyLandmarkOrientation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, landmarkDescriptionElementIndex = 0, clockFacePositionElementIndex = 0, distanceFromLandmarkElementIndex = 0, surfaceOrientationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "landmarkDescription":
                    position = checkElementOrder("landmarkDescription", 2, position, true);
                    builder.landmarkDescription(parseCodeableConcept("landmarkDescription", reader, landmarkDescriptionElementIndex++));
                    break;
                case "clockFacePosition":
                    position = checkElementOrder("clockFacePosition", 3, position, true);
                    builder.clockFacePosition(parseCodeableConcept("clockFacePosition", reader, clockFacePositionElementIndex++));
                    break;
                case "distanceFromLandmark":
                    position = checkElementOrder("distanceFromLandmark", 4, position, true);
                    builder.distanceFromLandmark(parseBodyStructureIncludedStructureBodyLandmarkOrientationDistanceFromLandmark("distanceFromLandmark", reader, distanceFromLandmarkElementIndex++));
                    break;
                case "surfaceOrientation":
                    position = checkElementOrder("surfaceOrientation", 5, position, true);
                    builder.surfaceOrientation(parseCodeableConcept("surfaceOrientation", reader, surfaceOrientationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BodyStructure.IncludedStructure.BodyLandmarkOrientation.DistanceFromLandmark parseBodyStructureIncludedStructureBodyLandmarkOrientationDistanceFromLandmark(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BodyStructure.IncludedStructure.BodyLandmarkOrientation.DistanceFromLandmark.Builder builder = BodyStructure.IncludedStructure.BodyLandmarkOrientation.DistanceFromLandmark.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, deviceElementIndex = 0, valueElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 2, position, true);
                    builder.device(parseCodeableReference("device", reader, deviceElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, true);
                    builder.value(parseQuantity("value", reader, valueElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Boolean parseBoolean(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Boolean.Builder builder = Boolean.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle parseBundle(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Builder builder = Bundle.builder();
        builder.setValidating(validating);
        int position = -1;
        int linkElementIndex = 0, entryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 4, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type((BundleType) parseString(BundleType.builder(), "type", reader, -1));
                    break;
                case "timestamp":
                    position = checkElementOrder("timestamp", 6, position, false);
                    builder.timestamp(parseInstant("timestamp", reader, -1));
                    break;
                case "total":
                    position = checkElementOrder("total", 7, position, false);
                    builder.total((UnsignedInt) parseInteger(UnsignedInt.builder(), "total", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 8, position, true);
                    builder.link(parseBundleLink("link", reader, linkElementIndex++));
                    break;
                case "entry":
                    position = checkElementOrder("entry", 9, position, true);
                    builder.entry(parseBundleEntry("entry", reader, entryElementIndex++));
                    break;
                case "signature":
                    position = checkElementOrder("signature", 10, position, false);
                    builder.signature(parseSignature("signature", reader, -1));
                    break;
                case "issues":
                    position = checkElementOrder("issues", 11, position, false);
                    builder.issues(parseOperationOutcome("issues", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Entry parseBundleEntry(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Entry.Builder builder = Bundle.Entry.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "link":
                    position = checkElementOrder("link", 2, position, true);
                    builder.link(parseBundleLink("link", reader, linkElementIndex++));
                    break;
                case "fullUrl":
                    position = checkElementOrder("fullUrl", 3, position, false);
                    builder.fullUrl(parseUri("fullUrl", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 4, position, false);
                    builder.resource(parseResource("resource", reader, -1));
                    break;
                case "search":
                    position = checkElementOrder("search", 5, position, false);
                    builder.search(parseBundleEntrySearch("search", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 6, position, false);
                    builder.request(parseBundleEntryRequest("request", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 7, position, false);
                    builder.response(parseBundleEntryResponse("response", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Entry.Request parseBundleEntryRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Entry.Request.Builder builder = Bundle.Entry.Request.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "method":
                    position = checkElementOrder("method", 2, position, false);
                    builder.method((HTTPVerb) parseString(HTTPVerb.builder(), "method", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "ifNoneMatch":
                    position = checkElementOrder("ifNoneMatch", 4, position, false);
                    builder.ifNoneMatch(parseString("ifNoneMatch", reader, -1));
                    break;
                case "ifModifiedSince":
                    position = checkElementOrder("ifModifiedSince", 5, position, false);
                    builder.ifModifiedSince(parseInstant("ifModifiedSince", reader, -1));
                    break;
                case "ifMatch":
                    position = checkElementOrder("ifMatch", 6, position, false);
                    builder.ifMatch(parseString("ifMatch", reader, -1));
                    break;
                case "ifNoneExist":
                    position = checkElementOrder("ifNoneExist", 7, position, false);
                    builder.ifNoneExist(parseString("ifNoneExist", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Entry.Response parseBundleEntryResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Entry.Response.Builder builder = Bundle.Entry.Response.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 2, position, false);
                    builder.status(parseString("status", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 3, position, false);
                    builder.location(parseUri("location", reader, -1));
                    break;
                case "etag":
                    position = checkElementOrder("etag", 4, position, false);
                    builder.etag(parseString("etag", reader, -1));
                    break;
                case "lastModified":
                    position = checkElementOrder("lastModified", 5, position, false);
                    builder.lastModified(parseInstant("lastModified", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 6, position, false);
                    builder.outcome(parseResource("outcome", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Entry.Search parseBundleEntrySearch(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Entry.Search.Builder builder = Bundle.Entry.Search.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((SearchEntryMode) parseString(SearchEntryMode.builder(), "mode", reader, -1));
                    break;
                case "score":
                    position = checkElementOrder("score", 3, position, false);
                    builder.score(parseDecimal("score", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Link parseBundleLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Link.Builder builder = Bundle.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relation":
                    position = checkElementOrder("relation", 2, position, false);
                    builder.relation((Code) parseString(Code.builder(), "relation", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement parseCapabilityStatement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Builder builder = CapabilityStatement.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, instantiatesElementIndex = 0, importsElementIndex = 0, formatElementIndex = 0, patchFormatElementIndex = 0, acceptLanguageElementIndex = 0, implementationGuideElementIndex = 0, restElementIndex = 0, messagingElementIndex = 0, documentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 25, position, false);
                    builder.kind((CapabilityStatementKind) parseString(CapabilityStatementKind.builder(), "kind", reader, -1));
                    break;
                case "instantiates":
                    position = checkElementOrder("instantiates", 26, position, true);
                    builder.instantiates((Canonical) parseUri(Canonical.builder(), "instantiates", reader, instantiatesElementIndex++));
                    break;
                case "imports":
                    position = checkElementOrder("imports", 27, position, true);
                    builder.imports((Canonical) parseUri(Canonical.builder(), "imports", reader, importsElementIndex++));
                    break;
                case "software":
                    position = checkElementOrder("software", 28, position, false);
                    builder.software(parseCapabilityStatementSoftware("software", reader, -1));
                    break;
                case "implementation":
                    position = checkElementOrder("implementation", 29, position, false);
                    builder.implementation(parseCapabilityStatementImplementation("implementation", reader, -1));
                    break;
                case "fhirVersion":
                    position = checkElementOrder("fhirVersion", 30, position, false);
                    builder.fhirVersion((FHIRVersion) parseString(FHIRVersion.builder(), "fhirVersion", reader, -1));
                    break;
                case "format":
                    position = checkElementOrder("format", 31, position, true);
                    builder.format((Code) parseString(Code.builder(), "format", reader, formatElementIndex++));
                    break;
                case "patchFormat":
                    position = checkElementOrder("patchFormat", 32, position, true);
                    builder.patchFormat((Code) parseString(Code.builder(), "patchFormat", reader, patchFormatElementIndex++));
                    break;
                case "acceptLanguage":
                    position = checkElementOrder("acceptLanguage", 33, position, true);
                    builder.acceptLanguage((Code) parseString(Code.builder(), "acceptLanguage", reader, acceptLanguageElementIndex++));
                    break;
                case "implementationGuide":
                    position = checkElementOrder("implementationGuide", 34, position, true);
                    builder.implementationGuide((Canonical) parseUri(Canonical.builder(), "implementationGuide", reader, implementationGuideElementIndex++));
                    break;
                case "rest":
                    position = checkElementOrder("rest", 35, position, true);
                    builder.rest(parseCapabilityStatementRest("rest", reader, restElementIndex++));
                    break;
                case "messaging":
                    position = checkElementOrder("messaging", 36, position, true);
                    builder.messaging(parseCapabilityStatementMessaging("messaging", reader, messagingElementIndex++));
                    break;
                case "document":
                    position = checkElementOrder("document", 37, position, true);
                    builder.document(parseCapabilityStatementDocument("document", reader, documentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Document parseCapabilityStatementDocument(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Document.Builder builder = CapabilityStatement.Document.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((DocumentMode) parseString(DocumentMode.builder(), "mode", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 4, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Implementation parseCapabilityStatementImplementation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Implementation.Builder builder = CapabilityStatement.Implementation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                case "custodian":
                    position = checkElementOrder("custodian", 4, position, false);
                    builder.custodian(parseReference("custodian", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Messaging parseCapabilityStatementMessaging(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Messaging.Builder builder = CapabilityStatement.Messaging.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, endpointElementIndex = 0, supportedMessageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 2, position, true);
                    builder.endpoint(parseCapabilityStatementMessagingEndpoint("endpoint", reader, endpointElementIndex++));
                    break;
                case "reliableCache":
                    position = checkElementOrder("reliableCache", 3, position, false);
                    builder.reliableCache((UnsignedInt) parseInteger(UnsignedInt.builder(), "reliableCache", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 4, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "supportedMessage":
                    position = checkElementOrder("supportedMessage", 5, position, true);
                    builder.supportedMessage(parseCapabilityStatementMessagingSupportedMessage("supportedMessage", reader, supportedMessageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Messaging.Endpoint parseCapabilityStatementMessagingEndpoint(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Messaging.Endpoint.Builder builder = CapabilityStatement.Messaging.Endpoint.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "protocol":
                    position = checkElementOrder("protocol", 2, position, false);
                    builder.protocol(parseCoding("protocol", reader, -1));
                    break;
                case "address":
                    position = checkElementOrder("address", 3, position, false);
                    builder.address((Url) parseUri(Url.builder(), "address", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Messaging.SupportedMessage parseCapabilityStatementMessagingSupportedMessage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Messaging.SupportedMessage.Builder builder = CapabilityStatement.Messaging.SupportedMessage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((EventCapabilityMode) parseString(EventCapabilityMode.builder(), "mode", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest parseCapabilityStatementRest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Builder builder = CapabilityStatement.Rest.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, resourceElementIndex = 0, interactionElementIndex = 0, searchParamElementIndex = 0, operationElementIndex = 0, compartmentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((RestfulCapabilityMode) parseString(RestfulCapabilityMode.builder(), "mode", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "security":
                    position = checkElementOrder("security", 4, position, false);
                    builder.security(parseCapabilityStatementRestSecurity("security", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 5, position, true);
                    builder.resource(parseCapabilityStatementRestResource("resource", reader, resourceElementIndex++));
                    break;
                case "interaction":
                    position = checkElementOrder("interaction", 6, position, true);
                    builder.interaction(parseCapabilityStatementRestInteraction("interaction", reader, interactionElementIndex++));
                    break;
                case "searchParam":
                    position = checkElementOrder("searchParam", 7, position, true);
                    builder.searchParam(parseCapabilityStatementRestResourceSearchParam("searchParam", reader, searchParamElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 8, position, true);
                    builder.operation(parseCapabilityStatementRestResourceOperation("operation", reader, operationElementIndex++));
                    break;
                case "compartment":
                    position = checkElementOrder("compartment", 9, position, true);
                    builder.compartment((Canonical) parseUri(Canonical.builder(), "compartment", reader, compartmentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Interaction parseCapabilityStatementRestInteraction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Interaction.Builder builder = CapabilityStatement.Rest.Interaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((SystemRestfulInteraction) parseString(SystemRestfulInteraction.builder(), "code", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Resource parseCapabilityStatementRestResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Resource.Builder builder = CapabilityStatement.Rest.Resource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, supportedProfileElementIndex = 0, interactionElementIndex = 0, referencePolicyElementIndex = 0, searchIncludeElementIndex = 0, searchRevIncludeElementIndex = 0, searchParamElementIndex = 0, operationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "type", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                case "supportedProfile":
                    position = checkElementOrder("supportedProfile", 4, position, true);
                    builder.supportedProfile((Canonical) parseUri(Canonical.builder(), "supportedProfile", reader, supportedProfileElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "interaction":
                    position = checkElementOrder("interaction", 6, position, true);
                    builder.interaction(parseCapabilityStatementRestResourceInteraction("interaction", reader, interactionElementIndex++));
                    break;
                case "versioning":
                    position = checkElementOrder("versioning", 7, position, false);
                    builder.versioning((ResourceVersionPolicy) parseString(ResourceVersionPolicy.builder(), "versioning", reader, -1));
                    break;
                case "readHistory":
                    position = checkElementOrder("readHistory", 8, position, false);
                    builder.readHistory(parseBoolean("readHistory", reader, -1));
                    break;
                case "updateCreate":
                    position = checkElementOrder("updateCreate", 9, position, false);
                    builder.updateCreate(parseBoolean("updateCreate", reader, -1));
                    break;
                case "conditionalCreate":
                    position = checkElementOrder("conditionalCreate", 10, position, false);
                    builder.conditionalCreate(parseBoolean("conditionalCreate", reader, -1));
                    break;
                case "conditionalRead":
                    position = checkElementOrder("conditionalRead", 11, position, false);
                    builder.conditionalRead((ConditionalReadStatus) parseString(ConditionalReadStatus.builder(), "conditionalRead", reader, -1));
                    break;
                case "conditionalUpdate":
                    position = checkElementOrder("conditionalUpdate", 12, position, false);
                    builder.conditionalUpdate(parseBoolean("conditionalUpdate", reader, -1));
                    break;
                case "conditionalPatch":
                    position = checkElementOrder("conditionalPatch", 13, position, false);
                    builder.conditionalPatch(parseBoolean("conditionalPatch", reader, -1));
                    break;
                case "conditionalDelete":
                    position = checkElementOrder("conditionalDelete", 14, position, false);
                    builder.conditionalDelete((ConditionalDeleteStatus) parseString(ConditionalDeleteStatus.builder(), "conditionalDelete", reader, -1));
                    break;
                case "referencePolicy":
                    position = checkElementOrder("referencePolicy", 15, position, true);
                    builder.referencePolicy((ReferenceHandlingPolicy) parseString(ReferenceHandlingPolicy.builder(), "referencePolicy", reader, referencePolicyElementIndex++));
                    break;
                case "searchInclude":
                    position = checkElementOrder("searchInclude", 16, position, true);
                    builder.searchInclude(parseString("searchInclude", reader, searchIncludeElementIndex++));
                    break;
                case "searchRevInclude":
                    position = checkElementOrder("searchRevInclude", 17, position, true);
                    builder.searchRevInclude(parseString("searchRevInclude", reader, searchRevIncludeElementIndex++));
                    break;
                case "searchParam":
                    position = checkElementOrder("searchParam", 18, position, true);
                    builder.searchParam(parseCapabilityStatementRestResourceSearchParam("searchParam", reader, searchParamElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 19, position, true);
                    builder.operation(parseCapabilityStatementRestResourceOperation("operation", reader, operationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Resource.Interaction parseCapabilityStatementRestResourceInteraction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Resource.Interaction.Builder builder = CapabilityStatement.Rest.Resource.Interaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((TypeRestfulInteraction) parseString(TypeRestfulInteraction.builder(), "code", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Resource.Operation parseCapabilityStatementRestResourceOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Resource.Operation.Builder builder = CapabilityStatement.Rest.Resource.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 4, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Resource.SearchParam parseCapabilityStatementRestResourceSearchParam(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Resource.SearchParam.Builder builder = CapabilityStatement.Rest.Resource.SearchParam.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type((SearchParamType) parseString(SearchParamType.builder(), "type", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Security parseCapabilityStatementRestSecurity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Security.Builder builder = CapabilityStatement.Rest.Security.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, serviceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "cors":
                    position = checkElementOrder("cors", 2, position, false);
                    builder.cors(parseBoolean("cors", reader, -1));
                    break;
                case "service":
                    position = checkElementOrder("service", 3, position, true);
                    builder.service(parseCodeableConcept("service", reader, serviceElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Software parseCapabilityStatementSoftware(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Software.Builder builder = CapabilityStatement.Software.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "releaseDate":
                    position = checkElementOrder("releaseDate", 4, position, false);
                    builder.releaseDate(parseDateTime("releaseDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CarePlan parseCarePlan(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CarePlan.Builder builder = CarePlan.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, replacesElementIndex = 0, partOfElementIndex = 0, categoryElementIndex = 0, contributorElementIndex = 0, careTeamElementIndex = 0, addressesElementIndex = 0, supportingInfoElementIndex = 0, goalElementIndex = 0, activityElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 12, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 13, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((CarePlanStatus) parseString(CarePlanStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((CarePlanIntent) parseString(CarePlanIntent.builder(), "intent", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 16, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 17, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 19, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 20, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 21, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 22, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "custodian":
                    position = checkElementOrder("custodian", 23, position, false);
                    builder.custodian(parseReference("custodian", reader, -1));
                    break;
                case "contributor":
                    position = checkElementOrder("contributor", 24, position, true);
                    builder.contributor(parseReference("contributor", reader, contributorElementIndex++));
                    break;
                case "careTeam":
                    position = checkElementOrder("careTeam", 25, position, true);
                    builder.careTeam(parseReference("careTeam", reader, careTeamElementIndex++));
                    break;
                case "addresses":
                    position = checkElementOrder("addresses", 26, position, true);
                    builder.addresses(parseCodeableReference("addresses", reader, addressesElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 27, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "goal":
                    position = checkElementOrder("goal", 28, position, true);
                    builder.goal(parseReference("goal", reader, goalElementIndex++));
                    break;
                case "activity":
                    position = checkElementOrder("activity", 29, position, true);
                    builder.activity(parseCarePlanActivity("activity", reader, activityElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 30, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CarePlan.Activity parseCarePlanActivity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CarePlan.Activity.Builder builder = CarePlan.Activity.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, performedActivityElementIndex = 0, progressElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "performedActivity":
                    position = checkElementOrder("performedActivity", 2, position, true);
                    builder.performedActivity(parseCodeableReference("performedActivity", reader, performedActivityElementIndex++));
                    break;
                case "progress":
                    position = checkElementOrder("progress", 3, position, true);
                    builder.progress(parseAnnotation("progress", reader, progressElementIndex++));
                    break;
                case "plannedActivityReference":
                    position = checkElementOrder("plannedActivityReference", 4, position, false);
                    builder.plannedActivityReference(parseReference("plannedActivityReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CareTeam parseCareTeam(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CareTeam.Builder builder = CareTeam.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, participantElementIndex = 0, reasonElementIndex = 0, managingOrganizationElementIndex = 0, telecomElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((CareTeamStatus) parseString(CareTeamStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 13, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 14, position, true);
                    builder.participant(parseCareTeamParticipant("participant", reader, participantElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 15, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 16, position, true);
                    builder.managingOrganization(parseReference("managingOrganization", reader, managingOrganizationElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 17, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 18, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CareTeam.Participant parseCareTeamParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CareTeam.Participant.Builder builder = CareTeam.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "member":
                    position = checkElementOrder("member", 3, position, false);
                    builder.member(parseReference("member", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 4, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                case "coveragePeriod":
                    position = checkElementOrder("coverage[x]", 5, position, false);
                    builder.coverage(parsePeriod("coveragePeriod", reader, -1));
                    break;
                case "coverageTiming":
                    position = checkElementOrder("coverage[x]", 5, position, false);
                    builder.coverage(parseTiming("coverageTiming", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItem parseChargeItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItem.Builder builder = ChargeItem.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, definitionUriElementIndex = 0, definitionCanonicalElementIndex = 0, partOfElementIndex = 0, performerElementIndex = 0, bodysiteElementIndex = 0, reasonElementIndex = 0, serviceElementIndex = 0, productElementIndex = 0, accountElementIndex = 0, noteElementIndex = 0, supportingInformationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "definitionUri":
                    position = checkElementOrder("definitionUri", 9, position, true);
                    builder.definitionUri(parseUri("definitionUri", reader, definitionUriElementIndex++));
                    break;
                case "definitionCanonical":
                    position = checkElementOrder("definitionCanonical", 10, position, true);
                    builder.definitionCanonical((Canonical) parseUri(Canonical.builder(), "definitionCanonical", reader, definitionCanonicalElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((ChargeItemStatus) parseString(ChargeItemStatus.builder(), "status", reader, -1));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 12, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 13, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 15, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 17, position, true);
                    builder.performer(parseChargeItemPerformer("performer", reader, performerElementIndex++));
                    break;
                case "performingOrganization":
                    position = checkElementOrder("performingOrganization", 18, position, false);
                    builder.performingOrganization(parseReference("performingOrganization", reader, -1));
                    break;
                case "requestingOrganization":
                    position = checkElementOrder("requestingOrganization", 19, position, false);
                    builder.requestingOrganization(parseReference("requestingOrganization", reader, -1));
                    break;
                case "costCenter":
                    position = checkElementOrder("costCenter", 20, position, false);
                    builder.costCenter(parseReference("costCenter", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 21, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "bodysite":
                    position = checkElementOrder("bodysite", 22, position, true);
                    builder.bodysite(parseCodeableConcept("bodysite", reader, bodysiteElementIndex++));
                    break;
                case "unitPriceComponent":
                    position = checkElementOrder("unitPriceComponent", 23, position, false);
                    builder.unitPriceComponent(parseMonetaryComponent("unitPriceComponent", reader, -1));
                    break;
                case "totalPriceComponent":
                    position = checkElementOrder("totalPriceComponent", 24, position, false);
                    builder.totalPriceComponent(parseMonetaryComponent("totalPriceComponent", reader, -1));
                    break;
                case "overrideReason":
                    position = checkElementOrder("overrideReason", 25, position, false);
                    builder.overrideReason(parseCodeableConcept("overrideReason", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 26, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "enteredDate":
                    position = checkElementOrder("enteredDate", 27, position, false);
                    builder.enteredDate(parseDateTime("enteredDate", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 28, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                case "service":
                    position = checkElementOrder("service", 29, position, true);
                    builder.service(parseCodeableReference("service", reader, serviceElementIndex++));
                    break;
                case "product":
                    position = checkElementOrder("product", 30, position, true);
                    builder.product(parseCodeableReference("product", reader, productElementIndex++));
                    break;
                case "account":
                    position = checkElementOrder("account", 31, position, true);
                    builder.account(parseReference("account", reader, accountElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 32, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 33, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItem.Performer parseChargeItemPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItem.Performer.Builder builder = ChargeItem.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItemDefinition parseChargeItemDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItemDefinition.Builder builder = ChargeItemDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, derivedFromUriElementIndex = 0, partOfElementIndex = 0, replacesElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, instanceElementIndex = 0, applicabilityElementIndex = 0, propertyGroupElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "derivedFromUri":
                    position = checkElementOrder("derivedFromUri", 14, position, true);
                    builder.derivedFromUri(parseUri("derivedFromUri", reader, derivedFromUriElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 15, position, true);
                    builder.partOf((Canonical) parseUri(Canonical.builder(), "partOf", reader, partOfElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 16, position, true);
                    builder.replaces((Canonical) parseUri(Canonical.builder(), "replaces", reader, replacesElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 17, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 18, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 19, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 20, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 21, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 22, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 23, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 24, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 25, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 26, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 27, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 28, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 29, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 30, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 31, position, true);
                    builder.instance(parseReference("instance", reader, instanceElementIndex++));
                    break;
                case "applicability":
                    position = checkElementOrder("applicability", 32, position, true);
                    builder.applicability(parseChargeItemDefinitionApplicability("applicability", reader, applicabilityElementIndex++));
                    break;
                case "propertyGroup":
                    position = checkElementOrder("propertyGroup", 33, position, true);
                    builder.propertyGroup(parseChargeItemDefinitionPropertyGroup("propertyGroup", reader, propertyGroupElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItemDefinition.Applicability parseChargeItemDefinitionApplicability(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItemDefinition.Applicability.Builder builder = ChargeItemDefinition.Applicability.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 2, position, false);
                    builder.condition(parseExpression("condition", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 3, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 4, position, false);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItemDefinition.PropertyGroup parseChargeItemDefinitionPropertyGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItemDefinition.PropertyGroup.Builder builder = ChargeItemDefinition.PropertyGroup.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, applicabilityElementIndex = 0, priceComponentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "applicability":
                    position = checkElementOrder("applicability", 2, position, true);
                    builder.applicability(parseChargeItemDefinitionApplicability("applicability", reader, applicabilityElementIndex++));
                    break;
                case "priceComponent":
                    position = checkElementOrder("priceComponent", 3, position, true);
                    builder.priceComponent(parseMonetaryComponent("priceComponent", reader, priceComponentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation parseCitation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.Builder builder = Citation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, summaryElementIndex = 0, classificationElementIndex = 0, noteElementIndex = 0, currentStateElementIndex = 0, statusDateElementIndex = 0, relatedArtifactElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 25, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 26, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 27, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 28, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 29, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 30, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 31, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "summary":
                    position = checkElementOrder("summary", 32, position, true);
                    builder.summary(parseCitationSummary("summary", reader, summaryElementIndex++));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 33, position, true);
                    builder.classification(parseCitationClassification("classification", reader, classificationElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 34, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "currentState":
                    position = checkElementOrder("currentState", 35, position, true);
                    builder.currentState(parseCodeableConcept("currentState", reader, currentStateElementIndex++));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 36, position, true);
                    builder.statusDate(parseCitationStatusDate("statusDate", reader, statusDateElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 37, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "citedArtifact":
                    position = checkElementOrder("citedArtifact", 38, position, false);
                    builder.citedArtifact(parseCitationCitedArtifact("citedArtifact", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact parseCitationCitedArtifact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Builder builder = Citation.CitedArtifact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, relatedIdentifierElementIndex = 0, currentStateElementIndex = 0, statusDateElementIndex = 0, titleElementIndex = 0, abstractElementIndex = 0, relatesToElementIndex = 0, publicationFormElementIndex = 0, webLocationElementIndex = 0, classificationElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "relatedIdentifier":
                    position = checkElementOrder("relatedIdentifier", 3, position, true);
                    builder.relatedIdentifier(parseIdentifier("relatedIdentifier", reader, relatedIdentifierElementIndex++));
                    break;
                case "dateAccessed":
                    position = checkElementOrder("dateAccessed", 4, position, false);
                    builder.dateAccessed(parseDateTime("dateAccessed", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 5, position, false);
                    builder.version(parseCitationCitedArtifactVersion("version", reader, -1));
                    break;
                case "currentState":
                    position = checkElementOrder("currentState", 6, position, true);
                    builder.currentState(parseCodeableConcept("currentState", reader, currentStateElementIndex++));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 7, position, true);
                    builder.statusDate(parseCitationCitedArtifactStatusDate("statusDate", reader, statusDateElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 8, position, true);
                    builder.title(parseCitationCitedArtifactTitle("title", reader, titleElementIndex++));
                    break;
                case "abstract":
                    position = checkElementOrder("abstract", 9, position, true);
                    builder._abstract(parseCitationCitedArtifactAbstract("abstract", reader, abstractElementIndex++));
                    break;
                case "part":
                    position = checkElementOrder("part", 10, position, false);
                    builder.part(parseCitationCitedArtifactPart("part", reader, -1));
                    break;
                case "relatesTo":
                    position = checkElementOrder("relatesTo", 11, position, true);
                    builder.relatesTo(parseCitationCitedArtifactRelatesTo("relatesTo", reader, relatesToElementIndex++));
                    break;
                case "publicationForm":
                    position = checkElementOrder("publicationForm", 12, position, true);
                    builder.publicationForm(parseCitationCitedArtifactPublicationForm("publicationForm", reader, publicationFormElementIndex++));
                    break;
                case "webLocation":
                    position = checkElementOrder("webLocation", 13, position, true);
                    builder.webLocation(parseCitationCitedArtifactWebLocation("webLocation", reader, webLocationElementIndex++));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 14, position, true);
                    builder.classification(parseCitationCitedArtifactClassification("classification", reader, classificationElementIndex++));
                    break;
                case "contributorship":
                    position = checkElementOrder("contributorship", 15, position, false);
                    builder.contributorship(parseCitationCitedArtifactContributorship("contributorship", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 16, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Abstract parseCitationCitedArtifactAbstract(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Abstract.Builder builder = Citation.CitedArtifact.Abstract.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text((Markdown) parseString(Markdown.builder(), "text", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 5, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Classification parseCitationCitedArtifactClassification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Classification.Builder builder = Citation.CitedArtifact.Classification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, classifierElementIndex = 0, artifactAssessmentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 3, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                case "artifactAssessment":
                    position = checkElementOrder("artifactAssessment", 4, position, true);
                    builder.artifactAssessment(parseReference("artifactAssessment", reader, artifactAssessmentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Contributorship parseCitationCitedArtifactContributorship(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Contributorship.Builder builder = Citation.CitedArtifact.Contributorship.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, entryElementIndex = 0, summaryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "complete":
                    position = checkElementOrder("complete", 2, position, false);
                    builder.complete(parseBoolean("complete", reader, -1));
                    break;
                case "entry":
                    position = checkElementOrder("entry", 3, position, true);
                    builder.entry(parseCitationCitedArtifactContributorshipEntry("entry", reader, entryElementIndex++));
                    break;
                case "summary":
                    position = checkElementOrder("summary", 4, position, true);
                    builder.summary(parseCitationCitedArtifactContributorshipSummary("summary", reader, summaryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Contributorship.Entry parseCitationCitedArtifactContributorshipEntry(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Contributorship.Entry.Builder builder = Citation.CitedArtifact.Contributorship.Entry.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, affiliationElementIndex = 0, contributionTypeElementIndex = 0, contributionInstanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contributor":
                    position = checkElementOrder("contributor", 2, position, false);
                    builder.contributor(parseReference("contributor", reader, -1));
                    break;
                case "forenameInitials":
                    position = checkElementOrder("forenameInitials", 3, position, false);
                    builder.forenameInitials(parseString("forenameInitials", reader, -1));
                    break;
                case "affiliation":
                    position = checkElementOrder("affiliation", 4, position, true);
                    builder.affiliation(parseReference("affiliation", reader, affiliationElementIndex++));
                    break;
                case "contributionType":
                    position = checkElementOrder("contributionType", 5, position, true);
                    builder.contributionType(parseCodeableConcept("contributionType", reader, contributionTypeElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 6, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "contributionInstance":
                    position = checkElementOrder("contributionInstance", 7, position, true);
                    builder.contributionInstance(parseCitationCitedArtifactContributorshipEntryContributionInstance("contributionInstance", reader, contributionInstanceElementIndex++));
                    break;
                case "correspondingContact":
                    position = checkElementOrder("correspondingContact", 8, position, false);
                    builder.correspondingContact(parseBoolean("correspondingContact", reader, -1));
                    break;
                case "rankingOrder":
                    position = checkElementOrder("rankingOrder", 9, position, false);
                    builder.rankingOrder((PositiveInt) parseInteger(PositiveInt.builder(), "rankingOrder", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Contributorship.Entry.ContributionInstance parseCitationCitedArtifactContributorshipEntryContributionInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Contributorship.Entry.ContributionInstance.Builder builder = Citation.CitedArtifact.Contributorship.Entry.ContributionInstance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "time":
                    position = checkElementOrder("time", 3, position, false);
                    builder.time(parseDateTime("time", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Contributorship.Summary parseCitationCitedArtifactContributorshipSummary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Contributorship.Summary.Builder builder = Citation.CitedArtifact.Contributorship.Summary.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "style":
                    position = checkElementOrder("style", 3, position, false);
                    builder.style(parseCodeableConcept("style", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 4, position, false);
                    builder.source(parseCodeableConcept("source", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Part parseCitationCitedArtifactPart(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Part.Builder builder = Citation.CitedArtifact.Part.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "baseCitation":
                    position = checkElementOrder("baseCitation", 4, position, false);
                    builder.baseCitation(parseReference("baseCitation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.PublicationForm parseCitationCitedArtifactPublicationForm(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.PublicationForm.Builder builder = Citation.CitedArtifact.PublicationForm.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, languageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "publishedIn":
                    position = checkElementOrder("publishedIn", 2, position, false);
                    builder.publishedIn(parseCitationCitedArtifactPublicationFormPublishedIn("publishedIn", reader, -1));
                    break;
                case "citedMedium":
                    position = checkElementOrder("citedMedium", 3, position, false);
                    builder.citedMedium(parseCodeableConcept("citedMedium", reader, -1));
                    break;
                case "volume":
                    position = checkElementOrder("volume", 4, position, false);
                    builder.volume(parseString("volume", reader, -1));
                    break;
                case "issue":
                    position = checkElementOrder("issue", 5, position, false);
                    builder.issue(parseString("issue", reader, -1));
                    break;
                case "articleDate":
                    position = checkElementOrder("articleDate", 6, position, false);
                    builder.articleDate(parseDateTime("articleDate", reader, -1));
                    break;
                case "publicationDateText":
                    position = checkElementOrder("publicationDateText", 7, position, false);
                    builder.publicationDateText(parseString("publicationDateText", reader, -1));
                    break;
                case "publicationDateSeason":
                    position = checkElementOrder("publicationDateSeason", 8, position, false);
                    builder.publicationDateSeason(parseString("publicationDateSeason", reader, -1));
                    break;
                case "lastRevisionDate":
                    position = checkElementOrder("lastRevisionDate", 9, position, false);
                    builder.lastRevisionDate(parseDateTime("lastRevisionDate", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 10, position, true);
                    builder.language(parseCodeableConcept("language", reader, languageElementIndex++));
                    break;
                case "accessionNumber":
                    position = checkElementOrder("accessionNumber", 11, position, false);
                    builder.accessionNumber(parseString("accessionNumber", reader, -1));
                    break;
                case "pageString":
                    position = checkElementOrder("pageString", 12, position, false);
                    builder.pageString(parseString("pageString", reader, -1));
                    break;
                case "firstPage":
                    position = checkElementOrder("firstPage", 13, position, false);
                    builder.firstPage(parseString("firstPage", reader, -1));
                    break;
                case "lastPage":
                    position = checkElementOrder("lastPage", 14, position, false);
                    builder.lastPage(parseString("lastPage", reader, -1));
                    break;
                case "pageCount":
                    position = checkElementOrder("pageCount", 15, position, false);
                    builder.pageCount(parseString("pageCount", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 16, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.PublicationForm.PublishedIn parseCitationCitedArtifactPublicationFormPublishedIn(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.PublicationForm.PublishedIn.Builder builder = Citation.CitedArtifact.PublicationForm.PublishedIn.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 4, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 5, position, false);
                    builder.publisher(parseReference("publisher", reader, -1));
                    break;
                case "publisherLocation":
                    position = checkElementOrder("publisherLocation", 6, position, false);
                    builder.publisherLocation(parseString("publisherLocation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.RelatesTo parseCitationCitedArtifactRelatesTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.RelatesTo.Builder builder = Citation.CitedArtifact.RelatesTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, classifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((RelatedArtifactTypeExpanded) parseString(RelatedArtifactTypeExpanded.builder(), "type", reader, -1));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 3, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                case "label":
                    position = checkElementOrder("label", 4, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 5, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "citation":
                    position = checkElementOrder("citation", 6, position, false);
                    builder.citation((Markdown) parseString(Markdown.builder(), "citation", reader, -1));
                    break;
                case "document":
                    position = checkElementOrder("document", 7, position, false);
                    builder.document(parseAttachment("document", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 8, position, false);
                    builder.resource((Canonical) parseUri(Canonical.builder(), "resource", reader, -1));
                    break;
                case "resourceReference":
                    position = checkElementOrder("resourceReference", 9, position, false);
                    builder.resourceReference(parseReference("resourceReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.StatusDate parseCitationCitedArtifactStatusDate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.StatusDate.Builder builder = Citation.CitedArtifact.StatusDate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "activity":
                    position = checkElementOrder("activity", 2, position, false);
                    builder.activity(parseCodeableConcept("activity", reader, -1));
                    break;
                case "actual":
                    position = checkElementOrder("actual", 3, position, false);
                    builder.actual(parseBoolean("actual", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Title parseCitationCitedArtifactTitle(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Title.Builder builder = Citation.CitedArtifact.Title.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text((Markdown) parseString(Markdown.builder(), "text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Version parseCitationCitedArtifactVersion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Version.Builder builder = Citation.CitedArtifact.Version.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 2, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "baseCitation":
                    position = checkElementOrder("baseCitation", 3, position, false);
                    builder.baseCitation(parseReference("baseCitation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.WebLocation parseCitationCitedArtifactWebLocation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.WebLocation.Builder builder = Citation.CitedArtifact.WebLocation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, classifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 2, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.Classification parseCitationClassification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.Classification.Builder builder = Citation.Classification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, classifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 3, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.StatusDate parseCitationStatusDate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.StatusDate.Builder builder = Citation.StatusDate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "activity":
                    position = checkElementOrder("activity", 2, position, false);
                    builder.activity(parseCodeableConcept("activity", reader, -1));
                    break;
                case "actual":
                    position = checkElementOrder("actual", 3, position, false);
                    builder.actual(parseBoolean("actual", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.Summary parseCitationSummary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.Summary.Builder builder = Citation.Summary.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "style":
                    position = checkElementOrder("style", 2, position, false);
                    builder.style(parseCodeableConcept("style", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 3, position, false);
                    builder.text((Markdown) parseString(Markdown.builder(), "text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim parseClaim(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Builder builder = Claim.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, traceNumberElementIndex = 0, relatedElementIndex = 0, encounterElementIndex = 0, eventElementIndex = 0, careTeamElementIndex = 0, supportingInfoElementIndex = 0, diagnosisElementIndex = 0, procedureElementIndex = 0, insuranceElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 9, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((ClaimStatus) parseString(ClaimStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 12, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 13, position, false);
                    builder.use((Use) parseString(Use.builder(), "use", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 14, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "billablePeriod":
                    position = checkElementOrder("billablePeriod", 15, position, false);
                    builder.billablePeriod(parsePeriod("billablePeriod", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 16, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 17, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 18, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 19, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 20, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "fundsReserve":
                    position = checkElementOrder("fundsReserve", 21, position, false);
                    builder.fundsReserve(parseCodeableConcept("fundsReserve", reader, -1));
                    break;
                case "related":
                    position = checkElementOrder("related", 22, position, true);
                    builder.related(parseClaimRelated("related", reader, relatedElementIndex++));
                    break;
                case "prescription":
                    position = checkElementOrder("prescription", 23, position, false);
                    builder.prescription(parseReference("prescription", reader, -1));
                    break;
                case "originalPrescription":
                    position = checkElementOrder("originalPrescription", 24, position, false);
                    builder.originalPrescription(parseReference("originalPrescription", reader, -1));
                    break;
                case "payee":
                    position = checkElementOrder("payee", 25, position, false);
                    builder.payee(parseClaimPayee("payee", reader, -1));
                    break;
                case "referral":
                    position = checkElementOrder("referral", 26, position, false);
                    builder.referral(parseReference("referral", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 27, position, true);
                    builder.encounter(parseReference("encounter", reader, encounterElementIndex++));
                    break;
                case "facility":
                    position = checkElementOrder("facility", 28, position, false);
                    builder.facility(parseReference("facility", reader, -1));
                    break;
                case "diagnosisRelatedGroup":
                    position = checkElementOrder("diagnosisRelatedGroup", 29, position, false);
                    builder.diagnosisRelatedGroup(parseCodeableConcept("diagnosisRelatedGroup", reader, -1));
                    break;
                case "event":
                    position = checkElementOrder("event", 30, position, true);
                    builder.event(parseClaimEvent("event", reader, eventElementIndex++));
                    break;
                case "careTeam":
                    position = checkElementOrder("careTeam", 31, position, true);
                    builder.careTeam(parseClaimCareTeam("careTeam", reader, careTeamElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 32, position, true);
                    builder.supportingInfo(parseClaimSupportingInfo("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 33, position, true);
                    builder.diagnosis(parseClaimDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 34, position, true);
                    builder.procedure(parseClaimProcedure("procedure", reader, procedureElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 35, position, true);
                    builder.insurance(parseClaimInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "accident":
                    position = checkElementOrder("accident", 36, position, false);
                    builder.accident(parseClaimAccident("accident", reader, -1));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 37, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 38, position, true);
                    builder.item(parseClaimItem("item", reader, itemElementIndex++));
                    break;
                case "total":
                    position = checkElementOrder("total", 39, position, false);
                    builder.total(parseMoney("total", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Accident parseClaimAccident(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Accident.Builder builder = Claim.Accident.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 2, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 4, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 4, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.CareTeam parseClaimCareTeam(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.CareTeam.Builder builder = Claim.CareTeam.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 3, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 4, position, false);
                    builder.responsible(parseBoolean("responsible", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 5, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 6, position, false);
                    builder.specialty(parseCodeableConcept("specialty", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Diagnosis parseClaimDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Diagnosis.Builder builder = Claim.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "diagnosisCodeableConcept":
                    position = checkElementOrder("diagnosis[x]", 3, position, false);
                    builder.diagnosis(parseCodeableConcept("diagnosisCodeableConcept", reader, -1));
                    break;
                case "diagnosisReference":
                    position = checkElementOrder("diagnosis[x]", 3, position, false);
                    builder.diagnosis(parseReference("diagnosisReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "onAdmission":
                    position = checkElementOrder("onAdmission", 5, position, false);
                    builder.onAdmission(parseCodeableConcept("onAdmission", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Event parseClaimEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Event.Builder builder = Claim.Event.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "whenDateTime":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parseDateTime("whenDateTime", reader, -1));
                    break;
                case "whenPeriod":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parsePeriod("whenPeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Insurance parseClaimInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Insurance.Builder builder = Claim.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, preAuthRefElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "focal":
                    position = checkElementOrder("focal", 3, position, false);
                    builder.focal(parseBoolean("focal", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 4, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 5, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "businessArrangement":
                    position = checkElementOrder("businessArrangement", 6, position, false);
                    builder.businessArrangement(parseString("businessArrangement", reader, -1));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 7, position, true);
                    builder.preAuthRef(parseString("preAuthRef", reader, preAuthRefElementIndex++));
                    break;
                case "claimResponse":
                    position = checkElementOrder("claimResponse", 8, position, false);
                    builder.claimResponse(parseReference("claimResponse", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Item parseClaimItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Item.Builder builder = Claim.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, careTeamSequenceElementIndex = 0, diagnosisSequenceElementIndex = 0, procedureSequenceElementIndex = 0, informationSequenceElementIndex = 0, requestElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, bodySiteElementIndex = 0, encounterElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 3, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "careTeamSequence":
                    position = checkElementOrder("careTeamSequence", 4, position, true);
                    builder.careTeamSequence((PositiveInt) parseInteger(PositiveInt.builder(), "careTeamSequence", reader, careTeamSequenceElementIndex++));
                    break;
                case "diagnosisSequence":
                    position = checkElementOrder("diagnosisSequence", 5, position, true);
                    builder.diagnosisSequence((PositiveInt) parseInteger(PositiveInt.builder(), "diagnosisSequence", reader, diagnosisSequenceElementIndex++));
                    break;
                case "procedureSequence":
                    position = checkElementOrder("procedureSequence", 6, position, true);
                    builder.procedureSequence((PositiveInt) parseInteger(PositiveInt.builder(), "procedureSequence", reader, procedureSequenceElementIndex++));
                    break;
                case "informationSequence":
                    position = checkElementOrder("informationSequence", 7, position, true);
                    builder.informationSequence((PositiveInt) parseInteger(PositiveInt.builder(), "informationSequence", reader, informationSequenceElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 8, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 9, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 10, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 11, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 12, position, true);
                    builder.request(parseReference("request", reader, requestElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 13, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 14, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 15, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 15, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "locationCodeableConcept":
                    position = checkElementOrder("location[x]", 16, position, false);
                    builder.location(parseCodeableConcept("locationCodeableConcept", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 16, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 16, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 17, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 18, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 19, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 20, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 21, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 22, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 23, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 24, position, true);
                    builder.bodySite(parseClaimItemBodySite("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 25, position, true);
                    builder.encounter(parseReference("encounter", reader, encounterElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 26, position, true);
                    builder.detail(parseClaimItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Item.BodySite parseClaimItemBodySite(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Item.BodySite.Builder builder = Claim.Item.BodySite.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, siteElementIndex = 0, subSiteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "site":
                    position = checkElementOrder("site", 2, position, true);
                    builder.site(parseCodeableReference("site", reader, siteElementIndex++));
                    break;
                case "subSite":
                    position = checkElementOrder("subSite", 3, position, true);
                    builder.subSite(parseCodeableConcept("subSite", reader, subSiteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Item.Detail parseClaimItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Item.Detail.Builder builder = Claim.Item.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 3, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 4, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 5, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 6, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 7, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 8, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 9, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 10, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 11, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 12, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 13, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 14, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 15, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 16, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 17, position, true);
                    builder.subDetail(parseClaimItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Item.Detail.SubDetail parseClaimItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Item.Detail.SubDetail.Builder builder = Claim.Item.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 3, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 4, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 5, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 6, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 7, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 8, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 9, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 10, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 11, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 12, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 13, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 14, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 15, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 16, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Payee parseClaimPayee(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Payee.Builder builder = Claim.Payee.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "party":
                    position = checkElementOrder("party", 3, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Procedure parseClaimProcedure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Procedure.Builder builder = Claim.Procedure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, udiElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 4, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "procedureCodeableConcept":
                    position = checkElementOrder("procedure[x]", 5, position, false);
                    builder.procedure(parseCodeableConcept("procedureCodeableConcept", reader, -1));
                    break;
                case "procedureReference":
                    position = checkElementOrder("procedure[x]", 5, position, false);
                    builder.procedure(parseReference("procedureReference", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 6, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Related parseClaimRelated(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Related.Builder builder = Claim.Related.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "claim":
                    position = checkElementOrder("claim", 2, position, false);
                    builder.claim(parseReference("claim", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 3, position, false);
                    builder.relationship(parseCodeableConcept("relationship", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 4, position, false);
                    builder.reference(parseIdentifier("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.SupportingInfo parseClaimSupportingInfo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.SupportingInfo.Builder builder = Claim.SupportingInfo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 3, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 4, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "timingDate":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parseDate("timingDate", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 7, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse parseClaimResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Builder builder = ClaimResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, traceNumberElementIndex = 0, eventElementIndex = 0, encounterElementIndex = 0, itemElementIndex = 0, addItemElementIndex = 0, adjudicationElementIndex = 0, totalElementIndex = 0, processNoteElementIndex = 0, communicationRequestElementIndex = 0, insuranceElementIndex = 0, errorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 9, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((ClaimResponseStatus) parseString(ClaimResponseStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 12, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 13, position, false);
                    builder.use((Use) parseString(Use.builder(), "use", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 14, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 15, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 16, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "requestor":
                    position = checkElementOrder("requestor", 17, position, false);
                    builder.requestor(parseReference("requestor", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 18, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 19, position, false);
                    builder.outcome((RemittanceOutcome) parseString(RemittanceOutcome.builder(), "outcome", reader, -1));
                    break;
                case "decision":
                    position = checkElementOrder("decision", 20, position, false);
                    builder.decision(parseCodeableConcept("decision", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 21, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 22, position, false);
                    builder.preAuthRef(parseString("preAuthRef", reader, -1));
                    break;
                case "preAuthPeriod":
                    position = checkElementOrder("preAuthPeriod", 23, position, false);
                    builder.preAuthPeriod(parsePeriod("preAuthPeriod", reader, -1));
                    break;
                case "event":
                    position = checkElementOrder("event", 24, position, true);
                    builder.event(parseClaimResponseEvent("event", reader, eventElementIndex++));
                    break;
                case "payeeType":
                    position = checkElementOrder("payeeType", 25, position, false);
                    builder.payeeType(parseCodeableConcept("payeeType", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 26, position, true);
                    builder.encounter(parseReference("encounter", reader, encounterElementIndex++));
                    break;
                case "diagnosisRelatedGroup":
                    position = checkElementOrder("diagnosisRelatedGroup", 27, position, false);
                    builder.diagnosisRelatedGroup(parseCodeableConcept("diagnosisRelatedGroup", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 28, position, true);
                    builder.item(parseClaimResponseItem("item", reader, itemElementIndex++));
                    break;
                case "addItem":
                    position = checkElementOrder("addItem", 29, position, true);
                    builder.addItem(parseClaimResponseAddItem("addItem", reader, addItemElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 30, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "total":
                    position = checkElementOrder("total", 31, position, true);
                    builder.total(parseClaimResponseTotal("total", reader, totalElementIndex++));
                    break;
                case "payment":
                    position = checkElementOrder("payment", 32, position, false);
                    builder.payment(parseClaimResponsePayment("payment", reader, -1));
                    break;
                case "fundsReserve":
                    position = checkElementOrder("fundsReserve", 33, position, false);
                    builder.fundsReserve(parseCodeableConcept("fundsReserve", reader, -1));
                    break;
                case "formCode":
                    position = checkElementOrder("formCode", 34, position, false);
                    builder.formCode(parseCodeableConcept("formCode", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 35, position, false);
                    builder.form(parseAttachment("form", reader, -1));
                    break;
                case "processNote":
                    position = checkElementOrder("processNote", 36, position, true);
                    builder.processNote(parseClaimResponseProcessNote("processNote", reader, processNoteElementIndex++));
                    break;
                case "communicationRequest":
                    position = checkElementOrder("communicationRequest", 37, position, true);
                    builder.communicationRequest(parseReference("communicationRequest", reader, communicationRequestElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 38, position, true);
                    builder.insurance(parseClaimResponseInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "error":
                    position = checkElementOrder("error", 39, position, true);
                    builder.error(parseClaimResponseError("error", reader, errorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.AddItem parseClaimResponseAddItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.AddItem.Builder builder = ClaimResponse.AddItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemSequenceElementIndex = 0, detailSequenceElementIndex = 0, subdetailSequenceElementIndex = 0, traceNumberElementIndex = 0, providerElementIndex = 0, requestElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, bodySiteElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemSequence":
                    position = checkElementOrder("itemSequence", 2, position, true);
                    builder.itemSequence((PositiveInt) parseInteger(PositiveInt.builder(), "itemSequence", reader, itemSequenceElementIndex++));
                    break;
                case "detailSequence":
                    position = checkElementOrder("detailSequence", 3, position, true);
                    builder.detailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "detailSequence", reader, detailSequenceElementIndex++));
                    break;
                case "subdetailSequence":
                    position = checkElementOrder("subdetailSequence", 4, position, true);
                    builder.subdetailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "subdetailSequence", reader, subdetailSequenceElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 5, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 6, position, true);
                    builder.provider(parseReference("provider", reader, providerElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 7, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 8, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 9, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 10, position, true);
                    builder.request(parseReference("request", reader, requestElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 11, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 12, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 13, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 13, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "locationCodeableConcept":
                    position = checkElementOrder("location[x]", 14, position, false);
                    builder.location(parseCodeableConcept("locationCodeableConcept", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 14, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 14, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 15, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 16, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 17, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 18, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 19, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 20, position, true);
                    builder.bodySite(parseClaimResponseAddItemBodySite("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 21, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 22, position, false);
                    builder.reviewOutcome(parseClaimResponseItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 23, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 24, position, true);
                    builder.detail(parseClaimResponseAddItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.AddItem.BodySite parseClaimResponseAddItemBodySite(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.AddItem.BodySite.Builder builder = ClaimResponse.AddItem.BodySite.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, siteElementIndex = 0, subSiteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "site":
                    position = checkElementOrder("site", 2, position, true);
                    builder.site(parseCodeableReference("site", reader, siteElementIndex++));
                    break;
                case "subSite":
                    position = checkElementOrder("subSite", 3, position, true);
                    builder.subSite(parseCodeableConcept("subSite", reader, subSiteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.AddItem.Detail parseClaimResponseAddItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.AddItem.Detail.Builder builder = ClaimResponse.AddItem.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, modifierElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 2, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 3, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 4, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 5, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 6, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 7, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 8, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 9, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 10, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 11, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 12, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 13, position, false);
                    builder.reviewOutcome(parseClaimResponseItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 14, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 15, position, true);
                    builder.subDetail(parseClaimResponseAddItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.AddItem.Detail.SubDetail parseClaimResponseAddItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.AddItem.Detail.SubDetail.Builder builder = ClaimResponse.AddItem.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, modifierElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 2, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 3, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 4, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 5, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 6, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 7, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 8, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 9, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 10, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 11, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 12, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 13, position, false);
                    builder.reviewOutcome(parseClaimResponseItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 14, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Error parseClaimResponseError(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Error.Builder builder = ClaimResponse.Error.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, expressionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemSequence":
                    position = checkElementOrder("itemSequence", 2, position, false);
                    builder.itemSequence((PositiveInt) parseInteger(PositiveInt.builder(), "itemSequence", reader, -1));
                    break;
                case "detailSequence":
                    position = checkElementOrder("detailSequence", 3, position, false);
                    builder.detailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "detailSequence", reader, -1));
                    break;
                case "subDetailSequence":
                    position = checkElementOrder("subDetailSequence", 4, position, false);
                    builder.subDetailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "subDetailSequence", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 5, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 6, position, true);
                    builder.expression(parseString("expression", reader, expressionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Event parseClaimResponseEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Event.Builder builder = ClaimResponse.Event.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "whenDateTime":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parseDateTime("whenDateTime", reader, -1));
                    break;
                case "whenPeriod":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parsePeriod("whenPeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Insurance parseClaimResponseInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Insurance.Builder builder = ClaimResponse.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "focal":
                    position = checkElementOrder("focal", 3, position, false);
                    builder.focal(parseBoolean("focal", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 4, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "businessArrangement":
                    position = checkElementOrder("businessArrangement", 5, position, false);
                    builder.businessArrangement(parseString("businessArrangement", reader, -1));
                    break;
                case "claimResponse":
                    position = checkElementOrder("claimResponse", 6, position, false);
                    builder.claimResponse(parseReference("claimResponse", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Item parseClaimResponseItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Item.Builder builder = ClaimResponse.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemSequence":
                    position = checkElementOrder("itemSequence", 2, position, false);
                    builder.itemSequence((PositiveInt) parseInteger(PositiveInt.builder(), "itemSequence", reader, -1));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 3, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 4, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 5, position, false);
                    builder.reviewOutcome(parseClaimResponseItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 6, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 7, position, true);
                    builder.detail(parseClaimResponseItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Item.Adjudication parseClaimResponseItemAdjudication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Item.Adjudication.Builder builder = ClaimResponse.Item.Adjudication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 4, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Item.Detail parseClaimResponseItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Item.Detail.Builder builder = ClaimResponse.Item.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "detailSequence":
                    position = checkElementOrder("detailSequence", 2, position, false);
                    builder.detailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "detailSequence", reader, -1));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 3, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 4, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 5, position, false);
                    builder.reviewOutcome(parseClaimResponseItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 6, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 7, position, true);
                    builder.subDetail(parseClaimResponseItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Item.Detail.SubDetail parseClaimResponseItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Item.Detail.SubDetail.Builder builder = ClaimResponse.Item.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "subDetailSequence":
                    position = checkElementOrder("subDetailSequence", 2, position, false);
                    builder.subDetailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "subDetailSequence", reader, -1));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 3, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 4, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 5, position, false);
                    builder.reviewOutcome(parseClaimResponseItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 6, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Item.ReviewOutcome parseClaimResponseItemReviewOutcome(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Item.ReviewOutcome.Builder builder = ClaimResponse.Item.ReviewOutcome.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, reasonElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "decision":
                    position = checkElementOrder("decision", 2, position, false);
                    builder.decision(parseCodeableConcept("decision", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 4, position, false);
                    builder.preAuthRef(parseString("preAuthRef", reader, -1));
                    break;
                case "preAuthPeriod":
                    position = checkElementOrder("preAuthPeriod", 5, position, false);
                    builder.preAuthPeriod(parsePeriod("preAuthPeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Payment parseClaimResponsePayment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Payment.Builder builder = ClaimResponse.Payment.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "adjustment":
                    position = checkElementOrder("adjustment", 3, position, false);
                    builder.adjustment(parseMoney("adjustment", reader, -1));
                    break;
                case "adjustmentReason":
                    position = checkElementOrder("adjustmentReason", 4, position, false);
                    builder.adjustmentReason(parseCodeableConcept("adjustmentReason", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 5, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 6, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 7, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.ProcessNote parseClaimResponseProcessNote(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.ProcessNote.Builder builder = ClaimResponse.ProcessNote.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "number":
                    position = checkElementOrder("number", 2, position, false);
                    builder.number((PositiveInt) parseInteger(PositiveInt.builder(), "number", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 5, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Total parseClaimResponseTotal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Total.Builder builder = ClaimResponse.Total.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalImpression parseClinicalImpression(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalImpression.Builder builder = ClinicalImpression.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, problemElementIndex = 0, protocolElementIndex = 0, findingElementIndex = 0, prognosisCodeableConceptElementIndex = 0, prognosisReferenceElementIndex = 0, supportingInfoElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ClinicalImpressionStatus) parseString(ClinicalImpressionStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 10, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 11, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 13, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "effectiveDateTime":
                    position = checkElementOrder("effective[x]", 14, position, false);
                    builder.effective(parseDateTime("effectiveDateTime", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effective[x]", 14, position, false);
                    builder.effective(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 16, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "previous":
                    position = checkElementOrder("previous", 17, position, false);
                    builder.previous(parseReference("previous", reader, -1));
                    break;
                case "problem":
                    position = checkElementOrder("problem", 18, position, true);
                    builder.problem(parseReference("problem", reader, problemElementIndex++));
                    break;
                case "changePattern":
                    position = checkElementOrder("changePattern", 19, position, false);
                    builder.changePattern(parseCodeableConcept("changePattern", reader, -1));
                    break;
                case "protocol":
                    position = checkElementOrder("protocol", 20, position, true);
                    builder.protocol(parseUri("protocol", reader, protocolElementIndex++));
                    break;
                case "summary":
                    position = checkElementOrder("summary", 21, position, false);
                    builder.summary(parseString("summary", reader, -1));
                    break;
                case "finding":
                    position = checkElementOrder("finding", 22, position, true);
                    builder.finding(parseClinicalImpressionFinding("finding", reader, findingElementIndex++));
                    break;
                case "prognosisCodeableConcept":
                    position = checkElementOrder("prognosisCodeableConcept", 23, position, true);
                    builder.prognosisCodeableConcept(parseCodeableConcept("prognosisCodeableConcept", reader, prognosisCodeableConceptElementIndex++));
                    break;
                case "prognosisReference":
                    position = checkElementOrder("prognosisReference", 24, position, true);
                    builder.prognosisReference(parseReference("prognosisReference", reader, prognosisReferenceElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 25, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 26, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalImpression.Finding parseClinicalImpressionFinding(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalImpression.Finding.Builder builder = ClinicalImpression.Finding.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 2, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 3, position, false);
                    builder.basis(parseString("basis", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition parseClinicalUseDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Builder builder = ClinicalUseDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, subjectElementIndex = 0, populationElementIndex = 0, libraryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type((ClinicalUseDefinitionType) parseString(ClinicalUseDefinitionType.builder(), "type", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 11, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "contraindication":
                    position = checkElementOrder("contraindication", 13, position, false);
                    builder.contraindication(parseClinicalUseDefinitionContraindication("contraindication", reader, -1));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 14, position, false);
                    builder.indication(parseClinicalUseDefinitionIndication("indication", reader, -1));
                    break;
                case "interaction":
                    position = checkElementOrder("interaction", 15, position, false);
                    builder.interaction(parseClinicalUseDefinitionInteraction("interaction", reader, -1));
                    break;
                case "population":
                    position = checkElementOrder("population", 16, position, true);
                    builder.population(parseReference("population", reader, populationElementIndex++));
                    break;
                case "library":
                    position = checkElementOrder("library", 17, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "undesirableEffect":
                    position = checkElementOrder("undesirableEffect", 18, position, false);
                    builder.undesirableEffect(parseClinicalUseDefinitionUndesirableEffect("undesirableEffect", reader, -1));
                    break;
                case "warning":
                    position = checkElementOrder("warning", 19, position, false);
                    builder.warning(parseClinicalUseDefinitionWarning("warning", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Contraindication parseClinicalUseDefinitionContraindication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Contraindication.Builder builder = ClinicalUseDefinition.Contraindication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, comorbidityElementIndex = 0, indicationElementIndex = 0, otherTherapyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "diseaseSymptomProcedure":
                    position = checkElementOrder("diseaseSymptomProcedure", 2, position, false);
                    builder.diseaseSymptomProcedure(parseCodeableReference("diseaseSymptomProcedure", reader, -1));
                    break;
                case "diseaseStatus":
                    position = checkElementOrder("diseaseStatus", 3, position, false);
                    builder.diseaseStatus(parseCodeableReference("diseaseStatus", reader, -1));
                    break;
                case "comorbidity":
                    position = checkElementOrder("comorbidity", 4, position, true);
                    builder.comorbidity(parseCodeableReference("comorbidity", reader, comorbidityElementIndex++));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 5, position, true);
                    builder.indication(parseReference("indication", reader, indicationElementIndex++));
                    break;
                case "applicability":
                    position = checkElementOrder("applicability", 6, position, false);
                    builder.applicability(parseExpression("applicability", reader, -1));
                    break;
                case "otherTherapy":
                    position = checkElementOrder("otherTherapy", 7, position, true);
                    builder.otherTherapy(parseClinicalUseDefinitionContraindicationOtherTherapy("otherTherapy", reader, otherTherapyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Contraindication.OtherTherapy parseClinicalUseDefinitionContraindicationOtherTherapy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Contraindication.OtherTherapy.Builder builder = ClinicalUseDefinition.Contraindication.OtherTherapy.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relationshipType":
                    position = checkElementOrder("relationshipType", 2, position, false);
                    builder.relationshipType(parseCodeableConcept("relationshipType", reader, -1));
                    break;
                case "treatment":
                    position = checkElementOrder("treatment", 3, position, false);
                    builder.treatment(parseCodeableReference("treatment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Indication parseClinicalUseDefinitionIndication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Indication.Builder builder = ClinicalUseDefinition.Indication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, comorbidityElementIndex = 0, undesirableEffectElementIndex = 0, otherTherapyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "diseaseSymptomProcedure":
                    position = checkElementOrder("diseaseSymptomProcedure", 2, position, false);
                    builder.diseaseSymptomProcedure(parseCodeableReference("diseaseSymptomProcedure", reader, -1));
                    break;
                case "diseaseStatus":
                    position = checkElementOrder("diseaseStatus", 3, position, false);
                    builder.diseaseStatus(parseCodeableReference("diseaseStatus", reader, -1));
                    break;
                case "comorbidity":
                    position = checkElementOrder("comorbidity", 4, position, true);
                    builder.comorbidity(parseCodeableReference("comorbidity", reader, comorbidityElementIndex++));
                    break;
                case "intendedEffect":
                    position = checkElementOrder("intendedEffect", 5, position, false);
                    builder.intendedEffect(parseCodeableReference("intendedEffect", reader, -1));
                    break;
                case "durationRange":
                    position = checkElementOrder("duration[x]", 6, position, false);
                    builder.duration(parseRange("durationRange", reader, -1));
                    break;
                case "durationString":
                    position = checkElementOrder("duration[x]", 6, position, false);
                    builder.duration(parseString("durationString", reader, -1));
                    break;
                case "undesirableEffect":
                    position = checkElementOrder("undesirableEffect", 7, position, true);
                    builder.undesirableEffect(parseReference("undesirableEffect", reader, undesirableEffectElementIndex++));
                    break;
                case "applicability":
                    position = checkElementOrder("applicability", 8, position, false);
                    builder.applicability(parseExpression("applicability", reader, -1));
                    break;
                case "otherTherapy":
                    position = checkElementOrder("otherTherapy", 9, position, true);
                    builder.otherTherapy(parseClinicalUseDefinitionContraindicationOtherTherapy("otherTherapy", reader, otherTherapyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Interaction parseClinicalUseDefinitionInteraction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Interaction.Builder builder = ClinicalUseDefinition.Interaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, interactantElementIndex = 0, managementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "interactant":
                    position = checkElementOrder("interactant", 2, position, true);
                    builder.interactant(parseClinicalUseDefinitionInteractionInteractant("interactant", reader, interactantElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "effect":
                    position = checkElementOrder("effect", 4, position, false);
                    builder.effect(parseCodeableReference("effect", reader, -1));
                    break;
                case "incidence":
                    position = checkElementOrder("incidence", 5, position, false);
                    builder.incidence(parseCodeableConcept("incidence", reader, -1));
                    break;
                case "management":
                    position = checkElementOrder("management", 6, position, true);
                    builder.management(parseCodeableConcept("management", reader, managementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Interaction.Interactant parseClinicalUseDefinitionInteractionInteractant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Interaction.Interactant.Builder builder = ClinicalUseDefinition.Interaction.Interactant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.UndesirableEffect parseClinicalUseDefinitionUndesirableEffect(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.UndesirableEffect.Builder builder = ClinicalUseDefinition.UndesirableEffect.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "symptomConditionEffect":
                    position = checkElementOrder("symptomConditionEffect", 2, position, false);
                    builder.symptomConditionEffect(parseCodeableReference("symptomConditionEffect", reader, -1));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 3, position, false);
                    builder.classification(parseCodeableConcept("classification", reader, -1));
                    break;
                case "frequencyOfOccurrence":
                    position = checkElementOrder("frequencyOfOccurrence", 4, position, false);
                    builder.frequencyOfOccurrence(parseCodeableConcept("frequencyOfOccurrence", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Warning parseClinicalUseDefinitionWarning(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Warning.Builder builder = ClinicalUseDefinition.Warning.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem parseCodeSystem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Builder builder = CodeSystem.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, filterElementIndex = 0, propertyElementIndex = 0, conceptElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 25, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 26, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 27, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 28, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 29, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 30, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 31, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 32, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 33, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "caseSensitive":
                    position = checkElementOrder("caseSensitive", 34, position, false);
                    builder.caseSensitive(parseBoolean("caseSensitive", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 35, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                case "hierarchyMeaning":
                    position = checkElementOrder("hierarchyMeaning", 36, position, false);
                    builder.hierarchyMeaning((CodeSystemHierarchyMeaning) parseString(CodeSystemHierarchyMeaning.builder(), "hierarchyMeaning", reader, -1));
                    break;
                case "compositional":
                    position = checkElementOrder("compositional", 37, position, false);
                    builder.compositional(parseBoolean("compositional", reader, -1));
                    break;
                case "versionNeeded":
                    position = checkElementOrder("versionNeeded", 38, position, false);
                    builder.versionNeeded(parseBoolean("versionNeeded", reader, -1));
                    break;
                case "content":
                    position = checkElementOrder("content", 39, position, false);
                    builder.content((CodeSystemContentMode) parseString(CodeSystemContentMode.builder(), "content", reader, -1));
                    break;
                case "supplements":
                    position = checkElementOrder("supplements", 40, position, false);
                    builder.supplements((Canonical) parseUri(Canonical.builder(), "supplements", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 41, position, false);
                    builder.count((UnsignedInt) parseInteger(UnsignedInt.builder(), "count", reader, -1));
                    break;
                case "filter":
                    position = checkElementOrder("filter", 42, position, true);
                    builder.filter(parseCodeSystemFilter("filter", reader, filterElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 43, position, true);
                    builder.property(parseCodeSystemProperty("property", reader, propertyElementIndex++));
                    break;
                case "concept":
                    position = checkElementOrder("concept", 44, position, true);
                    builder.concept(parseCodeSystemConcept("concept", reader, conceptElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Concept parseCodeSystemConcept(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Concept.Builder builder = CodeSystem.Concept.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, designationElementIndex = 0, propertyElementIndex = 0, conceptElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 3, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 4, position, false);
                    builder.definition(parseString("definition", reader, -1));
                    break;
                case "designation":
                    position = checkElementOrder("designation", 5, position, true);
                    builder.designation(parseCodeSystemConceptDesignation("designation", reader, designationElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 6, position, true);
                    builder.property(parseCodeSystemConceptProperty("property", reader, propertyElementIndex++));
                    break;
                case "concept":
                    position = checkElementOrder("concept", 7, position, true);
                    builder.concept(parseCodeSystemConcept("concept", reader, conceptElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Concept.Designation parseCodeSystemConceptDesignation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Concept.Designation.Builder builder = CodeSystem.Concept.Designation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additionalUseElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use(parseCoding("use", reader, -1));
                    break;
                case "additionalUse":
                    position = checkElementOrder("additionalUse", 4, position, true);
                    builder.additionalUse(parseCoding("additionalUse", reader, additionalUseElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Concept.Property parseCodeSystemConceptProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Concept.Property.Builder builder = CodeSystem.Concept.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Filter parseCodeSystemFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Filter.Builder builder = CodeSystem.Filter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, operatorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "operator":
                    position = checkElementOrder("operator", 4, position, true);
                    builder.operator((FilterOperator) parseString(FilterOperator.builder(), "operator", reader, operatorElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Property parseCodeSystemProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Property.Builder builder = CodeSystem.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type((PropertyType) parseString(PropertyType.builder(), "type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeableConcept parseCodeableConcept(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeableConcept.Builder builder = CodeableConcept.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, codingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "coding":
                    position = checkElementOrder("coding", 1, position, true);
                    builder.coding(parseCoding("coding", reader, codingElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 2, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeableReference parseCodeableReference(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeableReference.Builder builder = CodeableReference.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "concept":
                    position = checkElementOrder("concept", 1, position, false);
                    builder.concept(parseCodeableConcept("concept", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coding parseCoding(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coding.Builder builder = Coding.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 1, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 2, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "userSelected":
                    position = checkElementOrder("userSelected", 5, position, false);
                    builder.userSelected(parseBoolean("userSelected", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Communication parseCommunication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Communication.Builder builder = Communication.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, inResponseToElementIndex = 0, categoryElementIndex = 0, mediumElementIndex = 0, aboutElementIndex = 0, recipientElementIndex = 0, reasonElementIndex = 0, payloadElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 12, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "inResponseTo":
                    position = checkElementOrder("inResponseTo", 13, position, true);
                    builder.inResponseTo(parseReference("inResponseTo", reader, inResponseToElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((CommunicationStatus) parseString(CommunicationStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 15, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 16, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 17, position, false);
                    builder.priority((CommunicationPriority) parseString(CommunicationPriority.builder(), "priority", reader, -1));
                    break;
                case "medium":
                    position = checkElementOrder("medium", 18, position, true);
                    builder.medium(parseCodeableConcept("medium", reader, mediumElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 19, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 20, position, false);
                    builder.topic(parseCodeableConcept("topic", reader, -1));
                    break;
                case "about":
                    position = checkElementOrder("about", 21, position, true);
                    builder.about(parseReference("about", reader, aboutElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 22, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "sent":
                    position = checkElementOrder("sent", 23, position, false);
                    builder.sent(parseDateTime("sent", reader, -1));
                    break;
                case "received":
                    position = checkElementOrder("received", 24, position, false);
                    builder.received(parseDateTime("received", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 25, position, true);
                    builder.recipient(parseReference("recipient", reader, recipientElementIndex++));
                    break;
                case "sender":
                    position = checkElementOrder("sender", 26, position, false);
                    builder.sender(parseReference("sender", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 27, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "payload":
                    position = checkElementOrder("payload", 28, position, true);
                    builder.payload(parseCommunicationPayload("payload", reader, payloadElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 29, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Communication.Payload parseCommunicationPayload(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Communication.Payload.Builder builder = Communication.Payload.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                case "contentCodeableConcept":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseCodeableConcept("contentCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CommunicationRequest parseCommunicationRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CommunicationRequest.Builder builder = CommunicationRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, replacesElementIndex = 0, categoryElementIndex = 0, mediumElementIndex = 0, aboutElementIndex = 0, payloadElementIndex = 0, recipientElementIndex = 0, informationProviderElementIndex = 0, reasonElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 10, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 11, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((CommunicationRequestStatus) parseString(CommunicationRequestStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 13, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 14, position, false);
                    builder.intent((CommunicationRequestIntent) parseString(CommunicationRequestIntent.builder(), "intent", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 15, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 16, position, false);
                    builder.priority((CommunicationPriority) parseString(CommunicationPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 17, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "medium":
                    position = checkElementOrder("medium", 18, position, true);
                    builder.medium(parseCodeableConcept("medium", reader, mediumElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 19, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "about":
                    position = checkElementOrder("about", 20, position, true);
                    builder.about(parseReference("about", reader, aboutElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 21, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "payload":
                    position = checkElementOrder("payload", 22, position, true);
                    builder.payload(parseCommunicationRequestPayload("payload", reader, payloadElementIndex++));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 23, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 23, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 24, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 25, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 26, position, true);
                    builder.recipient(parseReference("recipient", reader, recipientElementIndex++));
                    break;
                case "informationProvider":
                    position = checkElementOrder("informationProvider", 27, position, true);
                    builder.informationProvider(parseReference("informationProvider", reader, informationProviderElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 28, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 29, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CommunicationRequest.Payload parseCommunicationRequestPayload(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CommunicationRequest.Payload.Builder builder = CommunicationRequest.Payload.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                case "contentCodeableConcept":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseCodeableConcept("contentCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CompartmentDefinition parseCompartmentDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CompartmentDefinition.Builder builder = CompartmentDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, resourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 10, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 10, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 20, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 21, position, false);
                    builder.code((CompartmentType) parseString(CompartmentType.builder(), "code", reader, -1));
                    break;
                case "search":
                    position = checkElementOrder("search", 22, position, false);
                    builder.search(parseBoolean("search", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 23, position, true);
                    builder.resource(parseCompartmentDefinitionResource("resource", reader, resourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CompartmentDefinition.Resource parseCompartmentDefinitionResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CompartmentDefinition.Resource.Builder builder = CompartmentDefinition.Resource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, paramElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "code", reader, -1));
                    break;
                case "param":
                    position = checkElementOrder("param", 3, position, true);
                    builder.param(parseString("param", reader, paramElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 4, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                case "startParam":
                    position = checkElementOrder("startParam", 5, position, false);
                    builder.startParam(parseUri("startParam", reader, -1));
                    break;
                case "endParam":
                    position = checkElementOrder("endParam", 6, position, false);
                    builder.endParam(parseUri("endParam", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Composition parseComposition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Composition.Builder builder = Composition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, subjectElementIndex = 0, useContextElementIndex = 0, authorElementIndex = 0, noteElementIndex = 0, attesterElementIndex = 0, relatesToElementIndex = 0, eventElementIndex = 0, sectionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((CompositionStatus) parseString(CompositionStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 12, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 13, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 15, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 17, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 18, position, true);
                    builder.author(parseReference("author", reader, authorElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 19, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 20, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 21, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "attester":
                    position = checkElementOrder("attester", 22, position, true);
                    builder.attester(parseCompositionAttester("attester", reader, attesterElementIndex++));
                    break;
                case "custodian":
                    position = checkElementOrder("custodian", 23, position, false);
                    builder.custodian(parseReference("custodian", reader, -1));
                    break;
                case "relatesTo":
                    position = checkElementOrder("relatesTo", 24, position, true);
                    builder.relatesTo(parseRelatedArtifact("relatesTo", reader, relatesToElementIndex++));
                    break;
                case "event":
                    position = checkElementOrder("event", 25, position, true);
                    builder.event(parseCompositionEvent("event", reader, eventElementIndex++));
                    break;
                case "section":
                    position = checkElementOrder("section", 26, position, true);
                    builder.section(parseCompositionSection("section", reader, sectionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Composition.Attester parseCompositionAttester(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Composition.Attester.Builder builder = Composition.Attester.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode(parseCodeableConcept("mode", reader, -1));
                    break;
                case "time":
                    position = checkElementOrder("time", 3, position, false);
                    builder.time(parseDateTime("time", reader, -1));
                    break;
                case "party":
                    position = checkElementOrder("party", 4, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Composition.Event parseCompositionEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Composition.Event.Builder builder = Composition.Event.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 2, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 3, position, true);
                    builder.detail(parseCodeableReference("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Composition.Section parseCompositionSection(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Composition.Section.Builder builder = Composition.Section.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, authorElementIndex = 0, entryElementIndex = 0, sectionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 4, position, true);
                    builder.author(parseReference("author", reader, authorElementIndex++));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 5, position, false);
                    builder.focus(parseReference("focus", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 6, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "orderedBy":
                    position = checkElementOrder("orderedBy", 7, position, false);
                    builder.orderedBy(parseCodeableConcept("orderedBy", reader, -1));
                    break;
                case "entry":
                    position = checkElementOrder("entry", 8, position, true);
                    builder.entry(parseReference("entry", reader, entryElementIndex++));
                    break;
                case "emptyReason":
                    position = checkElementOrder("emptyReason", 9, position, false);
                    builder.emptyReason(parseCodeableConcept("emptyReason", reader, -1));
                    break;
                case "section":
                    position = checkElementOrder("section", 10, position, true);
                    builder.section(parseCompositionSection("section", reader, sectionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap parseConceptMap(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Builder builder = ConceptMap.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, propertyElementIndex = 0, additionalAttributeElementIndex = 0, groupElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 25, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 26, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 27, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 28, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 29, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 30, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 31, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 32, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 33, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 34, position, true);
                    builder.property(parseConceptMapProperty("property", reader, propertyElementIndex++));
                    break;
                case "additionalAttribute":
                    position = checkElementOrder("additionalAttribute", 35, position, true);
                    builder.additionalAttribute(parseConceptMapAdditionalAttribute("additionalAttribute", reader, additionalAttributeElementIndex++));
                    break;
                case "sourceScopeUri":
                    position = checkElementOrder("sourceScope[x]", 36, position, false);
                    builder.sourceScope(parseUri("sourceScopeUri", reader, -1));
                    break;
                case "sourceScopeCanonical":
                    position = checkElementOrder("sourceScope[x]", 36, position, false);
                    builder.sourceScope((Canonical) parseUri(Canonical.builder(), "sourceScopeCanonical", reader, -1));
                    break;
                case "targetScopeUri":
                    position = checkElementOrder("targetScope[x]", 37, position, false);
                    builder.targetScope(parseUri("targetScopeUri", reader, -1));
                    break;
                case "targetScopeCanonical":
                    position = checkElementOrder("targetScope[x]", 37, position, false);
                    builder.targetScope((Canonical) parseUri(Canonical.builder(), "targetScopeCanonical", reader, -1));
                    break;
                case "group":
                    position = checkElementOrder("group", 38, position, true);
                    builder.group(parseConceptMapGroup("group", reader, groupElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.AdditionalAttribute parseConceptMapAdditionalAttribute(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.AdditionalAttribute.Builder builder = ConceptMap.AdditionalAttribute.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type((ConceptMapmapAttributeType) parseString(ConceptMapmapAttributeType.builder(), "type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group parseConceptMapGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Builder builder = ConceptMap.Group.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, elementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 2, position, false);
                    builder.source((Canonical) parseUri(Canonical.builder(), "source", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 3, position, false);
                    builder.target((Canonical) parseUri(Canonical.builder(), "target", reader, -1));
                    break;
                case "element":
                    position = checkElementOrder("element", 4, position, true);
                    builder.element(parseConceptMapGroupElement("element", reader, elementElementIndex++));
                    break;
                case "unmapped":
                    position = checkElementOrder("unmapped", 5, position, false);
                    builder.unmapped(parseConceptMapGroupUnmapped("unmapped", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group.Element parseConceptMapGroupElement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Element.Builder builder = ConceptMap.Group.Element.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 3, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 4, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                case "noMap":
                    position = checkElementOrder("noMap", 5, position, false);
                    builder.noMap(parseBoolean("noMap", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 6, position, true);
                    builder.target(parseConceptMapGroupElementTarget("target", reader, targetElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group.Element.Target parseConceptMapGroupElementTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Element.Target.Builder builder = ConceptMap.Group.Element.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, propertyElementIndex = 0, dependsOnElementIndex = 0, productElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 3, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 4, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 5, position, false);
                    builder.relationship((ConceptMapRelationship) parseString(ConceptMapRelationship.builder(), "relationship", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 6, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                case "property":
                    position = checkElementOrder("property", 7, position, true);
                    builder.property(parseConceptMapGroupElementTargetProperty("property", reader, propertyElementIndex++));
                    break;
                case "dependsOn":
                    position = checkElementOrder("dependsOn", 8, position, true);
                    builder.dependsOn(parseConceptMapGroupElementTargetDependsOn("dependsOn", reader, dependsOnElementIndex++));
                    break;
                case "product":
                    position = checkElementOrder("product", 9, position, true);
                    builder.product(parseConceptMapGroupElementTargetDependsOn("product", reader, productElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group.Element.Target.DependsOn parseConceptMapGroupElementTargetDependsOn(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Element.Target.DependsOn.Builder builder = ConceptMap.Group.Element.Target.DependsOn.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "attribute":
                    position = checkElementOrder("attribute", 2, position, false);
                    builder.attribute((Code) parseString(Code.builder(), "attribute", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 4, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group.Element.Target.Property parseConceptMapGroupElementTargetProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Element.Target.Property.Builder builder = ConceptMap.Group.Element.Target.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group.Unmapped parseConceptMapGroupUnmapped(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Unmapped.Builder builder = ConceptMap.Group.Unmapped.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((ConceptMapGroupUnmappedMode) parseString(ConceptMapGroupUnmappedMode.builder(), "mode", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 5, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 6, position, false);
                    builder.relationship((UnmappedConceptMapRelationship) parseString(UnmappedConceptMapRelationship.builder(), "relationship", reader, -1));
                    break;
                case "otherMap":
                    position = checkElementOrder("otherMap", 7, position, false);
                    builder.otherMap((Canonical) parseUri(Canonical.builder(), "otherMap", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Property parseConceptMapProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Property.Builder builder = ConceptMap.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type((PropertyType) parseString(PropertyType.builder(), "type", reader, -1));
                    break;
                case "system":
                    position = checkElementOrder("system", 6, position, false);
                    builder.system((Canonical) parseUri(Canonical.builder(), "system", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Condition parseCondition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Condition.Builder builder = Condition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, bodySiteElementIndex = 0, participantElementIndex = 0, stageElementIndex = 0, evidenceElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "clinicalStatus":
                    position = checkElementOrder("clinicalStatus", 9, position, false);
                    builder.clinicalStatus(parseCodeableConcept("clinicalStatus", reader, -1));
                    break;
                case "verificationStatus":
                    position = checkElementOrder("verificationStatus", 10, position, false);
                    builder.verificationStatus(parseCodeableConcept("verificationStatus", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 12, position, false);
                    builder.severity(parseCodeableConcept("severity", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 13, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 14, position, true);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 15, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 16, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "onsetDateTime":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseDateTime("onsetDateTime", reader, -1));
                    break;
                case "onsetAge":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset((Age) parseQuantity(Age.builder(), "onsetAge", reader, -1));
                    break;
                case "onsetPeriod":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parsePeriod("onsetPeriod", reader, -1));
                    break;
                case "onsetRange":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseRange("onsetRange", reader, -1));
                    break;
                case "onsetString":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseString("onsetString", reader, -1));
                    break;
                case "abatementDateTime":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement(parseDateTime("abatementDateTime", reader, -1));
                    break;
                case "abatementAge":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement((Age) parseQuantity(Age.builder(), "abatementAge", reader, -1));
                    break;
                case "abatementPeriod":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement(parsePeriod("abatementPeriod", reader, -1));
                    break;
                case "abatementRange":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement(parseRange("abatementRange", reader, -1));
                    break;
                case "abatementString":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement(parseString("abatementString", reader, -1));
                    break;
                case "recordedDate":
                    position = checkElementOrder("recordedDate", 19, position, false);
                    builder.recordedDate(parseDateTime("recordedDate", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 20, position, true);
                    builder.participant(parseConditionParticipant("participant", reader, participantElementIndex++));
                    break;
                case "stage":
                    position = checkElementOrder("stage", 21, position, true);
                    builder.stage(parseConditionStage("stage", reader, stageElementIndex++));
                    break;
                case "evidence":
                    position = checkElementOrder("evidence", 22, position, true);
                    builder.evidence(parseCodeableReference("evidence", reader, evidenceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 23, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Condition.Participant parseConditionParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Condition.Participant.Builder builder = Condition.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Condition.Stage parseConditionStage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Condition.Stage.Builder builder = Condition.Stage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, assessmentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "summary":
                    position = checkElementOrder("summary", 2, position, false);
                    builder.summary(parseCodeableConcept("summary", reader, -1));
                    break;
                case "assessment":
                    position = checkElementOrder("assessment", 3, position, true);
                    builder.assessment(parseReference("assessment", reader, assessmentElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConditionDefinition parseConditionDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConditionDefinition.Builder builder = ConditionDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, definitionElementIndex = 0, observationElementIndex = 0, medicationElementIndex = 0, preconditionElementIndex = 0, teamElementIndex = 0, questionnaireElementIndex = 0, planElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 14, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 23, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 24, position, false);
                    builder.severity(parseCodeableConcept("severity", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 25, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "stage":
                    position = checkElementOrder("stage", 26, position, false);
                    builder.stage(parseCodeableConcept("stage", reader, -1));
                    break;
                case "hasSeverity":
                    position = checkElementOrder("hasSeverity", 27, position, false);
                    builder.hasSeverity(parseBoolean("hasSeverity", reader, -1));
                    break;
                case "hasBodySite":
                    position = checkElementOrder("hasBodySite", 28, position, false);
                    builder.hasBodySite(parseBoolean("hasBodySite", reader, -1));
                    break;
                case "hasStage":
                    position = checkElementOrder("hasStage", 29, position, false);
                    builder.hasStage(parseBoolean("hasStage", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 30, position, true);
                    builder.definition(parseUri("definition", reader, definitionElementIndex++));
                    break;
                case "observation":
                    position = checkElementOrder("observation", 31, position, true);
                    builder.observation(parseConditionDefinitionObservation("observation", reader, observationElementIndex++));
                    break;
                case "medication":
                    position = checkElementOrder("medication", 32, position, true);
                    builder.medication(parseConditionDefinitionMedication("medication", reader, medicationElementIndex++));
                    break;
                case "precondition":
                    position = checkElementOrder("precondition", 33, position, true);
                    builder.precondition(parseConditionDefinitionPrecondition("precondition", reader, preconditionElementIndex++));
                    break;
                case "team":
                    position = checkElementOrder("team", 34, position, true);
                    builder.team(parseReference("team", reader, teamElementIndex++));
                    break;
                case "questionnaire":
                    position = checkElementOrder("questionnaire", 35, position, true);
                    builder.questionnaire(parseConditionDefinitionQuestionnaire("questionnaire", reader, questionnaireElementIndex++));
                    break;
                case "plan":
                    position = checkElementOrder("plan", 36, position, true);
                    builder.plan(parseConditionDefinitionPlan("plan", reader, planElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConditionDefinition.Medication parseConditionDefinitionMedication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConditionDefinition.Medication.Builder builder = ConditionDefinition.Medication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConditionDefinition.Observation parseConditionDefinitionObservation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConditionDefinition.Observation.Builder builder = ConditionDefinition.Observation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConditionDefinition.Plan parseConditionDefinitionPlan(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConditionDefinition.Plan.Builder builder = ConditionDefinition.Plan.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConditionDefinition.Precondition parseConditionDefinitionPrecondition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConditionDefinition.Precondition.Builder builder = ConditionDefinition.Precondition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ConditionPreconditionType) parseString(ConditionPreconditionType.builder(), "type", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConditionDefinition.Questionnaire parseConditionDefinitionQuestionnaire(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConditionDefinition.Questionnaire.Builder builder = ConditionDefinition.Questionnaire.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 2, position, false);
                    builder.purpose((ConditionQuestionnairePurpose) parseString(ConditionQuestionnairePurpose.builder(), "purpose", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent parseConsent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Builder builder = Consent.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, grantorElementIndex = 0, granteeElementIndex = 0, managerElementIndex = 0, controllerElementIndex = 0, sourceAttachmentElementIndex = 0, sourceReferenceElementIndex = 0, regulatoryBasisElementIndex = 0, policyTextElementIndex = 0, verificationElementIndex = 0, provisionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ConsentState) parseString(ConsentState.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 11, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 12, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 13, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "grantor":
                    position = checkElementOrder("grantor", 14, position, true);
                    builder.grantor(parseReference("grantor", reader, grantorElementIndex++));
                    break;
                case "grantee":
                    position = checkElementOrder("grantee", 15, position, true);
                    builder.grantee(parseReference("grantee", reader, granteeElementIndex++));
                    break;
                case "manager":
                    position = checkElementOrder("manager", 16, position, true);
                    builder.manager(parseReference("manager", reader, managerElementIndex++));
                    break;
                case "controller":
                    position = checkElementOrder("controller", 17, position, true);
                    builder.controller(parseReference("controller", reader, controllerElementIndex++));
                    break;
                case "sourceAttachment":
                    position = checkElementOrder("sourceAttachment", 18, position, true);
                    builder.sourceAttachment(parseAttachment("sourceAttachment", reader, sourceAttachmentElementIndex++));
                    break;
                case "sourceReference":
                    position = checkElementOrder("sourceReference", 19, position, true);
                    builder.sourceReference(parseReference("sourceReference", reader, sourceReferenceElementIndex++));
                    break;
                case "regulatoryBasis":
                    position = checkElementOrder("regulatoryBasis", 20, position, true);
                    builder.regulatoryBasis(parseCodeableConcept("regulatoryBasis", reader, regulatoryBasisElementIndex++));
                    break;
                case "policyBasis":
                    position = checkElementOrder("policyBasis", 21, position, false);
                    builder.policyBasis(parseConsentPolicyBasis("policyBasis", reader, -1));
                    break;
                case "policyText":
                    position = checkElementOrder("policyText", 22, position, true);
                    builder.policyText(parseReference("policyText", reader, policyTextElementIndex++));
                    break;
                case "verification":
                    position = checkElementOrder("verification", 23, position, true);
                    builder.verification(parseConsentVerification("verification", reader, verificationElementIndex++));
                    break;
                case "decision":
                    position = checkElementOrder("decision", 24, position, false);
                    builder.decision((ConsentProvisionType) parseString(ConsentProvisionType.builder(), "decision", reader, -1));
                    break;
                case "provision":
                    position = checkElementOrder("provision", 25, position, true);
                    builder.provision(parseConsentProvision("provision", reader, provisionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.PolicyBasis parseConsentPolicyBasis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.PolicyBasis.Builder builder = Consent.PolicyBasis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.Provision parseConsentProvision(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Provision.Builder builder = Consent.Provision.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actorElementIndex = 0, actionElementIndex = 0, securityLabelElementIndex = 0, purposeElementIndex = 0, documentTypeElementIndex = 0, resourceTypeElementIndex = 0, codeElementIndex = 0, dataElementIndex = 0, provisionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 2, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, true);
                    builder.actor(parseConsentProvisionActor("actor", reader, actorElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 4, position, true);
                    builder.action(parseCodeableConcept("action", reader, actionElementIndex++));
                    break;
                case "securityLabel":
                    position = checkElementOrder("securityLabel", 5, position, true);
                    builder.securityLabel(parseCoding("securityLabel", reader, securityLabelElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 6, position, true);
                    builder.purpose(parseCoding("purpose", reader, purposeElementIndex++));
                    break;
                case "documentType":
                    position = checkElementOrder("documentType", 7, position, true);
                    builder.documentType(parseCoding("documentType", reader, documentTypeElementIndex++));
                    break;
                case "resourceType":
                    position = checkElementOrder("resourceType", 8, position, true);
                    builder.resourceType(parseCoding("resourceType", reader, resourceTypeElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "dataPeriod":
                    position = checkElementOrder("dataPeriod", 10, position, false);
                    builder.dataPeriod(parsePeriod("dataPeriod", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 11, position, true);
                    builder.data(parseConsentProvisionData("data", reader, dataElementIndex++));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 12, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                case "provision":
                    position = checkElementOrder("provision", 13, position, true);
                    builder.provision(parseConsentProvision("provision", reader, provisionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.Provision.Actor parseConsentProvisionActor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Provision.Actor.Builder builder = Consent.Provision.Actor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.Provision.Data parseConsentProvisionData(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Provision.Data.Builder builder = Consent.Provision.Data.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "meaning":
                    position = checkElementOrder("meaning", 2, position, false);
                    builder.meaning((ConsentDataMeaning) parseString(ConsentDataMeaning.builder(), "meaning", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.Verification parseConsentVerification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Verification.Builder builder = Consent.Verification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, verificationDateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "verified":
                    position = checkElementOrder("verified", 2, position, false);
                    builder.verified(parseBoolean("verified", reader, -1));
                    break;
                case "verificationType":
                    position = checkElementOrder("verificationType", 3, position, false);
                    builder.verificationType(parseCodeableConcept("verificationType", reader, -1));
                    break;
                case "verifiedBy":
                    position = checkElementOrder("verifiedBy", 4, position, false);
                    builder.verifiedBy(parseReference("verifiedBy", reader, -1));
                    break;
                case "verifiedWith":
                    position = checkElementOrder("verifiedWith", 5, position, false);
                    builder.verifiedWith(parseReference("verifiedWith", reader, -1));
                    break;
                case "verificationDate":
                    position = checkElementOrder("verificationDate", 6, position, true);
                    builder.verificationDate(parseDateTime("verificationDate", reader, verificationDateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ContactDetail parseContactDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ContactDetail.Builder builder = ContactDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, telecomElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 1, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 2, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ContactPoint parseContactPoint(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ContactPoint.Builder builder = ContactPoint.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 1, position, false);
                    builder.system((ContactPointSystem) parseString(ContactPointSystem.builder(), "system", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 2, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use((ContactPointUse) parseString(ContactPointUse.builder(), "use", reader, -1));
                    break;
                case "rank":
                    position = checkElementOrder("rank", 4, position, false);
                    builder.rank((PositiveInt) parseInteger(PositiveInt.builder(), "rank", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract parseContract(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Builder builder = Contract.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, subjectElementIndex = 0, authorityElementIndex = 0, domainElementIndex = 0, siteElementIndex = 0, aliasElementIndex = 0, subTypeElementIndex = 0, termElementIndex = 0, supportingInfoElementIndex = 0, relevantHistoryElementIndex = 0, signerElementIndex = 0, friendlyElementIndex = 0, legalElementIndex = 0, ruleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 9, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((ContractStatus) parseString(ContractStatus.builder(), "status", reader, -1));
                    break;
                case "legalState":
                    position = checkElementOrder("legalState", 12, position, false);
                    builder.legalState(parseCodeableConcept("legalState", reader, -1));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 13, position, false);
                    builder.instantiatesCanonical(parseReference("instantiatesCanonical", reader, -1));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 14, position, false);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, -1));
                    break;
                case "contentDerivative":
                    position = checkElementOrder("contentDerivative", 15, position, false);
                    builder.contentDerivative(parseCodeableConcept("contentDerivative", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 16, position, false);
                    builder.issued(parseDateTime("issued", reader, -1));
                    break;
                case "applies":
                    position = checkElementOrder("applies", 17, position, false);
                    builder.applies(parsePeriod("applies", reader, -1));
                    break;
                case "expirationType":
                    position = checkElementOrder("expirationType", 18, position, false);
                    builder.expirationType(parseCodeableConcept("expirationType", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 19, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 20, position, true);
                    builder.authority(parseReference("authority", reader, authorityElementIndex++));
                    break;
                case "domain":
                    position = checkElementOrder("domain", 21, position, true);
                    builder.domain(parseReference("domain", reader, domainElementIndex++));
                    break;
                case "site":
                    position = checkElementOrder("site", 22, position, true);
                    builder.site(parseReference("site", reader, siteElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 23, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 24, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 25, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 26, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 27, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 28, position, false);
                    builder.scope(parseCodeableConcept("scope", reader, -1));
                    break;
                case "topicCodeableConcept":
                    position = checkElementOrder("topic[x]", 29, position, false);
                    builder.topic(parseCodeableConcept("topicCodeableConcept", reader, -1));
                    break;
                case "topicReference":
                    position = checkElementOrder("topic[x]", 29, position, false);
                    builder.topic(parseReference("topicReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 30, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 31, position, true);
                    builder.subType(parseCodeableConcept("subType", reader, subTypeElementIndex++));
                    break;
                case "contentDefinition":
                    position = checkElementOrder("contentDefinition", 32, position, false);
                    builder.contentDefinition(parseContractContentDefinition("contentDefinition", reader, -1));
                    break;
                case "term":
                    position = checkElementOrder("term", 33, position, true);
                    builder.term(parseContractTerm("term", reader, termElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 34, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "relevantHistory":
                    position = checkElementOrder("relevantHistory", 35, position, true);
                    builder.relevantHistory(parseReference("relevantHistory", reader, relevantHistoryElementIndex++));
                    break;
                case "signer":
                    position = checkElementOrder("signer", 36, position, true);
                    builder.signer(parseContractSigner("signer", reader, signerElementIndex++));
                    break;
                case "friendly":
                    position = checkElementOrder("friendly", 37, position, true);
                    builder.friendly(parseContractFriendly("friendly", reader, friendlyElementIndex++));
                    break;
                case "legal":
                    position = checkElementOrder("legal", 38, position, true);
                    builder.legal(parseContractLegal("legal", reader, legalElementIndex++));
                    break;
                case "rule":
                    position = checkElementOrder("rule", 39, position, true);
                    builder.rule(parseContractRule("rule", reader, ruleElementIndex++));
                    break;
                case "legallyBindingAttachment":
                    position = checkElementOrder("legallyBinding[x]", 40, position, false);
                    builder.legallyBinding(parseAttachment("legallyBindingAttachment", reader, -1));
                    break;
                case "legallyBindingReference":
                    position = checkElementOrder("legallyBinding[x]", 40, position, false);
                    builder.legallyBinding(parseReference("legallyBindingReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.ContentDefinition parseContractContentDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.ContentDefinition.Builder builder = Contract.ContentDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 3, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 4, position, false);
                    builder.publisher(parseReference("publisher", reader, -1));
                    break;
                case "publicationDate":
                    position = checkElementOrder("publicationDate", 5, position, false);
                    builder.publicationDate(parseDateTime("publicationDate", reader, -1));
                    break;
                case "publicationStatus":
                    position = checkElementOrder("publicationStatus", 6, position, false);
                    builder.publicationStatus((ContractPublicationStatus) parseString(ContractPublicationStatus.builder(), "publicationStatus", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 7, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Friendly parseContractFriendly(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Friendly.Builder builder = Contract.Friendly.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Legal parseContractLegal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Legal.Builder builder = Contract.Legal.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Rule parseContractRule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Rule.Builder builder = Contract.Rule.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Signer parseContractSigner(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Signer.Builder builder = Contract.Signer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, signatureElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCoding("type", reader, -1));
                    break;
                case "party":
                    position = checkElementOrder("party", 3, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                case "signature":
                    position = checkElementOrder("signature", 4, position, true);
                    builder.signature(parseSignature("signature", reader, signatureElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term parseContractTerm(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Builder builder = Contract.Term.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, securityLabelElementIndex = 0, assetElementIndex = 0, actionElementIndex = 0, groupElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 3, position, false);
                    builder.issued(parseDateTime("issued", reader, -1));
                    break;
                case "applies":
                    position = checkElementOrder("applies", 4, position, false);
                    builder.applies(parsePeriod("applies", reader, -1));
                    break;
                case "topicCodeableConcept":
                    position = checkElementOrder("topic[x]", 5, position, false);
                    builder.topic(parseCodeableConcept("topicCodeableConcept", reader, -1));
                    break;
                case "topicReference":
                    position = checkElementOrder("topic[x]", 5, position, false);
                    builder.topic(parseReference("topicReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 6, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 7, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 8, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "securityLabel":
                    position = checkElementOrder("securityLabel", 9, position, true);
                    builder.securityLabel(parseContractTermSecurityLabel("securityLabel", reader, securityLabelElementIndex++));
                    break;
                case "offer":
                    position = checkElementOrder("offer", 10, position, false);
                    builder.offer(parseContractTermOffer("offer", reader, -1));
                    break;
                case "asset":
                    position = checkElementOrder("asset", 11, position, true);
                    builder.asset(parseContractTermAsset("asset", reader, assetElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 12, position, true);
                    builder.action(parseContractTermAction("action", reader, actionElementIndex++));
                    break;
                case "group":
                    position = checkElementOrder("group", 13, position, true);
                    builder.group(parseContractTerm("group", reader, groupElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Action parseContractTermAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Action.Builder builder = Contract.Term.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, subjectElementIndex = 0, linkIdElementIndex = 0, contextLinkIdElementIndex = 0, requesterElementIndex = 0, requesterLinkIdElementIndex = 0, performerTypeElementIndex = 0, performerLinkIdElementIndex = 0, reasonElementIndex = 0, reasonLinkIdElementIndex = 0, noteElementIndex = 0, securityLabelNumberElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 2, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 4, position, true);
                    builder.subject(parseContractTermActionSubject("subject", reader, subjectElementIndex++));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 5, position, false);
                    builder.intent(parseCodeableConcept("intent", reader, -1));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 6, position, true);
                    builder.linkId(parseString("linkId", reader, linkIdElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 7, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 8, position, false);
                    builder.context(parseReference("context", reader, -1));
                    break;
                case "contextLinkId":
                    position = checkElementOrder("contextLinkId", 9, position, true);
                    builder.contextLinkId(parseString("contextLinkId", reader, contextLinkIdElementIndex++));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 10, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 10, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 10, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 11, position, true);
                    builder.requester(parseReference("requester", reader, requesterElementIndex++));
                    break;
                case "requesterLinkId":
                    position = checkElementOrder("requesterLinkId", 12, position, true);
                    builder.requesterLinkId(parseString("requesterLinkId", reader, requesterLinkIdElementIndex++));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 13, position, true);
                    builder.performerType(parseCodeableConcept("performerType", reader, performerTypeElementIndex++));
                    break;
                case "performerRole":
                    position = checkElementOrder("performerRole", 14, position, false);
                    builder.performerRole(parseCodeableConcept("performerRole", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 15, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "performerLinkId":
                    position = checkElementOrder("performerLinkId", 16, position, true);
                    builder.performerLinkId(parseString("performerLinkId", reader, performerLinkIdElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 17, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "reasonLinkId":
                    position = checkElementOrder("reasonLinkId", 18, position, true);
                    builder.reasonLinkId(parseString("reasonLinkId", reader, reasonLinkIdElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 19, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "securityLabelNumber":
                    position = checkElementOrder("securityLabelNumber", 20, position, true);
                    builder.securityLabelNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "securityLabelNumber", reader, securityLabelNumberElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Action.Subject parseContractTermActionSubject(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Action.Subject.Builder builder = Contract.Term.Action.Subject.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, referenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, true);
                    builder.reference(parseReference("reference", reader, referenceElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Asset parseContractTermAsset(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Asset.Builder builder = Contract.Term.Asset.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, typeReferenceElementIndex = 0, subtypeElementIndex = 0, contextElementIndex = 0, periodTypeElementIndex = 0, periodElementIndex = 0, usePeriodElementIndex = 0, linkIdElementIndex = 0, answerElementIndex = 0, securityLabelNumberElementIndex = 0, valuedItemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 2, position, false);
                    builder.scope(parseCodeableConcept("scope", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "typeReference":
                    position = checkElementOrder("typeReference", 4, position, true);
                    builder.typeReference(parseReference("typeReference", reader, typeReferenceElementIndex++));
                    break;
                case "subtype":
                    position = checkElementOrder("subtype", 5, position, true);
                    builder.subtype(parseCodeableConcept("subtype", reader, subtypeElementIndex++));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 6, position, false);
                    builder.relationship(parseCoding("relationship", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 7, position, true);
                    builder.context(parseContractTermAssetContext("context", reader, contextElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 8, position, false);
                    builder.condition(parseString("condition", reader, -1));
                    break;
                case "periodType":
                    position = checkElementOrder("periodType", 9, position, true);
                    builder.periodType(parseCodeableConcept("periodType", reader, periodTypeElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, true);
                    builder.period(parsePeriod("period", reader, periodElementIndex++));
                    break;
                case "usePeriod":
                    position = checkElementOrder("usePeriod", 11, position, true);
                    builder.usePeriod(parsePeriod("usePeriod", reader, usePeriodElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 12, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 13, position, true);
                    builder.linkId(parseString("linkId", reader, linkIdElementIndex++));
                    break;
                case "answer":
                    position = checkElementOrder("answer", 14, position, true);
                    builder.answer(parseContractTermOfferAnswer("answer", reader, answerElementIndex++));
                    break;
                case "securityLabelNumber":
                    position = checkElementOrder("securityLabelNumber", 15, position, true);
                    builder.securityLabelNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "securityLabelNumber", reader, securityLabelNumberElementIndex++));
                    break;
                case "valuedItem":
                    position = checkElementOrder("valuedItem", 16, position, true);
                    builder.valuedItem(parseContractTermAssetValuedItem("valuedItem", reader, valuedItemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Asset.Context parseContractTermAssetContext(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Asset.Context.Builder builder = Contract.Term.Asset.Context.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Asset.ValuedItem parseContractTermAssetValuedItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Asset.ValuedItem.Builder builder = Contract.Term.Asset.ValuedItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, linkIdElementIndex = 0, securityLabelNumberElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "entityCodeableConcept":
                    position = checkElementOrder("entity[x]", 2, position, false);
                    builder.entity(parseCodeableConcept("entityCodeableConcept", reader, -1));
                    break;
                case "entityReference":
                    position = checkElementOrder("entity[x]", 2, position, false);
                    builder.entity(parseReference("entityReference", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "effectiveTime":
                    position = checkElementOrder("effectiveTime", 4, position, false);
                    builder.effectiveTime(parseDateTime("effectiveTime", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 6, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 7, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "points":
                    position = checkElementOrder("points", 8, position, false);
                    builder.points(parseDecimal("points", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 9, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "payment":
                    position = checkElementOrder("payment", 10, position, false);
                    builder.payment(parseString("payment", reader, -1));
                    break;
                case "paymentDate":
                    position = checkElementOrder("paymentDate", 11, position, false);
                    builder.paymentDate(parseDateTime("paymentDate", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 12, position, false);
                    builder.responsible(parseReference("responsible", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 13, position, false);
                    builder.recipient(parseReference("recipient", reader, -1));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 14, position, true);
                    builder.linkId(parseString("linkId", reader, linkIdElementIndex++));
                    break;
                case "securityLabelNumber":
                    position = checkElementOrder("securityLabelNumber", 15, position, true);
                    builder.securityLabelNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "securityLabelNumber", reader, securityLabelNumberElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Offer parseContractTermOffer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Offer.Builder builder = Contract.Term.Offer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, partyElementIndex = 0, decisionModeElementIndex = 0, answerElementIndex = 0, linkIdElementIndex = 0, securityLabelNumberElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "party":
                    position = checkElementOrder("party", 3, position, true);
                    builder.party(parseContractTermOfferParty("party", reader, partyElementIndex++));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 4, position, false);
                    builder.topic(parseReference("topic", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "decision":
                    position = checkElementOrder("decision", 6, position, false);
                    builder.decision(parseCodeableConcept("decision", reader, -1));
                    break;
                case "decisionMode":
                    position = checkElementOrder("decisionMode", 7, position, true);
                    builder.decisionMode(parseCodeableConcept("decisionMode", reader, decisionModeElementIndex++));
                    break;
                case "answer":
                    position = checkElementOrder("answer", 8, position, true);
                    builder.answer(parseContractTermOfferAnswer("answer", reader, answerElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 9, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 10, position, true);
                    builder.linkId(parseString("linkId", reader, linkIdElementIndex++));
                    break;
                case "securityLabelNumber":
                    position = checkElementOrder("securityLabelNumber", 11, position, true);
                    builder.securityLabelNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "securityLabelNumber", reader, securityLabelNumberElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Offer.Answer parseContractTermOfferAnswer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Offer.Answer.Builder builder = Contract.Term.Offer.Answer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Offer.Party parseContractTermOfferParty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Offer.Party.Builder builder = Contract.Term.Offer.Party.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, referenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, true);
                    builder.reference(parseReference("reference", reader, referenceElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.SecurityLabel parseContractTermSecurityLabel(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.SecurityLabel.Builder builder = Contract.Term.SecurityLabel.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, numberElementIndex = 0, categoryElementIndex = 0, controlElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "number":
                    position = checkElementOrder("number", 2, position, true);
                    builder.number((UnsignedInt) parseInteger(UnsignedInt.builder(), "number", reader, numberElementIndex++));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 3, position, false);
                    builder.classification(parseCoding("classification", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 4, position, true);
                    builder.category(parseCoding("category", reader, categoryElementIndex++));
                    break;
                case "control":
                    position = checkElementOrder("control", 5, position, true);
                    builder.control(parseCoding("control", reader, controlElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contributor parseContributor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contributor.Builder builder = Contributor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, contactElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, false);
                    builder.type((ContributorType) parseString(ContributorType.builder(), "type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 3, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coverage parseCoverage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coverage.Builder builder = Coverage.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, paymentByElementIndex = 0, subscriberIdElementIndex = 0, classElementIndex = 0, costToBeneficiaryElementIndex = 0, contractElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((CoverageStatus) parseString(CoverageStatus.builder(), "status", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 10, position, false);
                    builder.kind((CoverageKind) parseString(CoverageKind.builder(), "kind", reader, -1));
                    break;
                case "paymentBy":
                    position = checkElementOrder("paymentBy", 11, position, true);
                    builder.paymentBy(parseCoveragePaymentBy("paymentBy", reader, paymentByElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 12, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "policyHolder":
                    position = checkElementOrder("policyHolder", 13, position, false);
                    builder.policyHolder(parseReference("policyHolder", reader, -1));
                    break;
                case "subscriber":
                    position = checkElementOrder("subscriber", 14, position, false);
                    builder.subscriber(parseReference("subscriber", reader, -1));
                    break;
                case "subscriberId":
                    position = checkElementOrder("subscriberId", 15, position, true);
                    builder.subscriberId(parseIdentifier("subscriberId", reader, subscriberIdElementIndex++));
                    break;
                case "beneficiary":
                    position = checkElementOrder("beneficiary", 16, position, false);
                    builder.beneficiary(parseReference("beneficiary", reader, -1));
                    break;
                case "dependent":
                    position = checkElementOrder("dependent", 17, position, false);
                    builder.dependent(parseString("dependent", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 18, position, false);
                    builder.relationship(parseCodeableConcept("relationship", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 19, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 20, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "class":
                    position = checkElementOrder("class", 21, position, true);
                    builder.clazz(parseCoverageClass("class", reader, classElementIndex++));
                    break;
                case "order":
                    position = checkElementOrder("order", 22, position, false);
                    builder.order((PositiveInt) parseInteger(PositiveInt.builder(), "order", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 23, position, false);
                    builder.network(parseString("network", reader, -1));
                    break;
                case "costToBeneficiary":
                    position = checkElementOrder("costToBeneficiary", 24, position, true);
                    builder.costToBeneficiary(parseCoverageCostToBeneficiary("costToBeneficiary", reader, costToBeneficiaryElementIndex++));
                    break;
                case "subrogation":
                    position = checkElementOrder("subrogation", 25, position, false);
                    builder.subrogation(parseBoolean("subrogation", reader, -1));
                    break;
                case "contract":
                    position = checkElementOrder("contract", 26, position, true);
                    builder.contract(parseReference("contract", reader, contractElementIndex++));
                    break;
                case "insurancePlan":
                    position = checkElementOrder("insurancePlan", 27, position, false);
                    builder.insurancePlan(parseReference("insurancePlan", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coverage.Class parseCoverageClass(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coverage.Class.Builder builder = Coverage.Class.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseIdentifier("value", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coverage.CostToBeneficiary parseCoverageCostToBeneficiary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coverage.CostToBeneficiary.Builder builder = Coverage.CostToBeneficiary.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, exceptionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 3, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 4, position, false);
                    builder.network(parseCodeableConcept("network", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 5, position, false);
                    builder.unit(parseCodeableConcept("unit", reader, -1));
                    break;
                case "term":
                    position = checkElementOrder("term", 6, position, false);
                    builder.term(parseCodeableConcept("term", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 7, position, false);
                    builder.value((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "valueQuantity", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 7, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "exception":
                    position = checkElementOrder("exception", 8, position, true);
                    builder.exception(parseCoverageCostToBeneficiaryException("exception", reader, exceptionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coverage.CostToBeneficiary.Exception parseCoverageCostToBeneficiaryException(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coverage.CostToBeneficiary.Exception.Builder builder = Coverage.CostToBeneficiary.Exception.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coverage.PaymentBy parseCoveragePaymentBy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coverage.PaymentBy.Builder builder = Coverage.PaymentBy.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "party":
                    position = checkElementOrder("party", 2, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                case "responsibility":
                    position = checkElementOrder("responsibility", 3, position, false);
                    builder.responsibility(parseString("responsibility", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest parseCoverageEligibilityRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.Builder builder = CoverageEligibilityRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, purposeElementIndex = 0, eventElementIndex = 0, supportingInfoElementIndex = 0, insuranceElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EligibilityRequestStatus) parseString(EligibilityRequestStatus.builder(), "status", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 10, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 11, position, true);
                    builder.purpose((EligibilityRequestPurpose) parseString(EligibilityRequestPurpose.builder(), "purpose", reader, purposeElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 12, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "event":
                    position = checkElementOrder("event", 13, position, true);
                    builder.event(parseCoverageEligibilityRequestEvent("event", reader, eventElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 14, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 14, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 15, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 16, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 17, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 18, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "facility":
                    position = checkElementOrder("facility", 19, position, false);
                    builder.facility(parseReference("facility", reader, -1));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 20, position, true);
                    builder.supportingInfo(parseCoverageEligibilityRequestSupportingInfo("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 21, position, true);
                    builder.insurance(parseCoverageEligibilityRequestInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 22, position, true);
                    builder.item(parseCoverageEligibilityRequestItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest.Event parseCoverageEligibilityRequestEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.Event.Builder builder = CoverageEligibilityRequest.Event.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "whenDateTime":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parseDateTime("whenDateTime", reader, -1));
                    break;
                case "whenPeriod":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parsePeriod("whenPeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest.Insurance parseCoverageEligibilityRequestInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.Insurance.Builder builder = CoverageEligibilityRequest.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "focal":
                    position = checkElementOrder("focal", 2, position, false);
                    builder.focal(parseBoolean("focal", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 3, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "businessArrangement":
                    position = checkElementOrder("businessArrangement", 4, position, false);
                    builder.businessArrangement(parseString("businessArrangement", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest.Item parseCoverageEligibilityRequestItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.Item.Builder builder = CoverageEligibilityRequest.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, supportingInfoSequenceElementIndex = 0, modifierElementIndex = 0, diagnosisElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "supportingInfoSequence":
                    position = checkElementOrder("supportingInfoSequence", 2, position, true);
                    builder.supportingInfoSequence((PositiveInt) parseInteger(PositiveInt.builder(), "supportingInfoSequence", reader, supportingInfoSequenceElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 3, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 4, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 5, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 6, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 7, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 8, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "facility":
                    position = checkElementOrder("facility", 9, position, false);
                    builder.facility(parseReference("facility", reader, -1));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 10, position, true);
                    builder.diagnosis(parseCoverageEligibilityRequestItemDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 11, position, true);
                    builder.detail(parseReference("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest.Item.Diagnosis parseCoverageEligibilityRequestItemDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.Item.Diagnosis.Builder builder = CoverageEligibilityRequest.Item.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "diagnosisCodeableConcept":
                    position = checkElementOrder("diagnosis[x]", 2, position, false);
                    builder.diagnosis(parseCodeableConcept("diagnosisCodeableConcept", reader, -1));
                    break;
                case "diagnosisReference":
                    position = checkElementOrder("diagnosis[x]", 2, position, false);
                    builder.diagnosis(parseReference("diagnosisReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest.SupportingInfo parseCoverageEligibilityRequestSupportingInfo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.SupportingInfo.Builder builder = CoverageEligibilityRequest.SupportingInfo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "information":
                    position = checkElementOrder("information", 3, position, false);
                    builder.information(parseReference("information", reader, -1));
                    break;
                case "appliesToAll":
                    position = checkElementOrder("appliesToAll", 4, position, false);
                    builder.appliesToAll(parseBoolean("appliesToAll", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse parseCoverageEligibilityResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Builder builder = CoverageEligibilityResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, purposeElementIndex = 0, eventElementIndex = 0, insuranceElementIndex = 0, errorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EligibilityResponseStatus) parseString(EligibilityResponseStatus.builder(), "status", reader, -1));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 10, position, true);
                    builder.purpose((EligibilityResponsePurpose) parseString(EligibilityResponsePurpose.builder(), "purpose", reader, purposeElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 11, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "event":
                    position = checkElementOrder("event", 12, position, true);
                    builder.event(parseCoverageEligibilityResponseEvent("event", reader, eventElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 13, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 13, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 14, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "requestor":
                    position = checkElementOrder("requestor", 15, position, false);
                    builder.requestor(parseReference("requestor", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 16, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 17, position, false);
                    builder.outcome((EligibilityOutcome) parseString(EligibilityOutcome.builder(), "outcome", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 18, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 19, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 20, position, true);
                    builder.insurance(parseCoverageEligibilityResponseInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 21, position, false);
                    builder.preAuthRef(parseString("preAuthRef", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 22, position, false);
                    builder.form(parseCodeableConcept("form", reader, -1));
                    break;
                case "error":
                    position = checkElementOrder("error", 23, position, true);
                    builder.error(parseCoverageEligibilityResponseError("error", reader, errorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse.Error parseCoverageEligibilityResponseError(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Error.Builder builder = CoverageEligibilityResponse.Error.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, expressionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, true);
                    builder.expression(parseString("expression", reader, expressionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse.Event parseCoverageEligibilityResponseEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Event.Builder builder = CoverageEligibilityResponse.Event.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "whenDateTime":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parseDateTime("whenDateTime", reader, -1));
                    break;
                case "whenPeriod":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parsePeriod("whenPeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse.Insurance parseCoverageEligibilityResponseInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Insurance.Builder builder = CoverageEligibilityResponse.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 2, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "inforce":
                    position = checkElementOrder("inforce", 3, position, false);
                    builder.inforce(parseBoolean("inforce", reader, -1));
                    break;
                case "benefitPeriod":
                    position = checkElementOrder("benefitPeriod", 4, position, false);
                    builder.benefitPeriod(parsePeriod("benefitPeriod", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 5, position, true);
                    builder.item(parseCoverageEligibilityResponseInsuranceItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse.Insurance.Item parseCoverageEligibilityResponseInsuranceItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Insurance.Item.Builder builder = CoverageEligibilityResponse.Insurance.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, benefitElementIndex = 0, authorizationSupportingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 3, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 4, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 5, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "excluded":
                    position = checkElementOrder("excluded", 6, position, false);
                    builder.excluded(parseBoolean("excluded", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 7, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 8, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 9, position, false);
                    builder.network(parseCodeableConcept("network", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 10, position, false);
                    builder.unit(parseCodeableConcept("unit", reader, -1));
                    break;
                case "term":
                    position = checkElementOrder("term", 11, position, false);
                    builder.term(parseCodeableConcept("term", reader, -1));
                    break;
                case "benefit":
                    position = checkElementOrder("benefit", 12, position, true);
                    builder.benefit(parseCoverageEligibilityResponseInsuranceItemBenefit("benefit", reader, benefitElementIndex++));
                    break;
                case "authorizationRequired":
                    position = checkElementOrder("authorizationRequired", 13, position, false);
                    builder.authorizationRequired(parseBoolean("authorizationRequired", reader, -1));
                    break;
                case "authorizationSupporting":
                    position = checkElementOrder("authorizationSupporting", 14, position, true);
                    builder.authorizationSupporting(parseCodeableConcept("authorizationSupporting", reader, authorizationSupportingElementIndex++));
                    break;
                case "authorizationUrl":
                    position = checkElementOrder("authorizationUrl", 15, position, false);
                    builder.authorizationUrl(parseUri("authorizationUrl", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse.Insurance.Item.Benefit parseCoverageEligibilityResponseInsuranceItemBenefit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Insurance.Item.Benefit.Builder builder = CoverageEligibilityResponse.Insurance.Item.Benefit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "allowedUnsignedInt":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed((UnsignedInt) parseInteger(UnsignedInt.builder(), "allowedUnsignedInt", reader, -1));
                    break;
                case "allowedString":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed(parseString("allowedString", reader, -1));
                    break;
                case "allowedMoney":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed(parseMoney("allowedMoney", reader, -1));
                    break;
                case "usedUnsignedInt":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used((UnsignedInt) parseInteger(UnsignedInt.builder(), "usedUnsignedInt", reader, -1));
                    break;
                case "usedString":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used(parseString("usedString", reader, -1));
                    break;
                case "usedMoney":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used(parseMoney("usedMoney", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DataRequirement parseDataRequirement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DataRequirement.Builder builder = DataRequirement.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, profileElementIndex = 0, mustSupportElementIndex = 0, codeFilterElementIndex = 0, dateFilterElementIndex = 0, valueFilterElementIndex = 0, sortElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, false);
                    builder.type((FHIRTypes) parseString(FHIRTypes.builder(), "type", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 2, position, true);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, profileElementIndex++));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 3, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 3, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "mustSupport":
                    position = checkElementOrder("mustSupport", 4, position, true);
                    builder.mustSupport(parseString("mustSupport", reader, mustSupportElementIndex++));
                    break;
                case "codeFilter":
                    position = checkElementOrder("codeFilter", 5, position, true);
                    builder.codeFilter(parseDataRequirementCodeFilter("codeFilter", reader, codeFilterElementIndex++));
                    break;
                case "dateFilter":
                    position = checkElementOrder("dateFilter", 6, position, true);
                    builder.dateFilter(parseDataRequirementDateFilter("dateFilter", reader, dateFilterElementIndex++));
                    break;
                case "valueFilter":
                    position = checkElementOrder("valueFilter", 7, position, true);
                    builder.valueFilter(parseElement("valueFilter", reader, valueFilterElementIndex++));
                    break;
                case "limit":
                    position = checkElementOrder("limit", 8, position, false);
                    builder.limit((PositiveInt) parseInteger(PositiveInt.builder(), "limit", reader, -1));
                    break;
                case "sort":
                    position = checkElementOrder("sort", 9, position, true);
                    builder.sort(parseDataRequirementSort("sort", reader, sortElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DataRequirement.CodeFilter parseDataRequirementCodeFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DataRequirement.CodeFilter.Builder builder = DataRequirement.CodeFilter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "searchParam":
                    position = checkElementOrder("searchParam", 3, position, false);
                    builder.searchParam(parseString("searchParam", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 4, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 5, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DataRequirement.DateFilter parseDataRequirementDateFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DataRequirement.DateFilter.Builder builder = DataRequirement.DateFilter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "searchParam":
                    position = checkElementOrder("searchParam", 3, position, false);
                    builder.searchParam(parseString("searchParam", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DataRequirement.Sort parseDataRequirementSort(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DataRequirement.Sort.Builder builder = DataRequirement.Sort.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "direction":
                    position = checkElementOrder("direction", 3, position, false);
                    builder.direction((SortDirection) parseString(SortDirection.builder(), "direction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Date parseDate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Date.Builder builder = Date.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DateTime parseDateTime(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DateTime.Builder builder = DateTime.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Decimal parseDecimal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Decimal.Builder builder = Decimal.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DetectedIssue parseDetectedIssue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DetectedIssue.Builder builder = DetectedIssue.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, implicatedElementIndex = 0, evidenceElementIndex = 0, mitigationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((DetectedIssueStatus) parseString(DetectedIssueStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 11, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 12, position, false);
                    builder.severity((DetectedIssueSeverity) parseString(DetectedIssueSeverity.builder(), "severity", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "identifiedDateTime":
                    position = checkElementOrder("identified[x]", 15, position, false);
                    builder.identified(parseDateTime("identifiedDateTime", reader, -1));
                    break;
                case "identifiedPeriod":
                    position = checkElementOrder("identified[x]", 15, position, false);
                    builder.identified(parsePeriod("identifiedPeriod", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 16, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "implicated":
                    position = checkElementOrder("implicated", 17, position, true);
                    builder.implicated(parseReference("implicated", reader, implicatedElementIndex++));
                    break;
                case "evidence":
                    position = checkElementOrder("evidence", 18, position, true);
                    builder.evidence(parseDetectedIssueEvidence("evidence", reader, evidenceElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 19, position, false);
                    builder.detail((Markdown) parseString(Markdown.builder(), "detail", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 20, position, false);
                    builder.reference(parseUri("reference", reader, -1));
                    break;
                case "mitigation":
                    position = checkElementOrder("mitigation", 21, position, true);
                    builder.mitigation(parseDetectedIssueMitigation("mitigation", reader, mitigationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DetectedIssue.Evidence parseDetectedIssueEvidence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DetectedIssue.Evidence.Builder builder = DetectedIssue.Evidence.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 3, position, true);
                    builder.detail(parseReference("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DetectedIssue.Mitigation parseDetectedIssueMitigation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DetectedIssue.Mitigation.Builder builder = DetectedIssue.Mitigation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, false);
                    builder.action(parseCodeableConcept("action", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 3, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 4, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 5, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device parseDevice(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.Builder builder = Device.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, udiCarrierElementIndex = 0, nameElementIndex = 0, categoryElementIndex = 0, typeElementIndex = 0, versionElementIndex = 0, conformsToElementIndex = 0, propertyElementIndex = 0, contactElementIndex = 0, endpointElementIndex = 0, gatewayElementIndex = 0, noteElementIndex = 0, safetyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "displayName":
                    position = checkElementOrder("displayName", 9, position, false);
                    builder.displayName(parseString("displayName", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 10, position, false);
                    builder.definition(parseCodeableReference("definition", reader, -1));
                    break;
                case "udiCarrier":
                    position = checkElementOrder("udiCarrier", 11, position, true);
                    builder.udiCarrier(parseDeviceUdiCarrier("udiCarrier", reader, udiCarrierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((FHIRDeviceStatus) parseString(FHIRDeviceStatus.builder(), "status", reader, -1));
                    break;
                case "availabilityStatus":
                    position = checkElementOrder("availabilityStatus", 13, position, false);
                    builder.availabilityStatus(parseCodeableConcept("availabilityStatus", reader, -1));
                    break;
                case "biologicalSourceEvent":
                    position = checkElementOrder("biologicalSourceEvent", 14, position, false);
                    builder.biologicalSourceEvent(parseIdentifier("biologicalSourceEvent", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 15, position, false);
                    builder.manufacturer(parseString("manufacturer", reader, -1));
                    break;
                case "manufactureDate":
                    position = checkElementOrder("manufactureDate", 16, position, false);
                    builder.manufactureDate(parseDateTime("manufactureDate", reader, -1));
                    break;
                case "expirationDate":
                    position = checkElementOrder("expirationDate", 17, position, false);
                    builder.expirationDate(parseDateTime("expirationDate", reader, -1));
                    break;
                case "lotNumber":
                    position = checkElementOrder("lotNumber", 18, position, false);
                    builder.lotNumber(parseString("lotNumber", reader, -1));
                    break;
                case "serialNumber":
                    position = checkElementOrder("serialNumber", 19, position, false);
                    builder.serialNumber(parseString("serialNumber", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 20, position, true);
                    builder.name(parseDeviceName("name", reader, nameElementIndex++));
                    break;
                case "modelNumber":
                    position = checkElementOrder("modelNumber", 21, position, false);
                    builder.modelNumber(parseString("modelNumber", reader, -1));
                    break;
                case "partNumber":
                    position = checkElementOrder("partNumber", 22, position, false);
                    builder.partNumber(parseString("partNumber", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 23, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 24, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 25, position, true);
                    builder.version(parseDeviceVersion("version", reader, versionElementIndex++));
                    break;
                case "conformsTo":
                    position = checkElementOrder("conformsTo", 26, position, true);
                    builder.conformsTo(parseDeviceConformsTo("conformsTo", reader, conformsToElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 27, position, true);
                    builder.property(parseDeviceProperty("property", reader, propertyElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 28, position, false);
                    builder.mode(parseCodeableConcept("mode", reader, -1));
                    break;
                case "cycle":
                    position = checkElementOrder("cycle", 29, position, false);
                    builder.cycle((Count) parseQuantity(Count.builder(), "cycle", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 30, position, false);
                    builder.duration((Duration) parseQuantity(Duration.builder(), "duration", reader, -1));
                    break;
                case "owner":
                    position = checkElementOrder("owner", 31, position, false);
                    builder.owner(parseReference("owner", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 32, position, true);
                    builder.contact(parseContactPoint("contact", reader, contactElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 33, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 34, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 35, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                case "gateway":
                    position = checkElementOrder("gateway", 36, position, true);
                    builder.gateway(parseCodeableReference("gateway", reader, gatewayElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 37, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "safety":
                    position = checkElementOrder("safety", 38, position, true);
                    builder.safety(parseCodeableConcept("safety", reader, safetyElementIndex++));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 39, position, false);
                    builder.parent(parseReference("parent", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.ConformsTo parseDeviceConformsTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.ConformsTo.Builder builder = Device.ConformsTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "specification":
                    position = checkElementOrder("specification", 3, position, false);
                    builder.specification(parseCodeableConcept("specification", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 4, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.Name parseDeviceName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.Name.Builder builder = Device.Name.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 2, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((DeviceNameType) parseString(DeviceNameType.builder(), "type", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseBoolean("display", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.Property parseDeviceProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.Property.Builder builder = Device.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.UdiCarrier parseDeviceUdiCarrier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.UdiCarrier.Builder builder = Device.UdiCarrier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "deviceIdentifier":
                    position = checkElementOrder("deviceIdentifier", 2, position, false);
                    builder.deviceIdentifier(parseString("deviceIdentifier", reader, -1));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 3, position, false);
                    builder.issuer(parseUri("issuer", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 4, position, false);
                    builder.jurisdiction(parseUri("jurisdiction", reader, -1));
                    break;
                case "carrierAIDC":
                    position = checkElementOrder("carrierAIDC", 5, position, false);
                    builder.carrierAIDC(parseBase64Binary("carrierAIDC", reader, -1));
                    break;
                case "carrierHRF":
                    position = checkElementOrder("carrierHRF", 6, position, false);
                    builder.carrierHRF(parseString("carrierHRF", reader, -1));
                    break;
                case "entryType":
                    position = checkElementOrder("entryType", 7, position, false);
                    builder.entryType((UDIEntryType) parseString(UDIEntryType.builder(), "entryType", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.Version parseDeviceVersion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.Version.Builder builder = Device.Version.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "component":
                    position = checkElementOrder("component", 3, position, false);
                    builder.component(parseIdentifier("component", reader, -1));
                    break;
                case "installDate":
                    position = checkElementOrder("installDate", 4, position, false);
                    builder.installDate(parseDateTime("installDate", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceAssociation parseDeviceAssociation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceAssociation.Builder builder = DeviceAssociation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, statusReasonElementIndex = 0, operationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 9, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 12, position, true);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, statusReasonElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "bodyStructure":
                    position = checkElementOrder("bodyStructure", 14, position, false);
                    builder.bodyStructure(parseReference("bodyStructure", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 15, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 16, position, true);
                    builder.operation(parseDeviceAssociationOperation("operation", reader, operationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceAssociation.Operation parseDeviceAssociationOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceAssociation.Operation.Builder builder = DeviceAssociation.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, operatorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 2, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "operator":
                    position = checkElementOrder("operator", 3, position, true);
                    builder.operator(parseReference("operator", reader, operatorElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition parseDeviceDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Builder builder = DeviceDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, udiDeviceIdentifierElementIndex = 0, regulatoryIdentifierElementIndex = 0, deviceNameElementIndex = 0, classificationElementIndex = 0, conformsToElementIndex = 0, hasPartElementIndex = 0, packagingElementIndex = 0, versionElementIndex = 0, safetyElementIndex = 0, shelfLifeStorageElementIndex = 0, languageCodeElementIndex = 0, propertyElementIndex = 0, contactElementIndex = 0, linkElementIndex = 0, noteElementIndex = 0, materialElementIndex = 0, productionIdentifierInUDIElementIndex = 0, chargeItemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 8, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "udiDeviceIdentifier":
                    position = checkElementOrder("udiDeviceIdentifier", 10, position, true);
                    builder.udiDeviceIdentifier(parseDeviceDefinitionUdiDeviceIdentifier("udiDeviceIdentifier", reader, udiDeviceIdentifierElementIndex++));
                    break;
                case "regulatoryIdentifier":
                    position = checkElementOrder("regulatoryIdentifier", 11, position, true);
                    builder.regulatoryIdentifier(parseDeviceDefinitionRegulatoryIdentifier("regulatoryIdentifier", reader, regulatoryIdentifierElementIndex++));
                    break;
                case "partNumber":
                    position = checkElementOrder("partNumber", 12, position, false);
                    builder.partNumber(parseString("partNumber", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 13, position, false);
                    builder.manufacturer(parseReference("manufacturer", reader, -1));
                    break;
                case "deviceName":
                    position = checkElementOrder("deviceName", 14, position, true);
                    builder.deviceName(parseDeviceDefinitionDeviceName("deviceName", reader, deviceNameElementIndex++));
                    break;
                case "modelNumber":
                    position = checkElementOrder("modelNumber", 15, position, false);
                    builder.modelNumber(parseString("modelNumber", reader, -1));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 16, position, true);
                    builder.classification(parseDeviceDefinitionClassification("classification", reader, classificationElementIndex++));
                    break;
                case "conformsTo":
                    position = checkElementOrder("conformsTo", 17, position, true);
                    builder.conformsTo(parseDeviceDefinitionConformsTo("conformsTo", reader, conformsToElementIndex++));
                    break;
                case "hasPart":
                    position = checkElementOrder("hasPart", 18, position, true);
                    builder.hasPart(parseDeviceDefinitionHasPart("hasPart", reader, hasPartElementIndex++));
                    break;
                case "packaging":
                    position = checkElementOrder("packaging", 19, position, true);
                    builder.packaging(parseDeviceDefinitionPackaging("packaging", reader, packagingElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 20, position, true);
                    builder.version(parseDeviceDefinitionVersion("version", reader, versionElementIndex++));
                    break;
                case "safety":
                    position = checkElementOrder("safety", 21, position, true);
                    builder.safety(parseCodeableConcept("safety", reader, safetyElementIndex++));
                    break;
                case "shelfLifeStorage":
                    position = checkElementOrder("shelfLifeStorage", 22, position, true);
                    builder.shelfLifeStorage(parseProductShelfLife("shelfLifeStorage", reader, shelfLifeStorageElementIndex++));
                    break;
                case "languageCode":
                    position = checkElementOrder("languageCode", 23, position, true);
                    builder.languageCode(parseCodeableConcept("languageCode", reader, languageCodeElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 24, position, true);
                    builder.property(parseDeviceDefinitionProperty("property", reader, propertyElementIndex++));
                    break;
                case "owner":
                    position = checkElementOrder("owner", 25, position, false);
                    builder.owner(parseReference("owner", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 26, position, true);
                    builder.contact(parseContactPoint("contact", reader, contactElementIndex++));
                    break;
                case "link":
                    position = checkElementOrder("link", 27, position, true);
                    builder.link(parseDeviceDefinitionLink("link", reader, linkElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 28, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "material":
                    position = checkElementOrder("material", 29, position, true);
                    builder.material(parseDeviceDefinitionMaterial("material", reader, materialElementIndex++));
                    break;
                case "productionIdentifierInUDI":
                    position = checkElementOrder("productionIdentifierInUDI", 30, position, true);
                    builder.productionIdentifierInUDI((DeviceProductionIdentifierInUDI) parseString(DeviceProductionIdentifierInUDI.builder(), "productionIdentifierInUDI", reader, productionIdentifierInUDIElementIndex++));
                    break;
                case "guideline":
                    position = checkElementOrder("guideline", 31, position, false);
                    builder.guideline(parseDeviceDefinitionGuideline("guideline", reader, -1));
                    break;
                case "correctiveAction":
                    position = checkElementOrder("correctiveAction", 32, position, false);
                    builder.correctiveAction(parseDeviceDefinitionCorrectiveAction("correctiveAction", reader, -1));
                    break;
                case "chargeItem":
                    position = checkElementOrder("chargeItem", 33, position, true);
                    builder.chargeItem(parseDeviceDefinitionChargeItem("chargeItem", reader, chargeItemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.ChargeItem parseDeviceDefinitionChargeItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.ChargeItem.Builder builder = DeviceDefinition.ChargeItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, useContextElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "chargeItemCode":
                    position = checkElementOrder("chargeItemCode", 2, position, false);
                    builder.chargeItemCode(parseCodeableReference("chargeItemCode", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 3, position, false);
                    builder.count(parseQuantity("count", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 4, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 5, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Classification parseDeviceDefinitionClassification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Classification.Builder builder = DeviceDefinition.Classification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, justificationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "justification":
                    position = checkElementOrder("justification", 3, position, true);
                    builder.justification(parseRelatedArtifact("justification", reader, justificationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.ConformsTo parseDeviceDefinitionConformsTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.ConformsTo.Builder builder = DeviceDefinition.ConformsTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, versionElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "specification":
                    position = checkElementOrder("specification", 3, position, false);
                    builder.specification(parseCodeableConcept("specification", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 4, position, true);
                    builder.version(parseString("version", reader, versionElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 5, position, true);
                    builder.source(parseRelatedArtifact("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.CorrectiveAction parseDeviceDefinitionCorrectiveAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.CorrectiveAction.Builder builder = DeviceDefinition.CorrectiveAction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "recall":
                    position = checkElementOrder("recall", 2, position, false);
                    builder.recall(parseBoolean("recall", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 3, position, false);
                    builder.scope((DeviceCorrectiveActionScope) parseString(DeviceCorrectiveActionScope.builder(), "scope", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.DeviceName parseDeviceDefinitionDeviceName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.DeviceName.Builder builder = DeviceDefinition.DeviceName.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((DeviceNameType) parseString(DeviceNameType.builder(), "type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Guideline parseDeviceDefinitionGuideline(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Guideline.Builder builder = DeviceDefinition.Guideline.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, useContextElementIndex = 0, relatedArtifactElementIndex = 0, indicationElementIndex = 0, contraindicationElementIndex = 0, warningElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 2, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "usageInstruction":
                    position = checkElementOrder("usageInstruction", 3, position, false);
                    builder.usageInstruction((Markdown) parseString(Markdown.builder(), "usageInstruction", reader, -1));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 4, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 5, position, true);
                    builder.indication(parseCodeableConcept("indication", reader, indicationElementIndex++));
                    break;
                case "contraindication":
                    position = checkElementOrder("contraindication", 6, position, true);
                    builder.contraindication(parseCodeableConcept("contraindication", reader, contraindicationElementIndex++));
                    break;
                case "warning":
                    position = checkElementOrder("warning", 7, position, true);
                    builder.warning(parseCodeableConcept("warning", reader, warningElementIndex++));
                    break;
                case "intendedUse":
                    position = checkElementOrder("intendedUse", 8, position, false);
                    builder.intendedUse(parseString("intendedUse", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.HasPart parseDeviceDefinitionHasPart(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.HasPart.Builder builder = DeviceDefinition.HasPart.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 3, position, false);
                    builder.count(parseInteger("count", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Link parseDeviceDefinitionLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Link.Builder builder = DeviceDefinition.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relation":
                    position = checkElementOrder("relation", 2, position, false);
                    builder.relation(parseCoding("relation", reader, -1));
                    break;
                case "relatedDevice":
                    position = checkElementOrder("relatedDevice", 3, position, false);
                    builder.relatedDevice(parseCodeableReference("relatedDevice", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Material parseDeviceDefinitionMaterial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Material.Builder builder = DeviceDefinition.Material.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "substance":
                    position = checkElementOrder("substance", 2, position, false);
                    builder.substance(parseCodeableConcept("substance", reader, -1));
                    break;
                case "alternate":
                    position = checkElementOrder("alternate", 3, position, false);
                    builder.alternate(parseBoolean("alternate", reader, -1));
                    break;
                case "allergenicIndicator":
                    position = checkElementOrder("allergenicIndicator", 4, position, false);
                    builder.allergenicIndicator(parseBoolean("allergenicIndicator", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Packaging parseDeviceDefinitionPackaging(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Packaging.Builder builder = DeviceDefinition.Packaging.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, distributorElementIndex = 0, udiDeviceIdentifierElementIndex = 0, packagingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 4, position, false);
                    builder.count(parseInteger("count", reader, -1));
                    break;
                case "distributor":
                    position = checkElementOrder("distributor", 5, position, true);
                    builder.distributor(parseDeviceDefinitionPackagingDistributor("distributor", reader, distributorElementIndex++));
                    break;
                case "udiDeviceIdentifier":
                    position = checkElementOrder("udiDeviceIdentifier", 6, position, true);
                    builder.udiDeviceIdentifier(parseDeviceDefinitionUdiDeviceIdentifier("udiDeviceIdentifier", reader, udiDeviceIdentifierElementIndex++));
                    break;
                case "packaging":
                    position = checkElementOrder("packaging", 7, position, true);
                    builder.packaging(parseDeviceDefinitionPackaging("packaging", reader, packagingElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Packaging.Distributor parseDeviceDefinitionPackagingDistributor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Packaging.Distributor.Builder builder = DeviceDefinition.Packaging.Distributor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, organizationReferenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "organizationReference":
                    position = checkElementOrder("organizationReference", 3, position, true);
                    builder.organizationReference(parseReference("organizationReference", reader, organizationReferenceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Property parseDeviceDefinitionProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Property.Builder builder = DeviceDefinition.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.RegulatoryIdentifier parseDeviceDefinitionRegulatoryIdentifier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.RegulatoryIdentifier.Builder builder = DeviceDefinition.RegulatoryIdentifier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((DeviceRegulatoryIdentifierType) parseString(DeviceRegulatoryIdentifierType.builder(), "type", reader, -1));
                    break;
                case "deviceIdentifier":
                    position = checkElementOrder("deviceIdentifier", 3, position, false);
                    builder.deviceIdentifier(parseString("deviceIdentifier", reader, -1));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 4, position, false);
                    builder.issuer(parseUri("issuer", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 5, position, false);
                    builder.jurisdiction(parseUri("jurisdiction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.UdiDeviceIdentifier parseDeviceDefinitionUdiDeviceIdentifier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.UdiDeviceIdentifier.Builder builder = DeviceDefinition.UdiDeviceIdentifier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, marketDistributionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "deviceIdentifier":
                    position = checkElementOrder("deviceIdentifier", 2, position, false);
                    builder.deviceIdentifier(parseString("deviceIdentifier", reader, -1));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 3, position, false);
                    builder.issuer(parseUri("issuer", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 4, position, false);
                    builder.jurisdiction(parseUri("jurisdiction", reader, -1));
                    break;
                case "marketDistribution":
                    position = checkElementOrder("marketDistribution", 5, position, true);
                    builder.marketDistribution(parseDeviceDefinitionUdiDeviceIdentifierMarketDistribution("marketDistribution", reader, marketDistributionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.UdiDeviceIdentifier.MarketDistribution parseDeviceDefinitionUdiDeviceIdentifierMarketDistribution(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.UdiDeviceIdentifier.MarketDistribution.Builder builder = DeviceDefinition.UdiDeviceIdentifier.MarketDistribution.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "marketPeriod":
                    position = checkElementOrder("marketPeriod", 2, position, false);
                    builder.marketPeriod(parsePeriod("marketPeriod", reader, -1));
                    break;
                case "subJurisdiction":
                    position = checkElementOrder("subJurisdiction", 3, position, false);
                    builder.subJurisdiction(parseUri("subJurisdiction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Version parseDeviceDefinitionVersion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Version.Builder builder = DeviceDefinition.Version.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "component":
                    position = checkElementOrder("component", 3, position, false);
                    builder.component(parseIdentifier("component", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 4, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDispense parseDeviceDispense(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDispense.Builder builder = DeviceDispense.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, categoryElementIndex = 0, supportingInformationElementIndex = 0, performerElementIndex = 0, noteElementIndex = 0, eventHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((DeviceDispenseStatus) parseString(DeviceDispenseStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 12, position, false);
                    builder.statusReason(parseCodeableReference("statusReason", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 13, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 14, position, false);
                    builder.device(parseCodeableReference("device", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 15, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "receiver":
                    position = checkElementOrder("receiver", 16, position, false);
                    builder.receiver(parseReference("receiver", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 17, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 18, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 19, position, true);
                    builder.performer(parseDeviceDispensePerformer("performer", reader, performerElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 20, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 21, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 22, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "preparedDate":
                    position = checkElementOrder("preparedDate", 23, position, false);
                    builder.preparedDate(parseDateTime("preparedDate", reader, -1));
                    break;
                case "whenHandedOver":
                    position = checkElementOrder("whenHandedOver", 24, position, false);
                    builder.whenHandedOver(parseDateTime("whenHandedOver", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 25, position, false);
                    builder.destination(parseReference("destination", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 26, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "usageInstruction":
                    position = checkElementOrder("usageInstruction", 27, position, false);
                    builder.usageInstruction((Markdown) parseString(Markdown.builder(), "usageInstruction", reader, -1));
                    break;
                case "eventHistory":
                    position = checkElementOrder("eventHistory", 28, position, true);
                    builder.eventHistory(parseReference("eventHistory", reader, eventHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDispense.Performer parseDeviceDispensePerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDispense.Performer.Builder builder = DeviceDispense.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceMetric parseDeviceMetric(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceMetric.Builder builder = DeviceMetric.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, calibrationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 10, position, false);
                    builder.unit(parseCodeableConcept("unit", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 11, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "operationalStatus":
                    position = checkElementOrder("operationalStatus", 12, position, false);
                    builder.operationalStatus((DeviceMetricOperationalStatus) parseString(DeviceMetricOperationalStatus.builder(), "operationalStatus", reader, -1));
                    break;
                case "color":
                    position = checkElementOrder("color", 13, position, false);
                    builder.color((Code) parseString(Code.builder(), "color", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 14, position, false);
                    builder.category((DeviceMetricCategory) parseString(DeviceMetricCategory.builder(), "category", reader, -1));
                    break;
                case "measurementFrequency":
                    position = checkElementOrder("measurementFrequency", 15, position, false);
                    builder.measurementFrequency(parseQuantity("measurementFrequency", reader, -1));
                    break;
                case "calibration":
                    position = checkElementOrder("calibration", 16, position, true);
                    builder.calibration(parseDeviceMetricCalibration("calibration", reader, calibrationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceMetric.Calibration parseDeviceMetricCalibration(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceMetric.Calibration.Builder builder = DeviceMetric.Calibration.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((DeviceMetricCalibrationType) parseString(DeviceMetricCalibrationType.builder(),"type", reader, -1));
                    break;
                case "state":
                    position = checkElementOrder("state", 3, position, false);
                    builder.state((DeviceMetricCalibrationState) parseString(DeviceMetricCalibrationState.builder(),"state", reader, -1));
                    break;
                case "time":
                    position = checkElementOrder("time", 4, position, false);
                    builder.time(parseInstant("time", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceRequest parseDeviceRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceRequest.Builder builder = DeviceRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, replacesElementIndex = 0, parameterElementIndex = 0, reasonElementIndex = 0, insuranceElementIndex = 0, supportingInfoElementIndex = 0, noteElementIndex = 0, relevantHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 12, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 13, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((DeviceRequestStatus) parseString(DeviceRequestStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((RequestIntent) parseString(RequestIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 16, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 17, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 18, position, false);
                    builder.code(parseCodeableReference("code", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 19, position, false);
                    builder.quantity(parseInteger("quantity", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 20, position, true);
                    builder.parameter(parseDeviceRequestParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 21, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 22, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 23, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 23, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 23, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 24, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 25, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 26, position, false);
                    builder.performer(parseCodeableReference("performer", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 27, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "asNeeded":
                    position = checkElementOrder("asNeeded", 28, position, false);
                    builder.asNeeded(parseBoolean("asNeeded", reader, -1));
                    break;
                case "asNeededFor":
                    position = checkElementOrder("asNeededFor", 29, position, false);
                    builder.asNeededFor(parseCodeableConcept("asNeededFor", reader, -1));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 30, position, true);
                    builder.insurance(parseReference("insurance", reader, insuranceElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 31, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 32, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "relevantHistory":
                    position = checkElementOrder("relevantHistory", 33, position, true);
                    builder.relevantHistory(parseReference("relevantHistory", reader, relevantHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceRequest.Parameter parseDeviceRequestParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceRequest.Parameter.Builder builder = DeviceRequest.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceUsage parseDeviceUsage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceUsage.Builder builder = DeviceUsage.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, categoryElementIndex = 0, derivedFromElementIndex = 0, usageReasonElementIndex = 0, reasonElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((DeviceUsageStatus) parseString(DeviceUsageStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 12, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 13, position, true);
                    builder.derivedFrom(parseReference("derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "context":
                    position = checkElementOrder("context", 14, position, false);
                    builder.context(parseReference("context", reader, -1));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 15, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 15, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "timingDateTime":
                    position = checkElementOrder("timing[x]", 15, position, false);
                    builder.timing(parseDateTime("timingDateTime", reader, -1));
                    break;
                case "dateAsserted":
                    position = checkElementOrder("dateAsserted", 16, position, false);
                    builder.dateAsserted(parseDateTime("dateAsserted", reader, -1));
                    break;
                case "usageStatus":
                    position = checkElementOrder("usageStatus", 17, position, false);
                    builder.usageStatus(parseCodeableConcept("usageStatus", reader, -1));
                    break;
                case "usageReason":
                    position = checkElementOrder("usageReason", 18, position, true);
                    builder.usageReason(parseCodeableConcept("usageReason", reader, usageReasonElementIndex++));
                    break;
                case "adherence":
                    position = checkElementOrder("adherence", 19, position, false);
                    builder.adherence(parseDeviceUsageAdherence("adherence", reader, -1));
                    break;
                case "informationSource":
                    position = checkElementOrder("informationSource", 20, position, false);
                    builder.informationSource(parseReference("informationSource", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 21, position, false);
                    builder.device(parseCodeableReference("device", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 22, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 23, position, false);
                    builder.bodySite(parseCodeableReference("bodySite", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 24, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceUsage.Adherence parseDeviceUsageAdherence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceUsage.Adherence.Builder builder = DeviceUsage.Adherence.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, reasonElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DiagnosticReport parseDiagnosticReport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DiagnosticReport.Builder builder = DiagnosticReport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, categoryElementIndex = 0, performerElementIndex = 0, resultsInterpreterElementIndex = 0, specimenElementIndex = 0, resultElementIndex = 0, noteElementIndex = 0, studyElementIndex = 0, supportingInfoElementIndex = 0, mediaElementIndex = 0, conclusionCodeElementIndex = 0, presentedFormElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((DiagnosticReportStatus) parseString(DiagnosticReportStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 12, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "effectiveDateTime":
                    position = checkElementOrder("effective[x]", 15, position, false);
                    builder.effective(parseDateTime("effectiveDateTime", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effective[x]", 15, position, false);
                    builder.effective(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 16, position, false);
                    builder.issued(parseInstant("issued", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 17, position, true);
                    builder.performer(parseReference("performer", reader, performerElementIndex++));
                    break;
                case "resultsInterpreter":
                    position = checkElementOrder("resultsInterpreter", 18, position, true);
                    builder.resultsInterpreter(parseReference("resultsInterpreter", reader, resultsInterpreterElementIndex++));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 19, position, true);
                    builder.specimen(parseReference("specimen", reader, specimenElementIndex++));
                    break;
                case "result":
                    position = checkElementOrder("result", 20, position, true);
                    builder.result(parseReference("result", reader, resultElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 21, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "study":
                    position = checkElementOrder("study", 22, position, true);
                    builder.study(parseReference("study", reader, studyElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 23, position, true);
                    builder.supportingInfo(parseDiagnosticReportSupportingInfo("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "media":
                    position = checkElementOrder("media", 24, position, true);
                    builder.media(parseDiagnosticReportMedia("media", reader, mediaElementIndex++));
                    break;
                case "composition":
                    position = checkElementOrder("composition", 25, position, false);
                    builder.composition(parseReference("composition", reader, -1));
                    break;
                case "conclusion":
                    position = checkElementOrder("conclusion", 26, position, false);
                    builder.conclusion((Markdown) parseString(Markdown.builder(), "conclusion", reader, -1));
                    break;
                case "conclusionCode":
                    position = checkElementOrder("conclusionCode", 27, position, true);
                    builder.conclusionCode(parseCodeableConcept("conclusionCode", reader, conclusionCodeElementIndex++));
                    break;
                case "presentedForm":
                    position = checkElementOrder("presentedForm", 28, position, true);
                    builder.presentedForm(parseAttachment("presentedForm", reader, presentedFormElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DiagnosticReport.Media parseDiagnosticReportMedia(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DiagnosticReport.Media.Builder builder = DiagnosticReport.Media.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 2, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 3, position, false);
                    builder.link(parseReference("link", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DiagnosticReport.SupportingInfo parseDiagnosticReportSupportingInfo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DiagnosticReport.SupportingInfo.Builder builder = DiagnosticReport.SupportingInfo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentReference parseDocumentReference(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentReference.Builder builder = DocumentReference.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, modalityElementIndex = 0, categoryElementIndex = 0, contextElementIndex = 0, eventElementIndex = 0, bodySiteElementIndex = 0, authorElementIndex = 0, attesterElementIndex = 0, relatesToElementIndex = 0, securityLabelElementIndex = 0, contentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 10, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((DocumentReferenceStatus) parseString(DocumentReferenceStatus.builder(), "status", reader, -1));
                    break;
                case "docStatus":
                    position = checkElementOrder("docStatus", 12, position, false);
                    builder.docStatus((ReferredDocumentStatus) parseString(ReferredDocumentStatus.builder(), "docStatus", reader, -1));
                    break;
                case "modality":
                    position = checkElementOrder("modality", 13, position, true);
                    builder.modality(parseCodeableConcept("modality", reader, modalityElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 14, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 15, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 16, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 17, position, true);
                    builder.context(parseReference("context", reader, contextElementIndex++));
                    break;
                case "event":
                    position = checkElementOrder("event", 18, position, true);
                    builder.event(parseCodeableReference("event", reader, eventElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 19, position, true);
                    builder.bodySite(parseCodeableReference("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "facilityType":
                    position = checkElementOrder("facilityType", 20, position, false);
                    builder.facilityType(parseCodeableConcept("facilityType", reader, -1));
                    break;
                case "practiceSetting":
                    position = checkElementOrder("practiceSetting", 21, position, false);
                    builder.practiceSetting(parseCodeableConcept("practiceSetting", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 22, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 23, position, false);
                    builder.date(parseInstant("date", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 24, position, true);
                    builder.author(parseReference("author", reader, authorElementIndex++));
                    break;
                case "attester":
                    position = checkElementOrder("attester", 25, position, true);
                    builder.attester(parseDocumentReferenceAttester("attester", reader, attesterElementIndex++));
                    break;
                case "custodian":
                    position = checkElementOrder("custodian", 26, position, false);
                    builder.custodian(parseReference("custodian", reader, -1));
                    break;
                case "relatesTo":
                    position = checkElementOrder("relatesTo", 27, position, true);
                    builder.relatesTo(parseDocumentReferenceRelatesTo("relatesTo", reader, relatesToElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 28, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "securityLabel":
                    position = checkElementOrder("securityLabel", 29, position, true);
                    builder.securityLabel(parseCodeableConcept("securityLabel", reader, securityLabelElementIndex++));
                    break;
                case "content":
                    position = checkElementOrder("content", 30, position, true);
                    builder.content(parseDocumentReferenceContent("content", reader, contentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentReference.Attester parseDocumentReferenceAttester(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentReference.Attester.Builder builder = DocumentReference.Attester.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode(parseCodeableConcept("mode", reader, -1));
                    break;
                case "time":
                    position = checkElementOrder("time", 3, position, false);
                    builder.time(parseDateTime("time", reader, -1));
                    break;
                case "party":
                    position = checkElementOrder("party", 4, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentReference.Content parseDocumentReferenceContent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentReference.Content.Builder builder = DocumentReference.Content.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, profileElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "attachment":
                    position = checkElementOrder("attachment", 2, position, false);
                    builder.attachment(parseAttachment("attachment", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, true);
                    builder.profile(parseDocumentReferenceContentProfile("profile", reader, profileElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentReference.Content.Profile parseDocumentReferenceContentProfile(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentReference.Content.Profile.Builder builder = DocumentReference.Content.Profile.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentReference.RelatesTo parseDocumentReferenceRelatesTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentReference.RelatesTo.Builder builder = DocumentReference.RelatesTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 3, position, false);
                    builder.target(parseReference("target", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Dosage parseDosage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Dosage.Builder builder = Dosage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additionalInstructionElementIndex = 0, asNeededForElementIndex = 0, doseAndRateElementIndex = 0, maxDosePerPeriodElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence(parseInteger("sequence", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 3, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "additionalInstruction":
                    position = checkElementOrder("additionalInstruction", 4, position, true);
                    builder.additionalInstruction(parseCodeableConcept("additionalInstruction", reader, additionalInstructionElementIndex++));
                    break;
                case "patientInstruction":
                    position = checkElementOrder("patientInstruction", 5, position, false);
                    builder.patientInstruction(parseString("patientInstruction", reader, -1));
                    break;
                case "timing":
                    position = checkElementOrder("timing", 6, position, false);
                    builder.timing(parseTiming("timing", reader, -1));
                    break;
                case "asNeeded":
                    position = checkElementOrder("asNeeded", 7, position, false);
                    builder.asNeeded(parseBoolean("asNeeded", reader, -1));
                    break;
                case "asNeededFor":
                    position = checkElementOrder("asNeededFor", 8, position, true);
                    builder.asNeededFor(parseCodeableConcept("asNeededFor", reader, asNeededForElementIndex++));
                    break;
                case "site":
                    position = checkElementOrder("site", 9, position, false);
                    builder.site(parseCodeableConcept("site", reader, -1));
                    break;
                case "route":
                    position = checkElementOrder("route", 10, position, false);
                    builder.route(parseCodeableConcept("route", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 11, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "doseAndRate":
                    position = checkElementOrder("doseAndRate", 12, position, true);
                    builder.doseAndRate(parseDosageDoseAndRate("doseAndRate", reader, doseAndRateElementIndex++));
                    break;
                case "maxDosePerPeriod":
                    position = checkElementOrder("maxDosePerPeriod", 13, position, true);
                    builder.maxDosePerPeriod(parseRatio("maxDosePerPeriod", reader, maxDosePerPeriodElementIndex++));
                    break;
                case "maxDosePerAdministration":
                    position = checkElementOrder("maxDosePerAdministration", 14, position, false);
                    builder.maxDosePerAdministration((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "maxDosePerAdministration", reader, -1));
                    break;
                case "maxDosePerLifetime":
                    position = checkElementOrder("maxDosePerLifetime", 15, position, false);
                    builder.maxDosePerLifetime((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "maxDosePerLifetime", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Dosage.DoseAndRate parseDosageDoseAndRate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Dosage.DoseAndRate.Builder builder = Dosage.DoseAndRate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "doseRange":
                    position = checkElementOrder("dose[x]", 3, position, false);
                    builder.dose(parseRange("doseRange", reader, -1));
                    break;
                case "doseQuantity":
                    position = checkElementOrder("dose[x]", 3, position, false);
                    builder.dose((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "doseQuantity", reader, -1));
                    break;
                case "rateRatio":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate(parseRatio("rateRatio", reader, -1));
                    break;
                case "rateRange":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate(parseRange("rateRange", reader, -1));
                    break;
                case "rateQuantity":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "rateQuantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition parseElementDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Builder builder = ElementDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, representationElementIndex = 0, codeElementIndex = 0, aliasElementIndex = 0, typeElementIndex = 0, exampleElementIndex = 0, conditionElementIndex = 0, constraintElementIndex = 0, valueAlternativesElementIndex = 0, mappingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "representation":
                    position = checkElementOrder("representation", 3, position, true);
                    builder.representation((PropertyRepresentation) parseString(PropertyRepresentation.builder(), "representation", reader, representationElementIndex++));
                    break;
                case "sliceName":
                    position = checkElementOrder("sliceName", 4, position, false);
                    builder.sliceName(parseString("sliceName", reader, -1));
                    break;
                case "sliceIsConstraining":
                    position = checkElementOrder("sliceIsConstraining", 5, position, false);
                    builder.sliceIsConstraining(parseBoolean("sliceIsConstraining", reader, -1));
                    break;
                case "label":
                    position = checkElementOrder("label", 6, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 7, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                case "slicing":
                    position = checkElementOrder("slicing", 8, position, false);
                    builder.slicing(parseElementDefinitionSlicing("slicing", reader, -1));
                    break;
                case "short":
                    position = checkElementOrder("short", 9, position, false);
                    builder._short(parseString("short", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 10, position, false);
                    builder.definition((Markdown) parseString(Markdown.builder(), "definition", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 11, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                case "requirements":
                    position = checkElementOrder("requirements", 12, position, false);
                    builder.requirements((Markdown) parseString(Markdown.builder(), "requirements", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 13, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "min":
                    position = checkElementOrder("min", 14, position, false);
                    builder.min((UnsignedInt) parseInteger(UnsignedInt.builder(), "min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 15, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 16, position, false);
                    builder.base(parseElementDefinitionBase("base", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("contentReference", 17, position, false);
                    builder.contentReference(parseUri("contentReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 18, position, true);
                    builder.type(parseElementDefinitionType("type", reader, typeElementIndex++));
                    break;
                case "defaultValueBase64Binary":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseBase64Binary("defaultValueBase64Binary", reader, -1));
                    break;
                case "defaultValueBoolean":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseBoolean("defaultValueBoolean", reader, -1));
                    break;
                case "defaultValueCanonical":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Canonical) parseUri(Canonical.builder(), "defaultValueCanonical", reader, -1));
                    break;
                case "defaultValueCode":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Code) parseString(Code.builder(), "defaultValueCode", reader, -1));
                    break;
                case "defaultValueDate":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDate("defaultValueDate", reader, -1));
                    break;
                case "defaultValueDateTime":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDateTime("defaultValueDateTime", reader, -1));
                    break;
                case "defaultValueDecimal":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDecimal("defaultValueDecimal", reader, -1));
                    break;
                case "defaultValueId":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Id) parseString(Id.builder(), "defaultValueId", reader, -1));
                    break;
                case "defaultValueInstant":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseInstant("defaultValueInstant", reader, -1));
                    break;
                case "defaultValueInteger":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseInteger("defaultValueInteger", reader, -1));
                    break;
                case "defaultValueInteger64":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseInteger64("defaultValueInteger64", reader, -1));
                    break;
                case "defaultValueMarkdown":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Markdown) parseString(Markdown.builder(), "defaultValueMarkdown", reader, -1));
                    break;
                case "defaultValueOid":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Oid) parseUri(Oid.builder(), "defaultValueOid", reader, -1));
                    break;
                case "defaultValuePositiveInt":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((PositiveInt) parseInteger(PositiveInt.builder(), "defaultValuePositiveInt", reader, -1));
                    break;
                case "defaultValueString":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseString("defaultValueString", reader, -1));
                    break;
                case "defaultValueTime":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseTime("defaultValueTime", reader, -1));
                    break;
                case "defaultValueUnsignedInt":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((UnsignedInt) parseInteger(UnsignedInt.builder(), "defaultValueUnsignedInt", reader, -1));
                    break;
                case "defaultValueUri":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseUri("defaultValueUri", reader, -1));
                    break;
                case "defaultValueUrl":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Url) parseUri(Url.builder(), "defaultValueUrl", reader, -1));
                    break;
                case "defaultValueUuid":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Uuid) parseUri(Uuid.builder(), "defaultValueUuid", reader, -1));
                    break;
                case "defaultValueAddress":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseAddress("defaultValueAddress", reader, -1));
                    break;
                case "defaultValueAge":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Age) parseQuantity(Age.builder(), "defaultValueAge", reader, -1));
                    break;
                case "defaultValueAnnotation":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseAnnotation("defaultValueAnnotation", reader, -1));
                    break;
                case "defaultValueAttachment":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseAttachment("defaultValueAttachment", reader, -1));
                    break;
                case "defaultValueCodeableConcept":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseCodeableConcept("defaultValueCodeableConcept", reader, -1));
                    break;
                case "defaultValueCodeableReference":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseCodeableReference("defaultValueCodeableReference", reader, -1));
                    break;
                case "defaultValueCoding":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseCoding("defaultValueCoding", reader, -1));
                    break;
                case "defaultValueContactPoint":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseContactPoint("defaultValueContactPoint", reader, -1));
                    break;
                case "defaultValueCount":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Count) parseQuantity(Count.builder(), "defaultValueCount", reader, -1));
                    break;
                case "defaultValueDistance":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Distance) parseQuantity(Distance.builder(), "defaultValueDistance", reader, -1));
                    break;
                case "defaultValueDuration":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Duration) parseQuantity(Duration.builder(), "defaultValueDuration", reader, -1));
                    break;
                case "defaultValueHumanName":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseHumanName("defaultValueHumanName", reader, -1));
                    break;
                case "defaultValueIdentifier":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseIdentifier("defaultValueIdentifier", reader, -1));
                    break;
                case "defaultValueMoney":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseMoney("defaultValueMoney", reader, -1));
                    break;
                case "defaultValuePeriod":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parsePeriod("defaultValuePeriod", reader, -1));
                    break;
                case "defaultValueQuantity":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseQuantity("defaultValueQuantity", reader, -1));
                    break;
                case "defaultValueRange":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseRange("defaultValueRange", reader, -1));
                    break;
                case "defaultValueRatio":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseRatio("defaultValueRatio", reader, -1));
                    break;
                case "defaultValueRatioRange":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseRatioRange("defaultValueRatioRange", reader, -1));
                    break;
                case "defaultValueReference":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseReference("defaultValueReference", reader, -1));
                    break;
                case "defaultValueSampledData":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseSampledData("defaultValueSampledData", reader, -1));
                    break;
                case "defaultValueSignature":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseSignature("defaultValueSignature", reader, -1));
                    break;
                case "defaultValueTiming":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseTiming("defaultValueTiming", reader, -1));
                    break;
                case "defaultValueContactDetail":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseContactDetail("defaultValueContactDetail", reader, -1));
                    break;
                case "defaultValueDataRequirement":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDataRequirement("defaultValueDataRequirement", reader, -1));
                    break;
                case "defaultValueExpression":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseExpression("defaultValueExpression", reader, -1));
                    break;
                case "defaultValueParameterDefinition":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseParameterDefinition("defaultValueParameterDefinition", reader, -1));
                    break;
                case "defaultValueRelatedArtifact":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseRelatedArtifact("defaultValueRelatedArtifact", reader, -1));
                    break;
                case "defaultValueTriggerDefinition":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseTriggerDefinition("defaultValueTriggerDefinition", reader, -1));
                    break;
                case "defaultValueUsageContext":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseUsageContext("defaultValueUsageContext", reader, -1));
                    break;
                case "defaultValueAvailability":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseAvailability("defaultValueAvailability", reader, -1));
                    break;
                case "defaultValueExtendedContactDetail":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseExtendedContactDetail("defaultValueExtendedContactDetail", reader, -1));
                    break;
                case "defaultValueDosage":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDosage("defaultValueDosage", reader, -1));
                    break;
                case "defaultValueMeta":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseMeta("defaultValueMeta", reader, -1));
                    break;
                case "meaningWhenMissing":
                    position = checkElementOrder("meaningWhenMissing", 20, position, false);
                    builder.meaningWhenMissing((Markdown) parseString(Markdown.builder(), "meaningWhenMissing", reader, -1));
                    break;
                case "orderMeaning":
                    position = checkElementOrder("orderMeaning", 21, position, false);
                    builder.orderMeaning(parseString("orderMeaning", reader, -1));
                    break;
                case "fixedBase64Binary":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseBase64Binary("fixedBase64Binary", reader, -1));
                    break;
                case "fixedBoolean":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseBoolean("fixedBoolean", reader, -1));
                    break;
                case "fixedCanonical":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Canonical) parseUri(Canonical.builder(), "fixedCanonical", reader, -1));
                    break;
                case "fixedCode":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Code) parseString(Code.builder(), "fixedCode", reader, -1));
                    break;
                case "fixedDate":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDate("fixedDate", reader, -1));
                    break;
                case "fixedDateTime":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDateTime("fixedDateTime", reader, -1));
                    break;
                case "fixedDecimal":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDecimal("fixedDecimal", reader, -1));
                    break;
                case "fixedId":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Id) parseString(Id.builder(), "fixedId", reader, -1));
                    break;
                case "fixedInstant":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseInstant("fixedInstant", reader, -1));
                    break;
                case "fixedInteger":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseInteger("fixedInteger", reader, -1));
                    break;
                case "fixedInteger64":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseInteger64("fixedInteger64", reader, -1));
                    break;
                case "fixedMarkdown":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Markdown) parseString(Markdown.builder(), "fixedMarkdown", reader, -1));
                    break;
                case "fixedOid":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Oid) parseUri(Oid.builder(), "fixedOid", reader, -1));
                    break;
                case "fixedPositiveInt":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((PositiveInt) parseInteger(PositiveInt.builder(), "fixedPositiveInt", reader, -1));
                    break;
                case "fixedString":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseString("fixedString", reader, -1));
                    break;
                case "fixedTime":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseTime("fixedTime", reader, -1));
                    break;
                case "fixedUnsignedInt":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((UnsignedInt) parseInteger(UnsignedInt.builder(), "fixedUnsignedInt", reader, -1));
                    break;
                case "fixedUri":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseUri("fixedUri", reader, -1));
                    break;
                case "fixedUrl":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Url) parseUri(Url.builder(), "fixedUrl", reader, -1));
                    break;
                case "fixedUuid":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Uuid) parseUri(Uuid.builder(), "fixedUuid", reader, -1));
                    break;
                case "fixedAddress":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseAddress("fixedAddress", reader, -1));
                    break;
                case "fixedAge":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Age) parseQuantity(Age.builder(), "fixedAge", reader, -1));
                    break;
                case "fixedAnnotation":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseAnnotation("fixedAnnotation", reader, -1));
                    break;
                case "fixedAttachment":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseAttachment("fixedAttachment", reader, -1));
                    break;
                case "fixedCodeableConcept":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseCodeableConcept("fixedCodeableConcept", reader, -1));
                    break;
                case "fixedCodeableReference":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseCodeableReference("fixedCodeableReference", reader, -1));
                    break;
                case "fixedCoding":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseCoding("fixedCoding", reader, -1));
                    break;
                case "fixedContactPoint":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseContactPoint("fixedContactPoint", reader, -1));
                    break;
                case "fixedCount":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Count) parseQuantity(Count.builder(), "fixedCount", reader, -1));
                    break;
                case "fixedDistance":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Distance) parseQuantity(Distance.builder(), "fixedDistance", reader, -1));
                    break;
                case "fixedDuration":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Duration) parseQuantity(Duration.builder(), "fixedDuration", reader, -1));
                    break;
                case "fixedHumanName":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseHumanName("fixedHumanName", reader, -1));
                    break;
                case "fixedIdentifier":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseIdentifier("fixedIdentifier", reader, -1));
                    break;
                case "fixedMoney":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseMoney("fixedMoney", reader, -1));
                    break;
                case "fixedPeriod":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parsePeriod("fixedPeriod", reader, -1));
                    break;
                case "fixedQuantity":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseQuantity("fixedQuantity", reader, -1));
                    break;
                case "fixedRange":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseRange("fixedRange", reader, -1));
                    break;
                case "fixedRatio":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseRatio("fixedRatio", reader, -1));
                    break;
                case "fixedRatioRange":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseRatioRange("fixedRatioRange", reader, -1));
                    break;
                case "fixedReference":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseReference("fixedReference", reader, -1));
                    break;
                case "fixedSampledData":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseSampledData("fixedSampledData", reader, -1));
                    break;
                case "fixedSignature":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseSignature("fixedSignature", reader, -1));
                    break;
                case "fixedTiming":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseTiming("fixedTiming", reader, -1));
                    break;
                case "fixedContactDetail":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseContactDetail("fixedContactDetail", reader, -1));
                    break;
                case "fixedDataRequirement":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDataRequirement("fixedDataRequirement", reader, -1));
                    break;
                case "fixedExpression":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseExpression("fixedExpression", reader, -1));
                    break;
                case "fixedParameterDefinition":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseParameterDefinition("fixedParameterDefinition", reader, -1));
                    break;
                case "fixedRelatedArtifact":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseRelatedArtifact("fixedRelatedArtifact", reader, -1));
                    break;
                case "fixedTriggerDefinition":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseTriggerDefinition("fixedTriggerDefinition", reader, -1));
                    break;
                case "fixedUsageContext":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseUsageContext("fixedUsageContext", reader, -1));
                    break;
                case "fixedAvailability":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseAvailability("fixedAvailability", reader, -1));
                    break;
                case "fixedExtendedContactDetail":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseExtendedContactDetail("fixedExtendedContactDetail", reader, -1));
                    break;
                case "fixedDosage":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDosage("fixedDosage", reader, -1));
                    break;
                case "fixedMeta":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseMeta("fixedMeta", reader, -1));
                    break;
                case "patternBase64Binary":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseBase64Binary("patternBase64Binary", reader, -1));
                    break;
                case "patternBoolean":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseBoolean("patternBoolean", reader, -1));
                    break;
                case "patternCanonical":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Canonical) parseUri(Canonical.builder(), "patternCanonical", reader, -1));
                    break;
                case "patternCode":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Code) parseString(Code.builder(), "patternCode", reader, -1));
                    break;
                case "patternDate":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDate("patternDate", reader, -1));
                    break;
                case "patternDateTime":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDateTime("patternDateTime", reader, -1));
                    break;
                case "patternDecimal":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDecimal("patternDecimal", reader, -1));
                    break;
                case "patternId":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Id) parseString(Id.builder(), "patternId", reader, -1));
                    break;
                case "patternInstant":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseInstant("patternInstant", reader, -1));
                    break;
                case "patternInteger":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseInteger("patternInteger", reader, -1));
                    break;
                case "patternInteger64":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseInteger64("patternInteger64", reader, -1));
                    break;
                case "patternMarkdown":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Markdown) parseString(Markdown.builder(), "patternMarkdown", reader, -1));
                    break;
                case "patternOid":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Oid) parseUri(Oid.builder(), "patternOid", reader, -1));
                    break;
                case "patternPositiveInt":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((PositiveInt) parseInteger(PositiveInt.builder(), "patternPositiveInt", reader, -1));
                    break;
                case "patternString":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseString("patternString", reader, -1));
                    break;
                case "patternTime":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseTime("patternTime", reader, -1));
                    break;
                case "patternUnsignedInt":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((UnsignedInt) parseInteger(UnsignedInt.builder(), "patternUnsignedInt", reader, -1));
                    break;
                case "patternUri":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseUri("patternUri", reader, -1));
                    break;
                case "patternUrl":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Url) parseUri(Url.builder(), "patternUrl", reader, -1));
                    break;
                case "patternUuid":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Uuid) parseUri(Uuid.builder(), "patternUuid", reader, -1));
                    break;
                case "patternAddress":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseAddress("patternAddress", reader, -1));
                    break;
                case "patternAge":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Age) parseQuantity(Age.builder(), "patternAge", reader, -1));
                    break;
                case "patternAnnotation":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseAnnotation("patternAnnotation", reader, -1));
                    break;
                case "patternAttachment":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseAttachment("patternAttachment", reader, -1));
                    break;
                case "patternCodeableConcept":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseCodeableConcept("patternCodeableConcept", reader, -1));
                    break;
                case "patternCodeableReference":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseCodeableReference("patternCodeableReference", reader, -1));
                    break;
                case "patternCoding":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseCoding("patternCoding", reader, -1));
                    break;
                case "patternContactPoint":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseContactPoint("patternContactPoint", reader, -1));
                    break;
                case "patternCount":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Count) parseQuantity(Count.builder(), "patternCount", reader, -1));
                    break;
                case "patternDistance":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Distance) parseQuantity(Distance.builder(), "patternDistance", reader, -1));
                    break;
                case "patternDuration":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Duration) parseQuantity(Duration.builder(), "patternDuration", reader, -1));
                    break;
                case "patternHumanName":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseHumanName("patternHumanName", reader, -1));
                    break;
                case "patternIdentifier":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseIdentifier("patternIdentifier", reader, -1));
                    break;
                case "patternMoney":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseMoney("patternMoney", reader, -1));
                    break;
                case "patternPeriod":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parsePeriod("patternPeriod", reader, -1));
                    break;
                case "patternQuantity":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseQuantity("patternQuantity", reader, -1));
                    break;
                case "patternRange":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseRange("patternRange", reader, -1));
                    break;
                case "patternRatio":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseRatio("patternRatio", reader, -1));
                    break;
                case "patternRatioRange":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseRatioRange("patternRatioRange", reader, -1));
                    break;
                case "patternReference":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseReference("patternReference", reader, -1));
                    break;
                case "patternSampledData":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseSampledData("patternSampledData", reader, -1));
                    break;
                case "patternSignature":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseSignature("patternSignature", reader, -1));
                    break;
                case "patternTiming":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseTiming("patternTiming", reader, -1));
                    break;
                case "patternContactDetail":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseContactDetail("patternContactDetail", reader, -1));
                    break;
                case "patternDataRequirement":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDataRequirement("patternDataRequirement", reader, -1));
                    break;
                case "patternExpression":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseExpression("patternExpression", reader, -1));
                    break;
                case "patternParameterDefinition":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseParameterDefinition("patternParameterDefinition", reader, -1));
                    break;
                case "patternRelatedArtifact":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseRelatedArtifact("patternRelatedArtifact", reader, -1));
                    break;
                case "patternTriggerDefinition":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseTriggerDefinition("patternTriggerDefinition", reader, -1));
                    break;
                case "patternUsageContext":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseUsageContext("patternUsageContext", reader, -1));
                    break;
                case "patternAvailability":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseAvailability("patternAvailability", reader, -1));
                    break;
                case "patternExtendedContactDetail":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseExtendedContactDetail("patternExtendedContactDetail", reader, -1));
                    break;
                case "patternDosage":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDosage("patternDosage", reader, -1));
                    break;
                case "patternMeta":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseMeta("patternMeta", reader, -1));
                    break;
                case "example":
                    position = checkElementOrder("example", 24, position, true);
                    builder.example(parseElementDefinitionExample("example", reader, exampleElementIndex++));
                    break;
                case "minValueDate":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseDate("minValueDate", reader, -1));
                    break;
                case "minValueDateTime":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseDateTime("minValueDateTime", reader, -1));
                    break;
                case "minValueInstant":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseInstant("minValueInstant", reader, -1));
                    break;
                case "minValueTime":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseTime("minValueTime", reader, -1));
                    break;
                case "minValueDecimal":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseDecimal("minValueDecimal", reader, -1));
                    break;
                case "minValueInteger":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseInteger("minValueInteger", reader, -1));
                    break;
                case "minValueInteger64":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseInteger64("minValueInteger64", reader, -1));
                    break;
                case "minValuePositiveInt":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue((PositiveInt) parseInteger(PositiveInt.builder(), "minValuePositiveInt", reader, -1));
                    break;
                case "minValueUnsignedInt":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue((UnsignedInt) parseInteger(UnsignedInt.builder(), "minValueUnsignedInt", reader, -1));
                    break;
                case "minValueQuantity":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseQuantity("minValueQuantity", reader, -1));
                    break;
                case "maxValueDate":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseDate("maxValueDate", reader, -1));
                    break;
                case "maxValueDateTime":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseDateTime("maxValueDateTime", reader, -1));
                    break;
                case "maxValueInstant":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseInstant("maxValueInstant", reader, -1));
                    break;
                case "maxValueTime":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseTime("maxValueTime", reader, -1));
                    break;
                case "maxValueDecimal":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseDecimal("maxValueDecimal", reader, -1));
                    break;
                case "maxValueInteger":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseInteger("maxValueInteger", reader, -1));
                    break;
                case "maxValueInteger64":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseInteger64("maxValueInteger64", reader, -1));
                    break;
                case "maxValuePositiveInt":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue((PositiveInt) parseInteger(PositiveInt.builder(), "maxValuePositiveInt", reader, -1));
                    break;
                case "maxValueUnsignedInt":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue((UnsignedInt) parseInteger(UnsignedInt.builder(), "maxValueUnsignedInt", reader, -1));
                    break;
                case "maxValueQuantity":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseQuantity("maxValueQuantity", reader, -1));
                    break;
                case "maxLength":
                    position = checkElementOrder("maxLength", 27, position, false);
                    builder.maxLength(parseInteger("maxLength", reader, -1));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 28, position, true);
                    builder.condition((Id) parseString(Id.builder(), "condition", reader, conditionElementIndex++));
                    break;
                case "constraint":
                    position = checkElementOrder("constraint", 29, position, true);
                    builder.constraint(parseElementDefinitionConstraint("constraint", reader, constraintElementIndex++));
                    break;
                case "mustHaveValue":
                    position = checkElementOrder("mustHaveValue", 30, position, false);
                    builder.mustHaveValue(parseBoolean("mustHaveValue", reader, -1));
                    break;
                case "valueAlternatives":
                    position = checkElementOrder("valueAlternatives", 31, position, true);
                    builder.valueAlternatives((Canonical) parseUri(Canonical.builder(), "valueAlternatives", reader, valueAlternativesElementIndex++));
                    break;
                case "mustSupport":
                    position = checkElementOrder("mustSupport", 32, position, false);
                    builder.mustSupport(parseBoolean("mustSupport", reader, -1));
                    break;
                case "isModifier":
                    position = checkElementOrder("isModifier", 33, position, false);
                    builder.isModifier(parseBoolean("isModifier", reader, -1));
                    break;
                case "isModifierReason":
                    position = checkElementOrder("isModifierReason", 34, position, false);
                    builder.isModifierReason(parseString("isModifierReason", reader, -1));
                    break;
                case "isSummary":
                    position = checkElementOrder("isSummary", 35, position, false);
                    builder.isSummary(parseBoolean("isSummary", reader, -1));
                    break;
                case "binding":
                    position = checkElementOrder("binding", 36, position, false);
                    builder.binding(parseElementDefinitionBinding("binding", reader, -1));
                    break;
                case "mapping":
                    position = checkElementOrder("mapping", 37, position, true);
                    builder.mapping(parseElementDefinitionMapping("mapping", reader, mappingElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Base parseElementDefinitionBase(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Base.Builder builder = ElementDefinition.Base.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 3, position, false);
                    builder.min((UnsignedInt) parseInteger(UnsignedInt.builder(), "min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 4, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Binding parseElementDefinitionBinding(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Binding.Builder builder = ElementDefinition.Binding.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additionalElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "strength":
                    position = checkElementOrder("strength", 2, position, false);
                    builder.strength((BindingStrength) parseString(BindingStrength.builder(), "strength", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 4, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                case "additional":
                    position = checkElementOrder("additional", 5, position, true);
                    builder.additional(parseElement("additional", reader, additionalElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Constraint parseElementDefinitionConstraint(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Constraint.Builder builder = ElementDefinition.Constraint.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "key":
                    position = checkElementOrder("key", 2, position, false);
                    builder.key((Id) parseString(Id.builder(), "key", reader, -1));
                    break;
                case "requirements":
                    position = checkElementOrder("requirements", 3, position, false);
                    builder.requirements((Markdown) parseString(Markdown.builder(), "requirements", reader, -1));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 4, position, false);
                    builder.severity((ConstraintSeverity) parseString(ConstraintSeverity.builder(), "severity", reader, -1));
                    break;
                case "suppress":
                    position = checkElementOrder("suppress", 5, position, false);
                    builder.suppress(parseBoolean("suppress", reader, -1));
                    break;
                case "human":
                    position = checkElementOrder("human", 6, position, false);
                    builder.human(parseString("human", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 7, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 8, position, false);
                    builder.source((Canonical) parseUri(Canonical.builder(), "source", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Example parseElementDefinitionExample(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Example.Builder builder = ElementDefinition.Example.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "label":
                    position = checkElementOrder("label", 2, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueInteger64":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger64("valueInteger64", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCodeableReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableReference("valueCodeableReference", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRatioRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatioRange("valueRatioRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueAvailability":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAvailability("valueAvailability", reader, -1));
                    break;
                case "valueExtendedContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExtendedContactDetail("valueExtendedContactDetail", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Mapping parseElementDefinitionMapping(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Mapping.Builder builder = ElementDefinition.Mapping.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identity":
                    position = checkElementOrder("identity", 2, position, false);
                    builder.identity((Id) parseString(Id.builder(), "identity", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "map":
                    position = checkElementOrder("map", 4, position, false);
                    builder.map(parseString("map", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 5, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Slicing parseElementDefinitionSlicing(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Slicing.Builder builder = ElementDefinition.Slicing.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, discriminatorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "discriminator":
                    position = checkElementOrder("discriminator", 2, position, true);
                    builder.discriminator(parseElementDefinitionSlicingDiscriminator("discriminator", reader, discriminatorElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "ordered":
                    position = checkElementOrder("ordered", 4, position, false);
                    builder.ordered(parseBoolean("ordered", reader, -1));
                    break;
                case "rules":
                    position = checkElementOrder("rules", 5, position, false);
                    builder.rules((SlicingRules) parseString(SlicingRules.builder(), "rules", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Slicing.Discriminator parseElementDefinitionSlicingDiscriminator(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Slicing.Discriminator.Builder builder = ElementDefinition.Slicing.Discriminator.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((DiscriminatorType) parseString(DiscriminatorType.builder(), "type", reader, -1));
                    break;
                case "path":
                    position = checkElementOrder("path", 3, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Type parseElementDefinitionType(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Type.Builder builder = ElementDefinition.Type.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, profileElementIndex = 0, targetProfileElementIndex = 0, aggregationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseUri("code", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, true);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, profileElementIndex++));
                    break;
                case "targetProfile":
                    position = checkElementOrder("targetProfile", 4, position, true);
                    builder.targetProfile((Canonical) parseUri(Canonical.builder(), "targetProfile", reader, targetProfileElementIndex++));
                    break;
                case "aggregation":
                    position = checkElementOrder("aggregation", 5, position, true);
                    builder.aggregation((AggregationMode) parseString(AggregationMode.builder(), "aggregation", reader, aggregationElementIndex++));
                    break;
                case "versioning":
                    position = checkElementOrder("versioning", 6, position, false);
                    builder.versioning((ReferenceVersionRules) parseString(ReferenceVersionRules.builder(), "versioning", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter parseEncounter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Builder builder = Encounter.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, classElementIndex = 0, typeElementIndex = 0, serviceTypeElementIndex = 0, episodeOfCareElementIndex = 0, basedOnElementIndex = 0, careTeamElementIndex = 0, participantElementIndex = 0, appointmentElementIndex = 0, virtualServiceElementIndex = 0, reasonElementIndex = 0, diagnosisElementIndex = 0, accountElementIndex = 0, dietPreferenceElementIndex = 0, specialArrangementElementIndex = 0, specialCourtesyElementIndex = 0, locationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EncounterStatus) parseString(EncounterStatus.builder(), "status", reader, -1));
                    break;
                case "class":
                    position = checkElementOrder("class", 10, position, true);
                    builder.clazz(parseCodeableConcept("class", reader, classElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 11, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 12, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "serviceType":
                    position = checkElementOrder("serviceType", 13, position, true);
                    builder.serviceType(parseCodeableReference("serviceType", reader, serviceTypeElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "subjectStatus":
                    position = checkElementOrder("subjectStatus", 15, position, false);
                    builder.subjectStatus(parseCodeableConcept("subjectStatus", reader, -1));
                    break;
                case "episodeOfCare":
                    position = checkElementOrder("episodeOfCare", 16, position, true);
                    builder.episodeOfCare(parseReference("episodeOfCare", reader, episodeOfCareElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 17, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "careTeam":
                    position = checkElementOrder("careTeam", 18, position, true);
                    builder.careTeam(parseReference("careTeam", reader, careTeamElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 19, position, false);
                    builder.partOf(parseReference("partOf", reader, -1));
                    break;
                case "serviceProvider":
                    position = checkElementOrder("serviceProvider", 20, position, false);
                    builder.serviceProvider(parseReference("serviceProvider", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 21, position, true);
                    builder.participant(parseEncounterParticipant("participant", reader, participantElementIndex++));
                    break;
                case "appointment":
                    position = checkElementOrder("appointment", 22, position, true);
                    builder.appointment(parseReference("appointment", reader, appointmentElementIndex++));
                    break;
                case "virtualService":
                    position = checkElementOrder("virtualService", 23, position, true);
                    builder.virtualService(parseVirtualServiceDetail("virtualService", reader, virtualServiceElementIndex++));
                    break;
                case "actualPeriod":
                    position = checkElementOrder("actualPeriod", 24, position, false);
                    builder.actualPeriod(parsePeriod("actualPeriod", reader, -1));
                    break;
                case "plannedStartDate":
                    position = checkElementOrder("plannedStartDate", 25, position, false);
                    builder.plannedStartDate(parseDateTime("plannedStartDate", reader, -1));
                    break;
                case "plannedEndDate":
                    position = checkElementOrder("plannedEndDate", 26, position, false);
                    builder.plannedEndDate(parseDateTime("plannedEndDate", reader, -1));
                    break;
                case "length":
                    position = checkElementOrder("length", 27, position, false);
                    builder.length((Duration) parseQuantity(Duration.builder(), "length", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 28, position, true);
                    builder.reason(parseEncounterReason("reason", reader, reasonElementIndex++));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 29, position, true);
                    builder.diagnosis(parseEncounterDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "account":
                    position = checkElementOrder("account", 30, position, true);
                    builder.account(parseReference("account", reader, accountElementIndex++));
                    break;
                case "dietPreference":
                    position = checkElementOrder("dietPreference", 31, position, true);
                    builder.dietPreference(parseCodeableConcept("dietPreference", reader, dietPreferenceElementIndex++));
                    break;
                case "specialArrangement":
                    position = checkElementOrder("specialArrangement", 32, position, true);
                    builder.specialArrangement(parseCodeableConcept("specialArrangement", reader, specialArrangementElementIndex++));
                    break;
                case "specialCourtesy":
                    position = checkElementOrder("specialCourtesy", 33, position, true);
                    builder.specialCourtesy(parseCodeableConcept("specialCourtesy", reader, specialCourtesyElementIndex++));
                    break;
                case "admission":
                    position = checkElementOrder("admission", 34, position, false);
                    builder.admission(parseEncounterAdmission("admission", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 35, position, true);
                    builder.location(parseEncounterLocation("location", reader, locationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.Admission parseEncounterAdmission(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Admission.Builder builder = Encounter.Admission.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "preAdmissionIdentifier":
                    position = checkElementOrder("preAdmissionIdentifier", 2, position, false);
                    builder.preAdmissionIdentifier(parseIdentifier("preAdmissionIdentifier", reader, -1));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 3, position, false);
                    builder.origin(parseReference("origin", reader, -1));
                    break;
                case "admitSource":
                    position = checkElementOrder("admitSource", 4, position, false);
                    builder.admitSource(parseCodeableConcept("admitSource", reader, -1));
                    break;
                case "reAdmission":
                    position = checkElementOrder("reAdmission", 5, position, false);
                    builder.reAdmission(parseCodeableConcept("reAdmission", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 6, position, false);
                    builder.destination(parseReference("destination", reader, -1));
                    break;
                case "dischargeDisposition":
                    position = checkElementOrder("dischargeDisposition", 7, position, false);
                    builder.dischargeDisposition(parseCodeableConcept("dischargeDisposition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.Diagnosis parseEncounterDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Diagnosis.Builder builder = Encounter.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, conditionElementIndex = 0, useElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 2, position, true);
                    builder.condition(parseCodeableReference("condition", reader, conditionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, true);
                    builder.use(parseCodeableConcept("use", reader, useElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.Location parseEncounterLocation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Location.Builder builder = Encounter.Location.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 2, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 3, position, false);
                    builder.status((EncounterLocationStatus) parseString(EncounterLocationStatus.builder(), "status", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 4, position, false);
                    builder.form(parseCodeableConcept("form", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.Participant parseEncounterParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Participant.Builder builder = Encounter.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 4, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.Reason parseEncounterReason(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Reason.Builder builder = Encounter.Reason.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, useElementIndex = 0, valueElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 2, position, true);
                    builder.use(parseCodeableConcept("use", reader, useElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, true);
                    builder.value(parseCodeableReference("value", reader, valueElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EncounterHistory parseEncounterHistory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EncounterHistory.Builder builder = EncounterHistory.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, typeElementIndex = 0, serviceTypeElementIndex = 0, locationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 8, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((EncounterStatus) parseString(EncounterStatus.builder(), "status", reader, -1));
                    break;
                case "class":
                    position = checkElementOrder("class", 11, position, false);
                    builder.clazz(parseCodeableConcept("class", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 12, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "serviceType":
                    position = checkElementOrder("serviceType", 13, position, true);
                    builder.serviceType(parseCodeableReference("serviceType", reader, serviceTypeElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "subjectStatus":
                    position = checkElementOrder("subjectStatus", 15, position, false);
                    builder.subjectStatus(parseCodeableConcept("subjectStatus", reader, -1));
                    break;
                case "actualPeriod":
                    position = checkElementOrder("actualPeriod", 16, position, false);
                    builder.actualPeriod(parsePeriod("actualPeriod", reader, -1));
                    break;
                case "plannedStartDate":
                    position = checkElementOrder("plannedStartDate", 17, position, false);
                    builder.plannedStartDate(parseDateTime("plannedStartDate", reader, -1));
                    break;
                case "plannedEndDate":
                    position = checkElementOrder("plannedEndDate", 18, position, false);
                    builder.plannedEndDate(parseDateTime("plannedEndDate", reader, -1));
                    break;
                case "length":
                    position = checkElementOrder("length", 19, position, false);
                    builder.length((Duration) parseQuantity(Duration.builder(), "length", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 20, position, true);
                    builder.location(parseEncounterHistoryLocation("location", reader, locationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EncounterHistory.Location parseEncounterHistoryLocation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EncounterHistory.Location.Builder builder = EncounterHistory.Location.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 2, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 3, position, false);
                    builder.form(parseCodeableConcept("form", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Endpoint parseEndpoint(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Endpoint.Builder builder = Endpoint.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, connectionTypeElementIndex = 0, environmentTypeElementIndex = 0, contactElementIndex = 0, payloadElementIndex = 0, headerElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EndpointStatus) parseString(EndpointStatus.builder(), "status", reader, -1));
                    break;
                case "connectionType":
                    position = checkElementOrder("connectionType", 10, position, true);
                    builder.connectionType(parseCodeableConcept("connectionType", reader, connectionTypeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 12, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "environmentType":
                    position = checkElementOrder("environmentType", 13, position, true);
                    builder.environmentType(parseCodeableConcept("environmentType", reader, environmentTypeElementIndex++));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 14, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 15, position, true);
                    builder.contact(parseContactPoint("contact", reader, contactElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 16, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "payload":
                    position = checkElementOrder("payload", 17, position, true);
                    builder.payload(parseEndpointPayload("payload", reader, payloadElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 18, position, false);
                    builder.address((Url) parseUri(Url.builder(), "address", reader, -1));
                    break;
                case "header":
                    position = checkElementOrder("header", 19, position, true);
                    builder.header(parseString("header", reader, headerElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Endpoint.Payload parseEndpointPayload(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Endpoint.Payload.Builder builder = Endpoint.Payload.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, mimeTypeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "mimeType":
                    position = checkElementOrder("mimeType", 3, position, true);
                    builder.mimeType((Code) parseString(Code.builder(), "mimeType", reader, mimeTypeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EnrollmentRequest parseEnrollmentRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EnrollmentRequest.Builder builder = EnrollmentRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EnrollmentRequestStatus) parseString(EnrollmentRequestStatus.builder(), "status", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 10, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 11, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 12, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "candidate":
                    position = checkElementOrder("candidate", 13, position, false);
                    builder.candidate(parseReference("candidate", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 14, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EnrollmentResponse parseEnrollmentResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EnrollmentResponse.Builder builder = EnrollmentResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EnrollmentResponseStatus) parseString(EnrollmentResponseStatus.builder(), "status", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 10, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 11, position, false);
                    builder.outcome((EnrollmentOutcome) parseString(EnrollmentOutcome.builder(), "outcome", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 12, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 13, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 14, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "requestProvider":
                    position = checkElementOrder("requestProvider", 15, position, false);
                    builder.requestProvider(parseReference("requestProvider", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EpisodeOfCare parseEpisodeOfCare(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EpisodeOfCare.Builder builder = EpisodeOfCare.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, statusHistoryElementIndex = 0, typeElementIndex = 0, reasonElementIndex = 0, diagnosisElementIndex = 0, referralRequestElementIndex = 0, careTeamElementIndex = 0, accountElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EpisodeOfCareStatus) parseString(EpisodeOfCareStatus.builder(), "status", reader, -1));
                    break;
                case "statusHistory":
                    position = checkElementOrder("statusHistory", 10, position, true);
                    builder.statusHistory(parseEpisodeOfCareStatusHistory("statusHistory", reader, statusHistoryElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 12, position, true);
                    builder.reason(parseEpisodeOfCareReason("reason", reader, reasonElementIndex++));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 13, position, true);
                    builder.diagnosis(parseEpisodeOfCareDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 14, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 15, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 16, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "referralRequest":
                    position = checkElementOrder("referralRequest", 17, position, true);
                    builder.referralRequest(parseReference("referralRequest", reader, referralRequestElementIndex++));
                    break;
                case "careManager":
                    position = checkElementOrder("careManager", 18, position, false);
                    builder.careManager(parseReference("careManager", reader, -1));
                    break;
                case "careTeam":
                    position = checkElementOrder("careTeam", 19, position, true);
                    builder.careTeam(parseReference("careTeam", reader, careTeamElementIndex++));
                    break;
                case "account":
                    position = checkElementOrder("account", 20, position, true);
                    builder.account(parseReference("account", reader, accountElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EpisodeOfCare.Diagnosis parseEpisodeOfCareDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EpisodeOfCare.Diagnosis.Builder builder = EpisodeOfCare.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, conditionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 2, position, true);
                    builder.condition(parseCodeableReference("condition", reader, conditionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use(parseCodeableConcept("use", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EpisodeOfCare.Reason parseEpisodeOfCareReason(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EpisodeOfCare.Reason.Builder builder = EpisodeOfCare.Reason.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, valueElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 2, position, false);
                    builder.use(parseCodeableConcept("use", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, true);
                    builder.value(parseCodeableReference("value", reader, valueElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EpisodeOfCare.StatusHistory parseEpisodeOfCareStatusHistory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EpisodeOfCare.StatusHistory.Builder builder = EpisodeOfCare.StatusHistory.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 2, position, false);
                    builder.status((EpisodeOfCareStatus) parseString(EpisodeOfCareStatus.builder(), "status", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EventDefinition parseEventDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EventDefinition.Builder builder = EventDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, triggerElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 14, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 18, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 19, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 20, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 21, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 22, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 23, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 24, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 25, position, false);
                    builder.usage((Markdown) parseString(Markdown.builder(), "usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 26, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 27, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 28, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 29, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 30, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 31, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 32, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 33, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 34, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 35, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 36, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "trigger":
                    position = checkElementOrder("trigger", 37, position, true);
                    builder.trigger(parseTriggerDefinition("trigger", reader, triggerElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence parseEvidence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Builder builder = Evidence.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, useContextElementIndex = 0, relatedArtifactElementIndex = 0, noteElementIndex = 0, variableDefinitionElementIndex = 0, studyDesignElementIndex = 0, statisticElementIndex = 0, certaintyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "citeAsReference":
                    position = checkElementOrder("citeAs[x]", 14, position, false);
                    builder.citeAs(parseReference("citeAsReference", reader, -1));
                    break;
                case "citeAsMarkdown":
                    position = checkElementOrder("citeAs[x]", 14, position, false);
                    builder.citeAs((Markdown) parseString(Markdown.builder(), "citeAsMarkdown", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 18, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 19, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 20, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 21, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 22, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 23, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 24, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 25, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 26, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 27, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 28, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 29, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 30, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 31, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "assertion":
                    position = checkElementOrder("assertion", 32, position, false);
                    builder.assertion((Markdown) parseString(Markdown.builder(), "assertion", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 33, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "variableDefinition":
                    position = checkElementOrder("variableDefinition", 34, position, true);
                    builder.variableDefinition(parseEvidenceVariableDefinition("variableDefinition", reader, variableDefinitionElementIndex++));
                    break;
                case "synthesisType":
                    position = checkElementOrder("synthesisType", 35, position, false);
                    builder.synthesisType(parseCodeableConcept("synthesisType", reader, -1));
                    break;
                case "studyDesign":
                    position = checkElementOrder("studyDesign", 36, position, true);
                    builder.studyDesign(parseCodeableConcept("studyDesign", reader, studyDesignElementIndex++));
                    break;
                case "statistic":
                    position = checkElementOrder("statistic", 37, position, true);
                    builder.statistic(parseEvidenceStatistic("statistic", reader, statisticElementIndex++));
                    break;
                case "certainty":
                    position = checkElementOrder("certainty", 38, position, true);
                    builder.certainty(parseEvidenceCertainty("certainty", reader, certaintyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Certainty parseEvidenceCertainty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Certainty.Builder builder = Evidence.Certainty.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, subcomponentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "rating":
                    position = checkElementOrder("rating", 5, position, false);
                    builder.rating(parseCodeableConcept("rating", reader, -1));
                    break;
                case "rater":
                    position = checkElementOrder("rater", 6, position, false);
                    builder.rater(parseString("rater", reader, -1));
                    break;
                case "subcomponent":
                    position = checkElementOrder("subcomponent", 7, position, true);
                    builder.subcomponent(parseEvidenceCertainty("subcomponent", reader, subcomponentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic parseEvidenceStatistic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.Builder builder = Evidence.Statistic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, attributeEstimateElementIndex = 0, modelCharacteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "statisticType":
                    position = checkElementOrder("statisticType", 4, position, false);
                    builder.statisticType(parseCodeableConcept("statisticType", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 5, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 6, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "numberOfEvents":
                    position = checkElementOrder("numberOfEvents", 7, position, false);
                    builder.numberOfEvents((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfEvents", reader, -1));
                    break;
                case "numberAffected":
                    position = checkElementOrder("numberAffected", 8, position, false);
                    builder.numberAffected((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberAffected", reader, -1));
                    break;
                case "sampleSize":
                    position = checkElementOrder("sampleSize", 9, position, false);
                    builder.sampleSize(parseEvidenceStatisticSampleSize("sampleSize", reader, -1));
                    break;
                case "attributeEstimate":
                    position = checkElementOrder("attributeEstimate", 10, position, true);
                    builder.attributeEstimate(parseEvidenceStatisticAttributeEstimate("attributeEstimate", reader, attributeEstimateElementIndex++));
                    break;
                case "modelCharacteristic":
                    position = checkElementOrder("modelCharacteristic", 11, position, true);
                    builder.modelCharacteristic(parseEvidenceStatisticModelCharacteristic("modelCharacteristic", reader, modelCharacteristicElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic.AttributeEstimate parseEvidenceStatisticAttributeEstimate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.AttributeEstimate.Builder builder = Evidence.Statistic.AttributeEstimate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, attributeEstimateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "level":
                    position = checkElementOrder("level", 6, position, false);
                    builder.level(parseDecimal("level", reader, -1));
                    break;
                case "range":
                    position = checkElementOrder("range", 7, position, false);
                    builder.range(parseRange("range", reader, -1));
                    break;
                case "attributeEstimate":
                    position = checkElementOrder("attributeEstimate", 8, position, true);
                    builder.attributeEstimate(parseEvidenceStatisticAttributeEstimate("attributeEstimate", reader, attributeEstimateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic.ModelCharacteristic parseEvidenceStatisticModelCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.ModelCharacteristic.Builder builder = Evidence.Statistic.ModelCharacteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, variableElementIndex = 0, attributeEstimateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "value", reader, -1));
                    break;
                case "variable":
                    position = checkElementOrder("variable", 4, position, true);
                    builder.variable(parseEvidenceStatisticModelCharacteristicVariable("variable", reader, variableElementIndex++));
                    break;
                case "attributeEstimate":
                    position = checkElementOrder("attributeEstimate", 5, position, true);
                    builder.attributeEstimate(parseEvidenceStatisticAttributeEstimate("attributeEstimate", reader, attributeEstimateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic.ModelCharacteristic.Variable parseEvidenceStatisticModelCharacteristicVariable(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.ModelCharacteristic.Variable.Builder builder = Evidence.Statistic.ModelCharacteristic.Variable.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, valueCategoryElementIndex = 0, valueQuantityElementIndex = 0, valueRangeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "variableDefinition":
                    position = checkElementOrder("variableDefinition", 2, position, false);
                    builder.variableDefinition(parseReference("variableDefinition", reader, -1));
                    break;
                case "handling":
                    position = checkElementOrder("handling", 3, position, false);
                    builder.handling((EvidenceVariableHandling) parseString(EvidenceVariableHandling.builder(), "handling", reader, -1));
                    break;
                case "valueCategory":
                    position = checkElementOrder("valueCategory", 4, position, true);
                    builder.valueCategory(parseCodeableConcept("valueCategory", reader, valueCategoryElementIndex++));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("valueQuantity", 5, position, true);
                    builder.valueQuantity(parseQuantity("valueQuantity", reader, valueQuantityElementIndex++));
                    break;
                case "valueRange":
                    position = checkElementOrder("valueRange", 6, position, true);
                    builder.valueRange(parseRange("valueRange", reader, valueRangeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic.SampleSize parseEvidenceStatisticSampleSize(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.SampleSize.Builder builder = Evidence.Statistic.SampleSize.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "numberOfStudies":
                    position = checkElementOrder("numberOfStudies", 4, position, false);
                    builder.numberOfStudies((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfStudies", reader, -1));
                    break;
                case "numberOfParticipants":
                    position = checkElementOrder("numberOfParticipants", 5, position, false);
                    builder.numberOfParticipants((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfParticipants", reader, -1));
                    break;
                case "knownDataCount":
                    position = checkElementOrder("knownDataCount", 6, position, false);
                    builder.knownDataCount((UnsignedInt) parseInteger(UnsignedInt.builder(), "knownDataCount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.VariableDefinition parseEvidenceVariableDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.VariableDefinition.Builder builder = Evidence.VariableDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "variableRole":
                    position = checkElementOrder("variableRole", 4, position, false);
                    builder.variableRole(parseCodeableConcept("variableRole", reader, -1));
                    break;
                case "observed":
                    position = checkElementOrder("observed", 5, position, false);
                    builder.observed(parseReference("observed", reader, -1));
                    break;
                case "intended":
                    position = checkElementOrder("intended", 6, position, false);
                    builder.intended(parseReference("intended", reader, -1));
                    break;
                case "directnessMatch":
                    position = checkElementOrder("directnessMatch", 7, position, false);
                    builder.directnessMatch(parseCodeableConcept("directnessMatch", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport parseEvidenceReport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.Builder builder = EvidenceReport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, useContextElementIndex = 0, identifierElementIndex = 0, relatedIdentifierElementIndex = 0, noteElementIndex = 0, relatedArtifactElementIndex = 0, contactElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatesToElementIndex = 0, sectionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 10, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 11, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "relatedIdentifier":
                    position = checkElementOrder("relatedIdentifier", 12, position, true);
                    builder.relatedIdentifier(parseIdentifier("relatedIdentifier", reader, relatedIdentifierElementIndex++));
                    break;
                case "citeAsReference":
                    position = checkElementOrder("citeAs[x]", 13, position, false);
                    builder.citeAs(parseReference("citeAsReference", reader, -1));
                    break;
                case "citeAsMarkdown":
                    position = checkElementOrder("citeAs[x]", 13, position, false);
                    builder.citeAs((Markdown) parseString(Markdown.builder(), "citeAsMarkdown", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 14, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 15, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 16, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 17, position, false);
                    builder.subject(parseEvidenceReportSubject("subject", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 20, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 21, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 22, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 23, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatesTo":
                    position = checkElementOrder("relatesTo", 24, position, true);
                    builder.relatesTo(parseEvidenceReportRelatesTo("relatesTo", reader, relatesToElementIndex++));
                    break;
                case "section":
                    position = checkElementOrder("section", 25, position, true);
                    builder.section(parseEvidenceReportSection("section", reader, sectionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport.RelatesTo parseEvidenceReportRelatesTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.RelatesTo.Builder builder = EvidenceReport.RelatesTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((ReportRelationshipType) parseString(ReportRelationshipType.builder(), "code", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 3, position, false);
                    builder.target(parseEvidenceReportRelatesToTarget("target", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport.RelatesTo.Target parseEvidenceReportRelatesToTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.RelatesTo.Target.Builder builder = EvidenceReport.RelatesTo.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 2, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display((Markdown) parseString(Markdown.builder(), "display", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 5, position, false);
                    builder.resource(parseReference("resource", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport.Section parseEvidenceReportSection(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.Section.Builder builder = EvidenceReport.Section.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, authorElementIndex = 0, entryClassifierElementIndex = 0, entryReferenceElementIndex = 0, entryQuantityElementIndex = 0, sectionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 3, position, false);
                    builder.focus(parseCodeableConcept("focus", reader, -1));
                    break;
                case "focusReference":
                    position = checkElementOrder("focusReference", 4, position, false);
                    builder.focusReference(parseReference("focusReference", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 5, position, true);
                    builder.author(parseReference("author", reader, authorElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 6, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 7, position, false);
                    builder.mode((SectionMode) parseString(SectionMode.builder(), "mode", reader, -1));
                    break;
                case "orderedBy":
                    position = checkElementOrder("orderedBy", 8, position, false);
                    builder.orderedBy(parseCodeableConcept("orderedBy", reader, -1));
                    break;
                case "entryClassifier":
                    position = checkElementOrder("entryClassifier", 9, position, true);
                    builder.entryClassifier(parseCodeableConcept("entryClassifier", reader, entryClassifierElementIndex++));
                    break;
                case "entryReference":
                    position = checkElementOrder("entryReference", 10, position, true);
                    builder.entryReference(parseReference("entryReference", reader, entryReferenceElementIndex++));
                    break;
                case "entryQuantity":
                    position = checkElementOrder("entryQuantity", 11, position, true);
                    builder.entryQuantity(parseQuantity("entryQuantity", reader, entryQuantityElementIndex++));
                    break;
                case "emptyReason":
                    position = checkElementOrder("emptyReason", 12, position, false);
                    builder.emptyReason(parseCodeableConcept("emptyReason", reader, -1));
                    break;
                case "section":
                    position = checkElementOrder("section", 13, position, true);
                    builder.section(parseEvidenceReportSection("section", reader, sectionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport.Subject parseEvidenceReportSubject(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.Subject.Builder builder = EvidenceReport.Subject.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, characteristicElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 2, position, true);
                    builder.characteristic(parseEvidenceReportSubjectCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport.Subject.Characteristic parseEvidenceReportSubjectCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.Subject.Characteristic.Builder builder = EvidenceReport.Subject.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "exclude":
                    position = checkElementOrder("exclude", 4, position, false);
                    builder.exclude(parseBoolean("exclude", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable parseEvidenceVariable(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Builder builder = EvidenceVariable.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, noteElementIndex = 0, useContextElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, characteristicElementIndex = 0, categoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "shortTitle":
                    position = checkElementOrder("shortTitle", 14, position, false);
                    builder.shortTitle(parseString("shortTitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 21, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 22, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 24, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 25, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 26, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 27, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 28, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 29, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 30, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 31, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 32, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 33, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "actual":
                    position = checkElementOrder("actual", 34, position, false);
                    builder.actual(parseBoolean("actual", reader, -1));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 35, position, true);
                    builder.characteristic(parseEvidenceVariableCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                case "handling":
                    position = checkElementOrder("handling", 36, position, false);
                    builder.handling((EvidenceVariableHandling) parseString(EvidenceVariableHandling.builder(), "handling", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 37, position, true);
                    builder.category(parseEvidenceVariableCategory("category", reader, categoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable.Category parseEvidenceVariableCategory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Category.Builder builder = EvidenceVariable.Category.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable.Characteristic parseEvidenceVariableCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Characteristic.Builder builder = EvidenceVariable.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, timeFromEventElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId((Id) parseString(Id.builder(), "linkId", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 4, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "exclude":
                    position = checkElementOrder("exclude", 5, position, false);
                    builder.exclude(parseBoolean("exclude", reader, -1));
                    break;
                case "definitionReference":
                    position = checkElementOrder("definitionReference", 6, position, false);
                    builder.definitionReference(parseReference("definitionReference", reader, -1));
                    break;
                case "definitionCanonical":
                    position = checkElementOrder("definitionCanonical", 7, position, false);
                    builder.definitionCanonical((Canonical) parseUri(Canonical.builder(), "definitionCanonical", reader, -1));
                    break;
                case "definitionCodeableConcept":
                    position = checkElementOrder("definitionCodeableConcept", 8, position, false);
                    builder.definitionCodeableConcept(parseCodeableConcept("definitionCodeableConcept", reader, -1));
                    break;
                case "definitionExpression":
                    position = checkElementOrder("definitionExpression", 9, position, false);
                    builder.definitionExpression(parseExpression("definitionExpression", reader, -1));
                    break;
                case "definitionId":
                    position = checkElementOrder("definitionId", 10, position, false);
                    builder.definitionId((Id) parseString(Id.builder(), "definitionId", reader, -1));
                    break;
                case "definitionByTypeAndValue":
                    position = checkElementOrder("definitionByTypeAndValue", 11, position, false);
                    builder.definitionByTypeAndValue(parseEvidenceVariableCharacteristicDefinitionByTypeAndValue("definitionByTypeAndValue", reader, -1));
                    break;
                case "definitionByCombination":
                    position = checkElementOrder("definitionByCombination", 12, position, false);
                    builder.definitionByCombination(parseEvidenceVariableCharacteristicDefinitionByCombination("definitionByCombination", reader, -1));
                    break;
                case "instancesQuantity":
                    position = checkElementOrder("instances[x]", 13, position, false);
                    builder.instances(parseQuantity("instancesQuantity", reader, -1));
                    break;
                case "instancesRange":
                    position = checkElementOrder("instances[x]", 13, position, false);
                    builder.instances(parseRange("instancesRange", reader, -1));
                    break;
                case "durationQuantity":
                    position = checkElementOrder("duration[x]", 14, position, false);
                    builder.duration(parseQuantity("durationQuantity", reader, -1));
                    break;
                case "durationRange":
                    position = checkElementOrder("duration[x]", 14, position, false);
                    builder.duration(parseRange("durationRange", reader, -1));
                    break;
                case "timeFromEvent":
                    position = checkElementOrder("timeFromEvent", 15, position, true);
                    builder.timeFromEvent(parseEvidenceVariableCharacteristicTimeFromEvent("timeFromEvent", reader, timeFromEventElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable.Characteristic.DefinitionByCombination parseEvidenceVariableCharacteristicDefinitionByCombination(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Characteristic.DefinitionByCombination.Builder builder = EvidenceVariable.Characteristic.DefinitionByCombination.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, characteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((CharacteristicCombination) parseString(CharacteristicCombination.builder(), "code", reader, -1));
                    break;
                case "threshold":
                    position = checkElementOrder("threshold", 3, position, false);
                    builder.threshold((PositiveInt) parseInteger(PositiveInt.builder(), "threshold", reader, -1));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 4, position, true);
                    builder.characteristic(parseEvidenceVariableCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable.Characteristic.DefinitionByTypeAndValue parseEvidenceVariableCharacteristicDefinitionByTypeAndValue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Characteristic.DefinitionByTypeAndValue.Builder builder = EvidenceVariable.Characteristic.DefinitionByTypeAndValue.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, methodElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 3, position, true);
                    builder.method(parseCodeableConcept("method", reader, methodElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 4, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 5, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 5, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 5, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 5, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 5, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 5, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "offset":
                    position = checkElementOrder("offset", 6, position, false);
                    builder.offset(parseCodeableConcept("offset", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable.Characteristic.TimeFromEvent parseEvidenceVariableCharacteristicTimeFromEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Characteristic.TimeFromEvent.Builder builder = EvidenceVariable.Characteristic.TimeFromEvent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "eventCodeableConcept":
                    position = checkElementOrder("event[x]", 4, position, false);
                    builder.event(parseCodeableConcept("eventCodeableConcept", reader, -1));
                    break;
                case "eventReference":
                    position = checkElementOrder("event[x]", 4, position, false);
                    builder.event(parseReference("eventReference", reader, -1));
                    break;
                case "eventDateTime":
                    position = checkElementOrder("event[x]", 4, position, false);
                    builder.event(parseDateTime("eventDateTime", reader, -1));
                    break;
                case "eventId":
                    position = checkElementOrder("event[x]", 4, position, false);
                    builder.event((Id) parseString(Id.builder(), "eventId", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "range":
                    position = checkElementOrder("range", 6, position, false);
                    builder.range(parseRange("range", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario parseExampleScenario(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Builder builder = ExampleScenario.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, actorElementIndex = 0, instanceElementIndex = 0, processElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 25, position, true);
                    builder.actor(parseExampleScenarioActor("actor", reader, actorElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 26, position, true);
                    builder.instance(parseExampleScenarioInstance("instance", reader, instanceElementIndex++));
                    break;
                case "process":
                    position = checkElementOrder("process", 27, position, true);
                    builder.process(parseExampleScenarioProcess("process", reader, processElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Actor parseExampleScenarioActor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Actor.Builder builder = ExampleScenario.Actor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "key":
                    position = checkElementOrder("key", 2, position, false);
                    builder.key(parseString("key", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((ExampleScenarioActorType) parseString(ExampleScenarioActorType.builder(), "type", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 4, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Instance parseExampleScenarioInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Instance.Builder builder = ExampleScenario.Instance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, versionElementIndex = 0, containedInstanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "key":
                    position = checkElementOrder("key", 2, position, false);
                    builder.key(parseString("key", reader, -1));
                    break;
                case "structureType":
                    position = checkElementOrder("structureType", 3, position, false);
                    builder.structureType(parseCoding("structureType", reader, -1));
                    break;
                case "structureVersion":
                    position = checkElementOrder("structureVersion", 4, position, false);
                    builder.structureVersion(parseString("structureVersion", reader, -1));
                    break;
                case "structureProfileCanonical":
                    position = checkElementOrder("structureProfile[x]", 5, position, false);
                    builder.structureProfile((Canonical) parseUri(Canonical.builder(), "structureProfileCanonical", reader, -1));
                    break;
                case "structureProfileUri":
                    position = checkElementOrder("structureProfile[x]", 5, position, false);
                    builder.structureProfile(parseUri("structureProfileUri", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 6, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 7, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "content":
                    position = checkElementOrder("content", 8, position, false);
                    builder.content(parseReference("content", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, true);
                    builder.version(parseExampleScenarioInstanceVersion("version", reader, versionElementIndex++));
                    break;
                case "containedInstance":
                    position = checkElementOrder("containedInstance", 10, position, true);
                    builder.containedInstance(parseExampleScenarioInstanceContainedInstance("containedInstance", reader, containedInstanceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Instance.ContainedInstance parseExampleScenarioInstanceContainedInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Instance.ContainedInstance.Builder builder = ExampleScenario.Instance.ContainedInstance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "instanceReference":
                    position = checkElementOrder("instanceReference", 2, position, false);
                    builder.instanceReference(parseString("instanceReference", reader, -1));
                    break;
                case "versionReference":
                    position = checkElementOrder("versionReference", 3, position, false);
                    builder.versionReference(parseString("versionReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Instance.Version parseExampleScenarioInstanceVersion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Instance.Version.Builder builder = ExampleScenario.Instance.Version.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "key":
                    position = checkElementOrder("key", 2, position, false);
                    builder.key(parseString("key", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 3, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "content":
                    position = checkElementOrder("content", 5, position, false);
                    builder.content(parseReference("content", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Process parseExampleScenarioProcess(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Process.Builder builder = ExampleScenario.Process.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, stepElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "preConditions":
                    position = checkElementOrder("preConditions", 4, position, false);
                    builder.preConditions((Markdown) parseString(Markdown.builder(), "preConditions", reader, -1));
                    break;
                case "postConditions":
                    position = checkElementOrder("postConditions", 5, position, false);
                    builder.postConditions((Markdown) parseString(Markdown.builder(), "postConditions", reader, -1));
                    break;
                case "step":
                    position = checkElementOrder("step", 6, position, true);
                    builder.step(parseExampleScenarioProcessStep("step", reader, stepElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Process.Step parseExampleScenarioProcessStep(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Process.Step.Builder builder = ExampleScenario.Process.Step.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, alternativeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "number":
                    position = checkElementOrder("number", 2, position, false);
                    builder.number(parseString("number", reader, -1));
                    break;
                case "process":
                    position = checkElementOrder("process", 3, position, false);
                    builder.process(parseExampleScenarioProcess("process", reader, -1));
                    break;
                case "workflow":
                    position = checkElementOrder("workflow", 4, position, false);
                    builder.workflow((Canonical) parseUri(Canonical.builder(), "workflow", reader, -1));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 5, position, false);
                    builder.operation(parseExampleScenarioProcessStepOperation("operation", reader, -1));
                    break;
                case "alternative":
                    position = checkElementOrder("alternative", 6, position, true);
                    builder.alternative(parseExampleScenarioProcessStepAlternative("alternative", reader, alternativeElementIndex++));
                    break;
                case "pause":
                    position = checkElementOrder("pause", 7, position, false);
                    builder.pause(parseBoolean("pause", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Process.Step.Alternative parseExampleScenarioProcessStepAlternative(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Process.Step.Alternative.Builder builder = ExampleScenario.Process.Step.Alternative.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, stepElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "step":
                    position = checkElementOrder("step", 4, position, true);
                    builder.step(parseExampleScenarioProcessStep("step", reader, stepElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Process.Step.Operation parseExampleScenarioProcessStepOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Process.Step.Operation.Builder builder = ExampleScenario.Process.Step.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCoding("type", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 3, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "initiator":
                    position = checkElementOrder("initiator", 4, position, false);
                    builder.initiator(parseString("initiator", reader, -1));
                    break;
                case "receiver":
                    position = checkElementOrder("receiver", 5, position, false);
                    builder.receiver(parseString("receiver", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 6, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "initiatorActive":
                    position = checkElementOrder("initiatorActive", 7, position, false);
                    builder.initiatorActive(parseBoolean("initiatorActive", reader, -1));
                    break;
                case "receiverActive":
                    position = checkElementOrder("receiverActive", 8, position, false);
                    builder.receiverActive(parseBoolean("receiverActive", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 9, position, false);
                    builder.request(parseExampleScenarioInstanceContainedInstance("request", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 10, position, false);
                    builder.response(parseExampleScenarioInstanceContainedInstance("response", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit parseExplanationOfBenefit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Builder builder = ExplanationOfBenefit.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, traceNumberElementIndex = 0, relatedElementIndex = 0, eventElementIndex = 0, encounterElementIndex = 0, preAuthRefElementIndex = 0, preAuthRefPeriodElementIndex = 0, careTeamElementIndex = 0, supportingInfoElementIndex = 0, diagnosisElementIndex = 0, procedureElementIndex = 0, insuranceElementIndex = 0, itemElementIndex = 0, addItemElementIndex = 0, adjudicationElementIndex = 0, totalElementIndex = 0, processNoteElementIndex = 0, benefitBalanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 9, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((ExplanationOfBenefitStatus) parseString(ExplanationOfBenefitStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 12, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 13, position, false);
                    builder.use((Use) parseString(Use.builder(), "use", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 14, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "billablePeriod":
                    position = checkElementOrder("billablePeriod", 15, position, false);
                    builder.billablePeriod(parsePeriod("billablePeriod", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 16, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 17, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 18, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 19, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 20, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "fundsReserveRequested":
                    position = checkElementOrder("fundsReserveRequested", 21, position, false);
                    builder.fundsReserveRequested(parseCodeableConcept("fundsReserveRequested", reader, -1));
                    break;
                case "fundsReserve":
                    position = checkElementOrder("fundsReserve", 22, position, false);
                    builder.fundsReserve(parseCodeableConcept("fundsReserve", reader, -1));
                    break;
                case "related":
                    position = checkElementOrder("related", 23, position, true);
                    builder.related(parseExplanationOfBenefitRelated("related", reader, relatedElementIndex++));
                    break;
                case "prescription":
                    position = checkElementOrder("prescription", 24, position, false);
                    builder.prescription(parseReference("prescription", reader, -1));
                    break;
                case "originalPrescription":
                    position = checkElementOrder("originalPrescription", 25, position, false);
                    builder.originalPrescription(parseReference("originalPrescription", reader, -1));
                    break;
                case "event":
                    position = checkElementOrder("event", 26, position, true);
                    builder.event(parseExplanationOfBenefitEvent("event", reader, eventElementIndex++));
                    break;
                case "payee":
                    position = checkElementOrder("payee", 27, position, false);
                    builder.payee(parseExplanationOfBenefitPayee("payee", reader, -1));
                    break;
                case "referral":
                    position = checkElementOrder("referral", 28, position, false);
                    builder.referral(parseReference("referral", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 29, position, true);
                    builder.encounter(parseReference("encounter", reader, encounterElementIndex++));
                    break;
                case "facility":
                    position = checkElementOrder("facility", 30, position, false);
                    builder.facility(parseReference("facility", reader, -1));
                    break;
                case "claim":
                    position = checkElementOrder("claim", 31, position, false);
                    builder.claim(parseReference("claim", reader, -1));
                    break;
                case "claimResponse":
                    position = checkElementOrder("claimResponse", 32, position, false);
                    builder.claimResponse(parseReference("claimResponse", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 33, position, false);
                    builder.outcome((ClaimOutcome) parseString(ClaimOutcome.builder(), "outcome", reader, -1));
                    break;
                case "decision":
                    position = checkElementOrder("decision", 34, position, false);
                    builder.decision(parseCodeableConcept("decision", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 35, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 36, position, true);
                    builder.preAuthRef(parseString("preAuthRef", reader, preAuthRefElementIndex++));
                    break;
                case "preAuthRefPeriod":
                    position = checkElementOrder("preAuthRefPeriod", 37, position, true);
                    builder.preAuthRefPeriod(parsePeriod("preAuthRefPeriod", reader, preAuthRefPeriodElementIndex++));
                    break;
                case "diagnosisRelatedGroup":
                    position = checkElementOrder("diagnosisRelatedGroup", 38, position, false);
                    builder.diagnosisRelatedGroup(parseCodeableConcept("diagnosisRelatedGroup", reader, -1));
                    break;
                case "careTeam":
                    position = checkElementOrder("careTeam", 39, position, true);
                    builder.careTeam(parseExplanationOfBenefitCareTeam("careTeam", reader, careTeamElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 40, position, true);
                    builder.supportingInfo(parseExplanationOfBenefitSupportingInfo("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 41, position, true);
                    builder.diagnosis(parseExplanationOfBenefitDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 42, position, true);
                    builder.procedure(parseExplanationOfBenefitProcedure("procedure", reader, procedureElementIndex++));
                    break;
                case "precedence":
                    position = checkElementOrder("precedence", 43, position, false);
                    builder.precedence((PositiveInt) parseInteger(PositiveInt.builder(), "precedence", reader, -1));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 44, position, true);
                    builder.insurance(parseExplanationOfBenefitInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "accident":
                    position = checkElementOrder("accident", 45, position, false);
                    builder.accident(parseExplanationOfBenefitAccident("accident", reader, -1));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 46, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 47, position, true);
                    builder.item(parseExplanationOfBenefitItem("item", reader, itemElementIndex++));
                    break;
                case "addItem":
                    position = checkElementOrder("addItem", 48, position, true);
                    builder.addItem(parseExplanationOfBenefitAddItem("addItem", reader, addItemElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 49, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "total":
                    position = checkElementOrder("total", 50, position, true);
                    builder.total(parseExplanationOfBenefitTotal("total", reader, totalElementIndex++));
                    break;
                case "payment":
                    position = checkElementOrder("payment", 51, position, false);
                    builder.payment(parseExplanationOfBenefitPayment("payment", reader, -1));
                    break;
                case "formCode":
                    position = checkElementOrder("formCode", 52, position, false);
                    builder.formCode(parseCodeableConcept("formCode", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 53, position, false);
                    builder.form(parseAttachment("form", reader, -1));
                    break;
                case "processNote":
                    position = checkElementOrder("processNote", 54, position, true);
                    builder.processNote(parseExplanationOfBenefitProcessNote("processNote", reader, processNoteElementIndex++));
                    break;
                case "benefitPeriod":
                    position = checkElementOrder("benefitPeriod", 55, position, false);
                    builder.benefitPeriod(parsePeriod("benefitPeriod", reader, -1));
                    break;
                case "benefitBalance":
                    position = checkElementOrder("benefitBalance", 56, position, true);
                    builder.benefitBalance(parseExplanationOfBenefitBenefitBalance("benefitBalance", reader, benefitBalanceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Accident parseExplanationOfBenefitAccident(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Accident.Builder builder = ExplanationOfBenefit.Accident.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 2, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 4, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 4, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.AddItem parseExplanationOfBenefitAddItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.AddItem.Builder builder = ExplanationOfBenefit.AddItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemSequenceElementIndex = 0, detailSequenceElementIndex = 0, subDetailSequenceElementIndex = 0, traceNumberElementIndex = 0, providerElementIndex = 0, requestElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, bodySiteElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemSequence":
                    position = checkElementOrder("itemSequence", 2, position, true);
                    builder.itemSequence((PositiveInt) parseInteger(PositiveInt.builder(), "itemSequence", reader, itemSequenceElementIndex++));
                    break;
                case "detailSequence":
                    position = checkElementOrder("detailSequence", 3, position, true);
                    builder.detailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "detailSequence", reader, detailSequenceElementIndex++));
                    break;
                case "subDetailSequence":
                    position = checkElementOrder("subDetailSequence", 4, position, true);
                    builder.subDetailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "subDetailSequence", reader, subDetailSequenceElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 5, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 6, position, true);
                    builder.provider(parseReference("provider", reader, providerElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 7, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 8, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 9, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 10, position, true);
                    builder.request(parseReference("request", reader, requestElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 11, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 12, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 13, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 13, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "locationCodeableConcept":
                    position = checkElementOrder("location[x]", 14, position, false);
                    builder.location(parseCodeableConcept("locationCodeableConcept", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 14, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 14, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 15, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 16, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 17, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 18, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 19, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 20, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 21, position, true);
                    builder.bodySite(parseExplanationOfBenefitAddItemBodySite("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 22, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 23, position, false);
                    builder.reviewOutcome(parseExplanationOfBenefitItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 24, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 25, position, true);
                    builder.detail(parseExplanationOfBenefitAddItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.AddItem.BodySite parseExplanationOfBenefitAddItemBodySite(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.AddItem.BodySite.Builder builder = ExplanationOfBenefit.AddItem.BodySite.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, siteElementIndex = 0, subSiteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "site":
                    position = checkElementOrder("site", 2, position, true);
                    builder.site(parseCodeableReference("site", reader, siteElementIndex++));
                    break;
                case "subSite":
                    position = checkElementOrder("subSite", 3, position, true);
                    builder.subSite(parseCodeableConcept("subSite", reader, subSiteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.AddItem.Detail parseExplanationOfBenefitAddItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.AddItem.Detail.Builder builder = ExplanationOfBenefit.AddItem.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, modifierElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 2, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 3, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 4, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 5, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 6, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 7, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 8, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 9, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 10, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 11, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 12, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 13, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 14, position, false);
                    builder.reviewOutcome(parseExplanationOfBenefitItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 15, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 16, position, true);
                    builder.subDetail(parseExplanationOfBenefitAddItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.AddItem.Detail.SubDetail parseExplanationOfBenefitAddItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.AddItem.Detail.SubDetail.Builder builder = ExplanationOfBenefit.AddItem.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, modifierElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 2, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 3, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 4, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 5, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 6, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 7, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 8, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 9, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 10, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 11, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 12, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 13, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 14, position, false);
                    builder.reviewOutcome(parseExplanationOfBenefitItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 15, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.BenefitBalance parseExplanationOfBenefitBenefitBalance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.BenefitBalance.Builder builder = ExplanationOfBenefit.BenefitBalance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, financialElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "excluded":
                    position = checkElementOrder("excluded", 3, position, false);
                    builder.excluded(parseBoolean("excluded", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 6, position, false);
                    builder.network(parseCodeableConcept("network", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 7, position, false);
                    builder.unit(parseCodeableConcept("unit", reader, -1));
                    break;
                case "term":
                    position = checkElementOrder("term", 8, position, false);
                    builder.term(parseCodeableConcept("term", reader, -1));
                    break;
                case "financial":
                    position = checkElementOrder("financial", 9, position, true);
                    builder.financial(parseExplanationOfBenefitBenefitBalanceFinancial("financial", reader, financialElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.BenefitBalance.Financial parseExplanationOfBenefitBenefitBalanceFinancial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.BenefitBalance.Financial.Builder builder = ExplanationOfBenefit.BenefitBalance.Financial.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "allowedUnsignedInt":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed((UnsignedInt) parseInteger(UnsignedInt.builder(), "allowedUnsignedInt", reader, -1));
                    break;
                case "allowedString":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed(parseString("allowedString", reader, -1));
                    break;
                case "allowedMoney":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed(parseMoney("allowedMoney", reader, -1));
                    break;
                case "usedUnsignedInt":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used((UnsignedInt) parseInteger(UnsignedInt.builder(), "usedUnsignedInt", reader, -1));
                    break;
                case "usedMoney":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used(parseMoney("usedMoney", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.CareTeam parseExplanationOfBenefitCareTeam(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.CareTeam.Builder builder = ExplanationOfBenefit.CareTeam.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 3, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 4, position, false);
                    builder.responsible(parseBoolean("responsible", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 5, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 6, position, false);
                    builder.specialty(parseCodeableConcept("specialty", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Diagnosis parseExplanationOfBenefitDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Diagnosis.Builder builder = ExplanationOfBenefit.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "diagnosisCodeableConcept":
                    position = checkElementOrder("diagnosis[x]", 3, position, false);
                    builder.diagnosis(parseCodeableConcept("diagnosisCodeableConcept", reader, -1));
                    break;
                case "diagnosisReference":
                    position = checkElementOrder("diagnosis[x]", 3, position, false);
                    builder.diagnosis(parseReference("diagnosisReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "onAdmission":
                    position = checkElementOrder("onAdmission", 5, position, false);
                    builder.onAdmission(parseCodeableConcept("onAdmission", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Event parseExplanationOfBenefitEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Event.Builder builder = ExplanationOfBenefit.Event.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "whenDateTime":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parseDateTime("whenDateTime", reader, -1));
                    break;
                case "whenPeriod":
                    position = checkElementOrder("when[x]", 3, position, false);
                    builder.when(parsePeriod("whenPeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Insurance parseExplanationOfBenefitInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Insurance.Builder builder = ExplanationOfBenefit.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, preAuthRefElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "focal":
                    position = checkElementOrder("focal", 2, position, false);
                    builder.focal(parseBoolean("focal", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 3, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 4, position, true);
                    builder.preAuthRef(parseString("preAuthRef", reader, preAuthRefElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item parseExplanationOfBenefitItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.Builder builder = ExplanationOfBenefit.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, careTeamSequenceElementIndex = 0, diagnosisSequenceElementIndex = 0, procedureSequenceElementIndex = 0, informationSequenceElementIndex = 0, traceNumberElementIndex = 0, requestElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, bodySiteElementIndex = 0, encounterElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "careTeamSequence":
                    position = checkElementOrder("careTeamSequence", 3, position, true);
                    builder.careTeamSequence((PositiveInt) parseInteger(PositiveInt.builder(), "careTeamSequence", reader, careTeamSequenceElementIndex++));
                    break;
                case "diagnosisSequence":
                    position = checkElementOrder("diagnosisSequence", 4, position, true);
                    builder.diagnosisSequence((PositiveInt) parseInteger(PositiveInt.builder(), "diagnosisSequence", reader, diagnosisSequenceElementIndex++));
                    break;
                case "procedureSequence":
                    position = checkElementOrder("procedureSequence", 5, position, true);
                    builder.procedureSequence((PositiveInt) parseInteger(PositiveInt.builder(), "procedureSequence", reader, procedureSequenceElementIndex++));
                    break;
                case "informationSequence":
                    position = checkElementOrder("informationSequence", 6, position, true);
                    builder.informationSequence((PositiveInt) parseInteger(PositiveInt.builder(), "informationSequence", reader, informationSequenceElementIndex++));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 7, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 8, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 9, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 10, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 11, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 12, position, true);
                    builder.request(parseReference("request", reader, requestElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 13, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 14, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 15, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 15, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "locationCodeableConcept":
                    position = checkElementOrder("location[x]", 16, position, false);
                    builder.location(parseCodeableConcept("locationCodeableConcept", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 16, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 16, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 17, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 18, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 19, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 20, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 21, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 22, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 23, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 24, position, true);
                    builder.bodySite(parseExplanationOfBenefitItemBodySite("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 25, position, true);
                    builder.encounter(parseReference("encounter", reader, encounterElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 26, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 27, position, false);
                    builder.reviewOutcome(parseExplanationOfBenefitItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 28, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 29, position, true);
                    builder.detail(parseExplanationOfBenefitItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item.Adjudication parseExplanationOfBenefitItemAdjudication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.Adjudication.Builder builder = ExplanationOfBenefit.Item.Adjudication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 4, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item.BodySite parseExplanationOfBenefitItemBodySite(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.BodySite.Builder builder = ExplanationOfBenefit.Item.BodySite.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, siteElementIndex = 0, subSiteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "site":
                    position = checkElementOrder("site", 2, position, true);
                    builder.site(parseCodeableReference("site", reader, siteElementIndex++));
                    break;
                case "subSite":
                    position = checkElementOrder("subSite", 3, position, true);
                    builder.subSite(parseCodeableConcept("subSite", reader, subSiteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item.Detail parseExplanationOfBenefitItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.Detail.Builder builder = ExplanationOfBenefit.Item.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 3, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 4, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 5, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 6, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 7, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 8, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 9, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 10, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 11, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 12, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 13, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 14, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 15, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 16, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 17, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 18, position, false);
                    builder.reviewOutcome(parseExplanationOfBenefitItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 19, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 20, position, true);
                    builder.subDetail(parseExplanationOfBenefitItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item.Detail.SubDetail parseExplanationOfBenefitItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.Detail.SubDetail.Builder builder = ExplanationOfBenefit.Item.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, traceNumberElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "traceNumber":
                    position = checkElementOrder("traceNumber", 3, position, true);
                    builder.traceNumber(parseIdentifier("traceNumber", reader, traceNumberElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 4, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 5, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 6, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "productOrServiceEnd":
                    position = checkElementOrder("productOrServiceEnd", 7, position, false);
                    builder.productOrServiceEnd(parseCodeableConcept("productOrServiceEnd", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 8, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 9, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "patientPaid":
                    position = checkElementOrder("patientPaid", 10, position, false);
                    builder.patientPaid(parseMoney("patientPaid", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 11, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 12, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 13, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "tax":
                    position = checkElementOrder("tax", 14, position, false);
                    builder.tax(parseMoney("tax", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 15, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 16, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 17, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "reviewOutcome":
                    position = checkElementOrder("reviewOutcome", 18, position, false);
                    builder.reviewOutcome(parseExplanationOfBenefitItemReviewOutcome("reviewOutcome", reader, -1));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 19, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item.ReviewOutcome parseExplanationOfBenefitItemReviewOutcome(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.ReviewOutcome.Builder builder = ExplanationOfBenefit.Item.ReviewOutcome.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, reasonElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "decision":
                    position = checkElementOrder("decision", 2, position, false);
                    builder.decision(parseCodeableConcept("decision", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 4, position, false);
                    builder.preAuthRef(parseString("preAuthRef", reader, -1));
                    break;
                case "preAuthPeriod":
                    position = checkElementOrder("preAuthPeriod", 5, position, false);
                    builder.preAuthPeriod(parsePeriod("preAuthPeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Payee parseExplanationOfBenefitPayee(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Payee.Builder builder = ExplanationOfBenefit.Payee.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "party":
                    position = checkElementOrder("party", 3, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Payment parseExplanationOfBenefitPayment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Payment.Builder builder = ExplanationOfBenefit.Payment.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "adjustment":
                    position = checkElementOrder("adjustment", 3, position, false);
                    builder.adjustment(parseMoney("adjustment", reader, -1));
                    break;
                case "adjustmentReason":
                    position = checkElementOrder("adjustmentReason", 4, position, false);
                    builder.adjustmentReason(parseCodeableConcept("adjustmentReason", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 5, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 6, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 7, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Procedure parseExplanationOfBenefitProcedure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Procedure.Builder builder = ExplanationOfBenefit.Procedure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, udiElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 4, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "procedureCodeableConcept":
                    position = checkElementOrder("procedure[x]", 5, position, false);
                    builder.procedure(parseCodeableConcept("procedureCodeableConcept", reader, -1));
                    break;
                case "procedureReference":
                    position = checkElementOrder("procedure[x]", 5, position, false);
                    builder.procedure(parseReference("procedureReference", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 6, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.ProcessNote parseExplanationOfBenefitProcessNote(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.ProcessNote.Builder builder = ExplanationOfBenefit.ProcessNote.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "number":
                    position = checkElementOrder("number", 2, position, false);
                    builder.number((PositiveInt) parseInteger(PositiveInt.builder(), "number", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 5, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Related parseExplanationOfBenefitRelated(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Related.Builder builder = ExplanationOfBenefit.Related.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "claim":
                    position = checkElementOrder("claim", 2, position, false);
                    builder.claim(parseReference("claim", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 3, position, false);
                    builder.relationship(parseCodeableConcept("relationship", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 4, position, false);
                    builder.reference(parseIdentifier("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.SupportingInfo parseExplanationOfBenefitSupportingInfo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.SupportingInfo.Builder builder = ExplanationOfBenefit.SupportingInfo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 3, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 4, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "timingDate":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parseDate("timingDate", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 7, position, false);
                    builder.reason(parseCoding("reason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Total parseExplanationOfBenefitTotal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Total.Builder builder = ExplanationOfBenefit.Total.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Expression parseExpression(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Expression.Builder builder = Expression.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 1, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Code) parseString(Code.builder(), "name", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 4, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 5, position, false);
                    builder.reference(parseUri("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExtendedContactDetail parseExtendedContactDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExtendedContactDetail.Builder builder = ExtendedContactDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, nameElementIndex = 0, telecomElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 1, position, false);
                    builder.purpose(parseCodeableConcept("purpose", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, true);
                    builder.name(parseHumanName("name", reader, nameElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 3, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 4, position, false);
                    builder.address(parseAddress("address", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 5, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 6, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Extension parseExtension(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Extension.Builder builder = Extension.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String url = reader.getAttributeValue(null, "url");
        if (url != null) {
            builder.url(url);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueInteger64":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseInteger64("valueInteger64", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCodeableReference":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseCodeableReference("valueCodeableReference", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRatioRange":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseRatioRange("valueRatioRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueAvailability":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseAvailability("valueAvailability", reader, -1));
                    break;
                case "valueExtendedContactDetail":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseExtendedContactDetail("valueExtendedContactDetail", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private FamilyMemberHistory parseFamilyMemberHistory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        FamilyMemberHistory.Builder builder = FamilyMemberHistory.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, participantElementIndex = 0, reasonElementIndex = 0, noteElementIndex = 0, conditionElementIndex = 0, procedureElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((FamilyHistoryStatus) parseString(FamilyHistoryStatus.builder(), "status", reader, -1));
                    break;
                case "dataAbsentReason":
                    position = checkElementOrder("dataAbsentReason", 12, position, false);
                    builder.dataAbsentReason(parseCodeableConcept("dataAbsentReason", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 13, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 15, position, true);
                    builder.participant(parseFamilyMemberHistoryParticipant("participant", reader, participantElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 16, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 17, position, false);
                    builder.relationship(parseCodeableConcept("relationship", reader, -1));
                    break;
                case "sex":
                    position = checkElementOrder("sex", 18, position, false);
                    builder.sex(parseCodeableConcept("sex", reader, -1));
                    break;
                case "bornPeriod":
                    position = checkElementOrder("born[x]", 19, position, false);
                    builder.born(parsePeriod("bornPeriod", reader, -1));
                    break;
                case "bornDate":
                    position = checkElementOrder("born[x]", 19, position, false);
                    builder.born(parseDate("bornDate", reader, -1));
                    break;
                case "bornString":
                    position = checkElementOrder("born[x]", 19, position, false);
                    builder.born(parseString("bornString", reader, -1));
                    break;
                case "ageAge":
                    position = checkElementOrder("age[x]", 20, position, false);
                    builder.age((Age) parseQuantity(Age.builder(), "ageAge", reader, -1));
                    break;
                case "ageRange":
                    position = checkElementOrder("age[x]", 20, position, false);
                    builder.age(parseRange("ageRange", reader, -1));
                    break;
                case "ageString":
                    position = checkElementOrder("age[x]", 20, position, false);
                    builder.age(parseString("ageString", reader, -1));
                    break;
                case "estimatedAge":
                    position = checkElementOrder("estimatedAge", 21, position, false);
                    builder.estimatedAge(parseBoolean("estimatedAge", reader, -1));
                    break;
                case "deceasedBoolean":
                    position = checkElementOrder("deceased[x]", 22, position, false);
                    builder.deceased(parseBoolean("deceasedBoolean", reader, -1));
                    break;
                case "deceasedAge":
                    position = checkElementOrder("deceased[x]", 22, position, false);
                    builder.deceased((Age) parseQuantity(Age.builder(), "deceasedAge", reader, -1));
                    break;
                case "deceasedRange":
                    position = checkElementOrder("deceased[x]", 22, position, false);
                    builder.deceased(parseRange("deceasedRange", reader, -1));
                    break;
                case "deceasedDate":
                    position = checkElementOrder("deceased[x]", 22, position, false);
                    builder.deceased(parseDate("deceasedDate", reader, -1));
                    break;
                case "deceasedString":
                    position = checkElementOrder("deceased[x]", 22, position, false);
                    builder.deceased(parseString("deceasedString", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 23, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 24, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 25, position, true);
                    builder.condition(parseFamilyMemberHistoryCondition("condition", reader, conditionElementIndex++));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 26, position, true);
                    builder.procedure(parseFamilyMemberHistoryProcedure("procedure", reader, procedureElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private FamilyMemberHistory.Condition parseFamilyMemberHistoryCondition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        FamilyMemberHistory.Condition.Builder builder = FamilyMemberHistory.Condition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 3, position, false);
                    builder.outcome(parseCodeableConcept("outcome", reader, -1));
                    break;
                case "contributedToDeath":
                    position = checkElementOrder("contributedToDeath", 4, position, false);
                    builder.contributedToDeath(parseBoolean("contributedToDeath", reader, -1));
                    break;
                case "onsetAge":
                    position = checkElementOrder("onset[x]", 5, position, false);
                    builder.onset((Age) parseQuantity(Age.builder(), "onsetAge", reader, -1));
                    break;
                case "onsetRange":
                    position = checkElementOrder("onset[x]", 5, position, false);
                    builder.onset(parseRange("onsetRange", reader, -1));
                    break;
                case "onsetPeriod":
                    position = checkElementOrder("onset[x]", 5, position, false);
                    builder.onset(parsePeriod("onsetPeriod", reader, -1));
                    break;
                case "onsetString":
                    position = checkElementOrder("onset[x]", 5, position, false);
                    builder.onset(parseString("onsetString", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 6, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private FamilyMemberHistory.Participant parseFamilyMemberHistoryParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        FamilyMemberHistory.Participant.Builder builder = FamilyMemberHistory.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private FamilyMemberHistory.Procedure parseFamilyMemberHistoryProcedure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        FamilyMemberHistory.Procedure.Builder builder = FamilyMemberHistory.Procedure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 3, position, false);
                    builder.outcome(parseCodeableConcept("outcome", reader, -1));
                    break;
                case "contributedToDeath":
                    position = checkElementOrder("contributedToDeath", 4, position, false);
                    builder.contributedToDeath(parseBoolean("contributedToDeath", reader, -1));
                    break;
                case "performedAge":
                    position = checkElementOrder("performed[x]", 5, position, false);
                    builder.performed((Age) parseQuantity(Age.builder(), "performedAge", reader, -1));
                    break;
                case "performedRange":
                    position = checkElementOrder("performed[x]", 5, position, false);
                    builder.performed(parseRange("performedRange", reader, -1));
                    break;
                case "performedPeriod":
                    position = checkElementOrder("performed[x]", 5, position, false);
                    builder.performed(parsePeriod("performedPeriod", reader, -1));
                    break;
                case "performedString":
                    position = checkElementOrder("performed[x]", 5, position, false);
                    builder.performed(parseString("performedString", reader, -1));
                    break;
                case "performedDateTime":
                    position = checkElementOrder("performed[x]", 5, position, false);
                    builder.performed(parseDateTime("performedDateTime", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 6, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Flag parseFlag(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Flag.Builder builder = Flag.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((FlagStatus) parseString(FlagStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 11, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 13, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 15, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private FormularyItem parseFormularyItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        FormularyItem.Builder builder = FormularyItem.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((FormularyItemStatus) parseString(FormularyItemStatus.builder(), "status", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GenomicStudy parseGenomicStudy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GenomicStudy.Builder builder = GenomicStudy.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, typeElementIndex = 0, basedOnElementIndex = 0, interpreterElementIndex = 0, reasonElementIndex = 0, noteElementIndex = 0, analysisElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((GenomicStudyStatus) parseString(GenomicStudyStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 11, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 12, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "startDate":
                    position = checkElementOrder("startDate", 13, position, false);
                    builder.startDate(parseDateTime("startDate", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 14, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "referrer":
                    position = checkElementOrder("referrer", 15, position, false);
                    builder.referrer(parseReference("referrer", reader, -1));
                    break;
                case "interpreter":
                    position = checkElementOrder("interpreter", 16, position, true);
                    builder.interpreter(parseReference("interpreter", reader, interpreterElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 17, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 18, position, false);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, -1));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 19, position, false);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 20, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 21, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "analysis":
                    position = checkElementOrder("analysis", 22, position, true);
                    builder.analysis(parseGenomicStudyAnalysis("analysis", reader, analysisElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GenomicStudy.Analysis parseGenomicStudyAnalysis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GenomicStudy.Analysis.Builder builder = GenomicStudy.Analysis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, methodTypeElementIndex = 0, changeTypeElementIndex = 0, focusElementIndex = 0, specimenElementIndex = 0, noteElementIndex = 0, regionsStudiedElementIndex = 0, regionsCalledElementIndex = 0, inputElementIndex = 0, outputElementIndex = 0, performerElementIndex = 0, deviceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "methodType":
                    position = checkElementOrder("methodType", 3, position, true);
                    builder.methodType(parseCodeableConcept("methodType", reader, methodTypeElementIndex++));
                    break;
                case "changeType":
                    position = checkElementOrder("changeType", 4, position, true);
                    builder.changeType(parseCodeableConcept("changeType", reader, changeTypeElementIndex++));
                    break;
                case "genomeBuild":
                    position = checkElementOrder("genomeBuild", 5, position, false);
                    builder.genomeBuild(parseCodeableConcept("genomeBuild", reader, -1));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 6, position, false);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, -1));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 7, position, false);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 8, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 9, position, true);
                    builder.focus(parseReference("focus", reader, focusElementIndex++));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 10, position, true);
                    builder.specimen(parseReference("specimen", reader, specimenElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 11, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 12, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "protocolPerformed":
                    position = checkElementOrder("protocolPerformed", 13, position, false);
                    builder.protocolPerformed(parseReference("protocolPerformed", reader, -1));
                    break;
                case "regionsStudied":
                    position = checkElementOrder("regionsStudied", 14, position, true);
                    builder.regionsStudied(parseReference("regionsStudied", reader, regionsStudiedElementIndex++));
                    break;
                case "regionsCalled":
                    position = checkElementOrder("regionsCalled", 15, position, true);
                    builder.regionsCalled(parseReference("regionsCalled", reader, regionsCalledElementIndex++));
                    break;
                case "input":
                    position = checkElementOrder("input", 16, position, true);
                    builder.input(parseGenomicStudyAnalysisInput("input", reader, inputElementIndex++));
                    break;
                case "output":
                    position = checkElementOrder("output", 17, position, true);
                    builder.output(parseGenomicStudyAnalysisOutput("output", reader, outputElementIndex++));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 18, position, true);
                    builder.performer(parseGenomicStudyAnalysisPerformer("performer", reader, performerElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 19, position, true);
                    builder.device(parseGenomicStudyAnalysisDevice("device", reader, deviceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GenomicStudy.Analysis.Device parseGenomicStudyAnalysisDevice(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GenomicStudy.Analysis.Device.Builder builder = GenomicStudy.Analysis.Device.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 2, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "function":
                    position = checkElementOrder("function", 3, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GenomicStudy.Analysis.Input parseGenomicStudyAnalysisInput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GenomicStudy.Analysis.Input.Builder builder = GenomicStudy.Analysis.Input.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "file":
                    position = checkElementOrder("file", 2, position, false);
                    builder.file(parseReference("file", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "generatedByIdentifier":
                    position = checkElementOrder("generatedBy[x]", 4, position, false);
                    builder.generatedBy(parseIdentifier("generatedByIdentifier", reader, -1));
                    break;
                case "generatedByReference":
                    position = checkElementOrder("generatedBy[x]", 4, position, false);
                    builder.generatedBy(parseReference("generatedByReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GenomicStudy.Analysis.Output parseGenomicStudyAnalysisOutput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GenomicStudy.Analysis.Output.Builder builder = GenomicStudy.Analysis.Output.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "file":
                    position = checkElementOrder("file", 2, position, false);
                    builder.file(parseReference("file", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GenomicStudy.Analysis.Performer parseGenomicStudyAnalysisPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GenomicStudy.Analysis.Performer.Builder builder = GenomicStudy.Analysis.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 2, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Goal parseGoal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Goal.Builder builder = Goal.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, targetElementIndex = 0, addressesElementIndex = 0, noteElementIndex = 0, outcomeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "lifecycleStatus":
                    position = checkElementOrder("lifecycleStatus", 9, position, false);
                    builder.lifecycleStatus((GoalLifecycleStatus) parseString(GoalLifecycleStatus.builder(), "lifecycleStatus", reader, -1));
                    break;
                case "achievementStatus":
                    position = checkElementOrder("achievementStatus", 10, position, false);
                    builder.achievementStatus(parseCodeableConcept("achievementStatus", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "continuous":
                    position = checkElementOrder("continuous", 12, position, false);
                    builder.continuous(parseBoolean("continuous", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 13, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 14, position, false);
                    builder.description(parseCodeableConcept("description", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 15, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "startDate":
                    position = checkElementOrder("start[x]", 16, position, false);
                    builder.start(parseDate("startDate", reader, -1));
                    break;
                case "startCodeableConcept":
                    position = checkElementOrder("start[x]", 16, position, false);
                    builder.start(parseCodeableConcept("startCodeableConcept", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 17, position, true);
                    builder.target(parseGoalTarget("target", reader, targetElementIndex++));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 18, position, false);
                    builder.statusDate(parseDate("statusDate", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 19, position, false);
                    builder.statusReason(parseString("statusReason", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 20, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                case "addresses":
                    position = checkElementOrder("addresses", 21, position, true);
                    builder.addresses(parseReference("addresses", reader, addressesElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 22, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 23, position, true);
                    builder.outcome(parseCodeableReference("outcome", reader, outcomeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Goal.Target parseGoalTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Goal.Target.Builder builder = Goal.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "measure":
                    position = checkElementOrder("measure", 2, position, false);
                    builder.measure(parseCodeableConcept("measure", reader, -1));
                    break;
                case "detailQuantity":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseQuantity("detailQuantity", reader, -1));
                    break;
                case "detailRange":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseRange("detailRange", reader, -1));
                    break;
                case "detailCodeableConcept":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseCodeableConcept("detailCodeableConcept", reader, -1));
                    break;
                case "detailString":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseString("detailString", reader, -1));
                    break;
                case "detailBoolean":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseBoolean("detailBoolean", reader, -1));
                    break;
                case "detailInteger":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseInteger("detailInteger", reader, -1));
                    break;
                case "detailRatio":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseRatio("detailRatio", reader, -1));
                    break;
                case "dueDate":
                    position = checkElementOrder("due[x]", 4, position, false);
                    builder.due(parseDate("dueDate", reader, -1));
                    break;
                case "dueDuration":
                    position = checkElementOrder("due[x]", 4, position, false);
                    builder.due((Duration) parseQuantity(Duration.builder(), "dueDuration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GraphDefinition parseGraphDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GraphDefinition.Builder builder = GraphDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, nodeElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 25, position, false);
                    builder.start((Id) parseString(Id.builder(), "start", reader, -1));
                    break;
                case "node":
                    position = checkElementOrder("node", 26, position, true);
                    builder.node(parseGraphDefinitionNode("node", reader, nodeElementIndex++));
                    break;
                case "link":
                    position = checkElementOrder("link", 27, position, true);
                    builder.link(parseGraphDefinitionLink("link", reader, linkElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GraphDefinition.Link parseGraphDefinitionLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GraphDefinition.Link.Builder builder = GraphDefinition.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, compartmentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 3, position, false);
                    builder.min(parseInteger("min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 4, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "sourceId":
                    position = checkElementOrder("sourceId", 5, position, false);
                    builder.sourceId((Id) parseString(Id.builder(), "sourceId", reader, -1));
                    break;
                case "path":
                    position = checkElementOrder("path", 6, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "sliceName":
                    position = checkElementOrder("sliceName", 7, position, false);
                    builder.sliceName(parseString("sliceName", reader, -1));
                    break;
                case "targetId":
                    position = checkElementOrder("targetId", 8, position, false);
                    builder.targetId((Id) parseString(Id.builder(), "targetId", reader, -1));
                    break;
                case "params":
                    position = checkElementOrder("params", 9, position, false);
                    builder.params(parseString("params", reader, -1));
                    break;
                case "compartment":
                    position = checkElementOrder("compartment", 10, position, true);
                    builder.compartment(parseGraphDefinitionLinkCompartment("compartment", reader, compartmentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GraphDefinition.Link.Compartment parseGraphDefinitionLinkCompartment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GraphDefinition.Link.Compartment.Builder builder = GraphDefinition.Link.Compartment.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 2, position, false);
                    builder.use((GraphCompartmentUse) parseString(GraphCompartmentUse.builder(), "use", reader, -1));
                    break;
                case "rule":
                    position = checkElementOrder("rule", 3, position, false);
                    builder.rule((GraphCompartmentRule) parseString(GraphCompartmentRule.builder(), "rule", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 4, position, false);
                    builder.code((CompartmentCode) parseString(CompartmentCode.builder(), "code", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 5, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 6, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GraphDefinition.Node parseGraphDefinitionNode(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GraphDefinition.Node.Builder builder = GraphDefinition.Node.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "nodeId":
                    position = checkElementOrder("nodeId", 2, position, false);
                    builder.nodeId((Id) parseString(Id.builder(), "nodeId", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type((FHIRTypes) parseString(FHIRTypes.builder(), "type", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 5, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Group parseGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Group.Builder builder = Group.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, characteristicElementIndex = 0, memberElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type((GroupType) parseString(GroupType.builder(), "type", reader, -1));
                    break;
                case "membership":
                    position = checkElementOrder("membership", 11, position, false);
                    builder.membership((Code) parseString(Code.builder(), "membership", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 12, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 13, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 14, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 15, position, false);
                    builder.quantity((UnsignedInt) parseInteger(UnsignedInt.builder(), "quantity", reader, -1));
                    break;
                case "managingEntity":
                    position = checkElementOrder("managingEntity", 16, position, false);
                    builder.managingEntity(parseReference("managingEntity", reader, -1));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 17, position, true);
                    builder.characteristic(parseGroupCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                case "member":
                    position = checkElementOrder("member", 18, position, true);
                    builder.member(parseGroupMember("member", reader, memberElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Group.Characteristic parseGroupCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Group.Characteristic.Builder builder = Group.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "exclude":
                    position = checkElementOrder("exclude", 4, position, false);
                    builder.exclude(parseBoolean("exclude", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Group.Member parseGroupMember(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Group.Member.Builder builder = Group.Member.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "entity":
                    position = checkElementOrder("entity", 2, position, false);
                    builder.entity(parseReference("entity", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "inactive":
                    position = checkElementOrder("inactive", 4, position, false);
                    builder.inactive(parseBoolean("inactive", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GuidanceResponse parseGuidanceResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GuidanceResponse.Builder builder = GuidanceResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, reasonElementIndex = 0, noteElementIndex = 0, resultElementIndex = 0, dataRequirementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "requestIdentifier":
                    position = checkElementOrder("requestIdentifier", 8, position, false);
                    builder.requestIdentifier(parseIdentifier("requestIdentifier", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "moduleUri":
                    position = checkElementOrder("module[x]", 10, position, false);
                    builder.module(parseUri("moduleUri", reader, -1));
                    break;
                case "moduleCanonical":
                    position = checkElementOrder("module[x]", 10, position, false);
                    builder.module((Canonical) parseUri(Canonical.builder(), "moduleCanonical", reader, -1));
                    break;
                case "moduleCodeableConcept":
                    position = checkElementOrder("module[x]", 10, position, false);
                    builder.module(parseCodeableConcept("moduleCodeableConcept", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((GuidanceResponseStatus) parseString(GuidanceResponseStatus.builder(), "status", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 13, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrenceDateTime", 14, position, false);
                    builder.occurrenceDateTime(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 15, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 16, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 17, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "evaluationMessage":
                    position = checkElementOrder("evaluationMessage", 18, position, false);
                    builder.evaluationMessage(parseReference("evaluationMessage", reader, -1));
                    break;
                case "outputParameters":
                    position = checkElementOrder("outputParameters", 19, position, false);
                    builder.outputParameters(parseReference("outputParameters", reader, -1));
                    break;
                case "result":
                    position = checkElementOrder("result", 20, position, true);
                    builder.result(parseReference("result", reader, resultElementIndex++));
                    break;
                case "dataRequirement":
                    position = checkElementOrder("dataRequirement", 21, position, true);
                    builder.dataRequirement(parseDataRequirement("dataRequirement", reader, dataRequirementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private HealthcareService parseHealthcareService(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        HealthcareService.Builder builder = HealthcareService.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, offeredInElementIndex = 0, categoryElementIndex = 0, typeElementIndex = 0, specialtyElementIndex = 0, locationElementIndex = 0, contactElementIndex = 0, coverageAreaElementIndex = 0, serviceProvisionCodeElementIndex = 0, eligibilityElementIndex = 0, programElementIndex = 0, characteristicElementIndex = 0, communicationElementIndex = 0, referralMethodElementIndex = 0, availabilityElementIndex = 0, endpointElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "providedBy":
                    position = checkElementOrder("providedBy", 10, position, false);
                    builder.providedBy(parseReference("providedBy", reader, -1));
                    break;
                case "offeredIn":
                    position = checkElementOrder("offeredIn", 11, position, true);
                    builder.offeredIn(parseReference("offeredIn", reader, offeredInElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 12, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 13, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 14, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 15, position, true);
                    builder.location(parseReference("location", reader, locationElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 16, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 17, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                case "extraDetails":
                    position = checkElementOrder("extraDetails", 18, position, false);
                    builder.extraDetails((Markdown) parseString(Markdown.builder(), "extraDetails", reader, -1));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 19, position, false);
                    builder.photo(parseAttachment("photo", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 20, position, true);
                    builder.contact(parseExtendedContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "coverageArea":
                    position = checkElementOrder("coverageArea", 21, position, true);
                    builder.coverageArea(parseReference("coverageArea", reader, coverageAreaElementIndex++));
                    break;
                case "serviceProvisionCode":
                    position = checkElementOrder("serviceProvisionCode", 22, position, true);
                    builder.serviceProvisionCode(parseCodeableConcept("serviceProvisionCode", reader, serviceProvisionCodeElementIndex++));
                    break;
                case "eligibility":
                    position = checkElementOrder("eligibility", 23, position, true);
                    builder.eligibility(parseHealthcareServiceEligibility("eligibility", reader, eligibilityElementIndex++));
                    break;
                case "program":
                    position = checkElementOrder("program", 24, position, true);
                    builder.program(parseCodeableConcept("program", reader, programElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 25, position, true);
                    builder.characteristic(parseCodeableConcept("characteristic", reader, characteristicElementIndex++));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 26, position, true);
                    builder.communication(parseCodeableConcept("communication", reader, communicationElementIndex++));
                    break;
                case "referralMethod":
                    position = checkElementOrder("referralMethod", 27, position, true);
                    builder.referralMethod(parseCodeableConcept("referralMethod", reader, referralMethodElementIndex++));
                    break;
                case "appointmentRequired":
                    position = checkElementOrder("appointmentRequired", 28, position, false);
                    builder.appointmentRequired(parseBoolean("appointmentRequired", reader, -1));
                    break;
                case "availability":
                    position = checkElementOrder("availability", 29, position, true);
                    builder.availability(parseAvailability("availability", reader, availabilityElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 30, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private HealthcareService.Eligibility parseHealthcareServiceEligibility(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        HealthcareService.Eligibility.Builder builder = HealthcareService.Eligibility.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 3, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private HumanName parseHumanName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        HumanName.Builder builder = HumanName.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, givenElementIndex = 0, prefixElementIndex = 0, suffixElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 1, position, false);
                    builder.use((NameUse) parseString(NameUse.builder(), "use", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 2, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "family":
                    position = checkElementOrder("family", 3, position, false);
                    builder.family(parseString("family", reader, -1));
                    break;
                case "given":
                    position = checkElementOrder("given", 4, position, true);
                    builder.given(parseString("given", reader, givenElementIndex++));
                    break;
                case "prefix":
                    position = checkElementOrder("prefix", 5, position, true);
                    builder.prefix(parseString("prefix", reader, prefixElementIndex++));
                    break;
                case "suffix":
                    position = checkElementOrder("suffix", 6, position, true);
                    builder.suffix(parseString("suffix", reader, suffixElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 7, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Identifier parseIdentifier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Identifier.Builder builder = Identifier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 1, position, false);
                    builder.use((IdentifierUse) parseString(IdentifierUse.builder(), "use", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "system":
                    position = checkElementOrder("system", 3, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 4, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "assigner":
                    position = checkElementOrder("assigner", 6, position, false);
                    builder.assigner(parseReference("assigner", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingSelection parseImagingSelection(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingSelection.Builder builder = ImagingSelection.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, performerElementIndex = 0, basedOnElementIndex = 0, categoryElementIndex = 0, derivedFromElementIndex = 0, endpointElementIndex = 0, focusElementIndex = 0, instanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ImagingSelectionStatus) parseString(ImagingSelectionStatus.builder(), "status", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 10, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 11, position, false);
                    builder.issued(parseInstant("issued", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 12, position, true);
                    builder.performer(parseImagingSelectionPerformer("performer", reader, performerElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 13, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 14, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 15, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "studyUid":
                    position = checkElementOrder("studyUid", 16, position, false);
                    builder.studyUid((Id) parseString(Id.builder(), "studyUid", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 17, position, true);
                    builder.derivedFrom(parseReference("derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 18, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                case "seriesUid":
                    position = checkElementOrder("seriesUid", 19, position, false);
                    builder.seriesUid((Id) parseString(Id.builder(), "seriesUid", reader, -1));
                    break;
                case "seriesNumber":
                    position = checkElementOrder("seriesNumber", 20, position, false);
                    builder.seriesNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "seriesNumber", reader, -1));
                    break;
                case "frameOfReferenceUid":
                    position = checkElementOrder("frameOfReferenceUid", 21, position, false);
                    builder.frameOfReferenceUid((Id) parseString(Id.builder(), "frameOfReferenceUid", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 22, position, false);
                    builder.bodySite(parseCodeableReference("bodySite", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 23, position, true);
                    builder.focus(parseReference("focus", reader, focusElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 24, position, true);
                    builder.instance(parseImagingSelectionInstance("instance", reader, instanceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingSelection.Instance parseImagingSelectionInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingSelection.Instance.Builder builder = ImagingSelection.Instance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, subsetElementIndex = 0, imageRegion2DElementIndex = 0, imageRegion3DElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "uid":
                    position = checkElementOrder("uid", 2, position, false);
                    builder.uid((Id) parseString(Id.builder(), "uid", reader, -1));
                    break;
                case "number":
                    position = checkElementOrder("number", 3, position, false);
                    builder.number((UnsignedInt) parseInteger(UnsignedInt.builder(), "number", reader, -1));
                    break;
                case "sopClass":
                    position = checkElementOrder("sopClass", 4, position, false);
                    builder.sopClass(parseCoding("sopClass", reader, -1));
                    break;
                case "subset":
                    position = checkElementOrder("subset", 5, position, true);
                    builder.subset(parseString("subset", reader, subsetElementIndex++));
                    break;
                case "imageRegion2D":
                    position = checkElementOrder("imageRegion2D", 6, position, true);
                    builder.imageRegion2D(parseImagingSelectionInstanceImageRegion2D("imageRegion2D", reader, imageRegion2DElementIndex++));
                    break;
                case "imageRegion3D":
                    position = checkElementOrder("imageRegion3D", 7, position, true);
                    builder.imageRegion3D(parseImagingSelectionInstanceImageRegion3D("imageRegion3D", reader, imageRegion3DElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingSelection.Instance.ImageRegion2D parseImagingSelectionInstanceImageRegion2D(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingSelection.Instance.ImageRegion2D.Builder builder = ImagingSelection.Instance.ImageRegion2D.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, coordinateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "regionType":
                    position = checkElementOrder("regionType", 2, position, false);
                    builder.regionType((ImagingSelection2DGraphicType) parseString(ImagingSelection2DGraphicType.builder(), "regionType", reader, -1));
                    break;
                case "coordinate":
                    position = checkElementOrder("coordinate", 3, position, true);
                    builder.coordinate(parseDecimal("coordinate", reader, coordinateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingSelection.Instance.ImageRegion3D parseImagingSelectionInstanceImageRegion3D(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingSelection.Instance.ImageRegion3D.Builder builder = ImagingSelection.Instance.ImageRegion3D.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, coordinateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "regionType":
                    position = checkElementOrder("regionType", 2, position, false);
                    builder.regionType((ImagingSelection3DGraphicType) parseString(ImagingSelection3DGraphicType.builder(), "regionType", reader, -1));
                    break;
                case "coordinate":
                    position = checkElementOrder("coordinate", 3, position, true);
                    builder.coordinate(parseDecimal("coordinate", reader, coordinateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingSelection.Performer parseImagingSelectionPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingSelection.Performer.Builder builder = ImagingSelection.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingStudy parseImagingStudy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingStudy.Builder builder = ImagingStudy.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, modalityElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, endpointElementIndex = 0, procedureElementIndex = 0, reasonElementIndex = 0, noteElementIndex = 0, seriesElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ImagingStudyStatus) parseString(ImagingStudyStatus.builder(), "status", reader, -1));
                    break;
                case "modality":
                    position = checkElementOrder("modality", 10, position, true);
                    builder.modality(parseCodeableConcept("modality", reader, modalityElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 11, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 12, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "started":
                    position = checkElementOrder("started", 13, position, false);
                    builder.started(parseDateTime("started", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 14, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 15, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "referrer":
                    position = checkElementOrder("referrer", 16, position, false);
                    builder.referrer(parseReference("referrer", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 17, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                case "numberOfSeries":
                    position = checkElementOrder("numberOfSeries", 18, position, false);
                    builder.numberOfSeries((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfSeries", reader, -1));
                    break;
                case "numberOfInstances":
                    position = checkElementOrder("numberOfInstances", 19, position, false);
                    builder.numberOfInstances((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfInstances", reader, -1));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 20, position, true);
                    builder.procedure(parseCodeableReference("procedure", reader, procedureElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 21, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 22, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 23, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 24, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "series":
                    position = checkElementOrder("series", 25, position, true);
                    builder.series(parseImagingStudySeries("series", reader, seriesElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingStudy.Series parseImagingStudySeries(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingStudy.Series.Builder builder = ImagingStudy.Series.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, endpointElementIndex = 0, specimenElementIndex = 0, performerElementIndex = 0, instanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "uid":
                    position = checkElementOrder("uid", 2, position, false);
                    builder.uid((Id) parseString(Id.builder(), "uid", reader, -1));
                    break;
                case "number":
                    position = checkElementOrder("number", 3, position, false);
                    builder.number((UnsignedInt) parseInteger(UnsignedInt.builder(), "number", reader, -1));
                    break;
                case "modality":
                    position = checkElementOrder("modality", 4, position, false);
                    builder.modality(parseCodeableConcept("modality", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "numberOfInstances":
                    position = checkElementOrder("numberOfInstances", 6, position, false);
                    builder.numberOfInstances((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfInstances", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 7, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 8, position, false);
                    builder.bodySite(parseCodeableReference("bodySite", reader, -1));
                    break;
                case "laterality":
                    position = checkElementOrder("laterality", 9, position, false);
                    builder.laterality(parseCodeableConcept("laterality", reader, -1));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 10, position, true);
                    builder.specimen(parseReference("specimen", reader, specimenElementIndex++));
                    break;
                case "started":
                    position = checkElementOrder("started", 11, position, false);
                    builder.started(parseDateTime("started", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 12, position, true);
                    builder.performer(parseImagingStudySeriesPerformer("performer", reader, performerElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 13, position, true);
                    builder.instance(parseImagingStudySeriesInstance("instance", reader, instanceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingStudy.Series.Instance parseImagingStudySeriesInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingStudy.Series.Instance.Builder builder = ImagingStudy.Series.Instance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "uid":
                    position = checkElementOrder("uid", 2, position, false);
                    builder.uid((Id) parseString(Id.builder(), "uid", reader, -1));
                    break;
                case "sopClass":
                    position = checkElementOrder("sopClass", 3, position, false);
                    builder.sopClass(parseCoding("sopClass", reader, -1));
                    break;
                case "number":
                    position = checkElementOrder("number", 4, position, false);
                    builder.number((UnsignedInt) parseInteger(UnsignedInt.builder(), "number", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 5, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingStudy.Series.Performer parseImagingStudySeriesPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingStudy.Series.Performer.Builder builder = ImagingStudy.Series.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization parseImmunization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.Builder builder = Immunization.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, supportingInformationElementIndex = 0, performerElementIndex = 0, noteElementIndex = 0, reasonElementIndex = 0, subpotentReasonElementIndex = 0, programEligibilityElementIndex = 0, reactionElementIndex = 0, protocolAppliedElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((ImmunizationStatus) parseString(ImmunizationStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 11, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "vaccineCode":
                    position = checkElementOrder("vaccineCode", 12, position, false);
                    builder.vaccineCode(parseCodeableConcept("vaccineCode", reader, -1));
                    break;
                case "administeredProduct":
                    position = checkElementOrder("administeredProduct", 13, position, false);
                    builder.administeredProduct(parseCodeableReference("administeredProduct", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 14, position, false);
                    builder.manufacturer(parseCodeableReference("manufacturer", reader, -1));
                    break;
                case "lotNumber":
                    position = checkElementOrder("lotNumber", 15, position, false);
                    builder.lotNumber(parseString("lotNumber", reader, -1));
                    break;
                case "expirationDate":
                    position = checkElementOrder("expirationDate", 16, position, false);
                    builder.expirationDate(parseDate("expirationDate", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 17, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 18, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 19, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 20, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrenceString":
                    position = checkElementOrder("occurrence[x]", 20, position, false);
                    builder.occurrence(parseString("occurrenceString", reader, -1));
                    break;
                case "primarySource":
                    position = checkElementOrder("primarySource", 21, position, false);
                    builder.primarySource(parseBoolean("primarySource", reader, -1));
                    break;
                case "informationSource":
                    position = checkElementOrder("informationSource", 22, position, false);
                    builder.informationSource(parseCodeableReference("informationSource", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 23, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "site":
                    position = checkElementOrder("site", 24, position, false);
                    builder.site(parseCodeableConcept("site", reader, -1));
                    break;
                case "route":
                    position = checkElementOrder("route", 25, position, false);
                    builder.route(parseCodeableConcept("route", reader, -1));
                    break;
                case "doseQuantity":
                    position = checkElementOrder("doseQuantity", 26, position, false);
                    builder.doseQuantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "doseQuantity", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 27, position, true);
                    builder.performer(parseImmunizationPerformer("performer", reader, performerElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 28, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 29, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "isSubpotent":
                    position = checkElementOrder("isSubpotent", 30, position, false);
                    builder.isSubpotent(parseBoolean("isSubpotent", reader, -1));
                    break;
                case "subpotentReason":
                    position = checkElementOrder("subpotentReason", 31, position, true);
                    builder.subpotentReason(parseCodeableConcept("subpotentReason", reader, subpotentReasonElementIndex++));
                    break;
                case "programEligibility":
                    position = checkElementOrder("programEligibility", 32, position, true);
                    builder.programEligibility(parseImmunizationProgramEligibility("programEligibility", reader, programEligibilityElementIndex++));
                    break;
                case "fundingSource":
                    position = checkElementOrder("fundingSource", 33, position, false);
                    builder.fundingSource(parseCodeableConcept("fundingSource", reader, -1));
                    break;
                case "reaction":
                    position = checkElementOrder("reaction", 34, position, true);
                    builder.reaction(parseImmunizationReaction("reaction", reader, reactionElementIndex++));
                    break;
                case "protocolApplied":
                    position = checkElementOrder("protocolApplied", 35, position, true);
                    builder.protocolApplied(parseImmunizationProtocolApplied("protocolApplied", reader, protocolAppliedElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization.Performer parseImmunizationPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.Performer.Builder builder = Immunization.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization.ProgramEligibility parseImmunizationProgramEligibility(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.ProgramEligibility.Builder builder = Immunization.ProgramEligibility.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "program":
                    position = checkElementOrder("program", 2, position, false);
                    builder.program(parseCodeableConcept("program", reader, -1));
                    break;
                case "programStatus":
                    position = checkElementOrder("programStatus", 3, position, false);
                    builder.programStatus(parseCodeableConcept("programStatus", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization.ProtocolApplied parseImmunizationProtocolApplied(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.ProtocolApplied.Builder builder = Immunization.ProtocolApplied.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetDiseaseElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "series":
                    position = checkElementOrder("series", 2, position, false);
                    builder.series(parseString("series", reader, -1));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 3, position, false);
                    builder.authority(parseReference("authority", reader, -1));
                    break;
                case "targetDisease":
                    position = checkElementOrder("targetDisease", 4, position, true);
                    builder.targetDisease(parseCodeableConcept("targetDisease", reader, targetDiseaseElementIndex++));
                    break;
                case "doseNumber":
                    position = checkElementOrder("doseNumber", 5, position, false);
                    builder.doseNumber(parseString("doseNumber", reader, -1));
                    break;
                case "seriesDoses":
                    position = checkElementOrder("seriesDoses", 6, position, false);
                    builder.seriesDoses(parseString("seriesDoses", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization.Reaction parseImmunizationReaction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.Reaction.Builder builder = Immunization.Reaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 2, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "manifestation":
                    position = checkElementOrder("manifestation", 3, position, false);
                    builder.manifestation(parseCodeableReference("manifestation", reader, -1));
                    break;
                case "reported":
                    position = checkElementOrder("reported", 4, position, false);
                    builder.reported(parseBoolean("reported", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImmunizationEvaluation parseImmunizationEvaluation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImmunizationEvaluation.Builder builder = ImmunizationEvaluation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, doseStatusReasonElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ImmunizationEvaluationStatus) parseString(ImmunizationEvaluationStatus.builder(), "status", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 10, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 11, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 12, position, false);
                    builder.authority(parseReference("authority", reader, -1));
                    break;
                case "targetDisease":
                    position = checkElementOrder("targetDisease", 13, position, false);
                    builder.targetDisease(parseCodeableConcept("targetDisease", reader, -1));
                    break;
                case "immunizationEvent":
                    position = checkElementOrder("immunizationEvent", 14, position, false);
                    builder.immunizationEvent(parseReference("immunizationEvent", reader, -1));
                    break;
                case "doseStatus":
                    position = checkElementOrder("doseStatus", 15, position, false);
                    builder.doseStatus(parseCodeableConcept("doseStatus", reader, -1));
                    break;
                case "doseStatusReason":
                    position = checkElementOrder("doseStatusReason", 16, position, true);
                    builder.doseStatusReason(parseCodeableConcept("doseStatusReason", reader, doseStatusReasonElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 17, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "series":
                    position = checkElementOrder("series", 18, position, false);
                    builder.series(parseString("series", reader, -1));
                    break;
                case "doseNumber":
                    position = checkElementOrder("doseNumber", 19, position, false);
                    builder.doseNumber(parseString("doseNumber", reader, -1));
                    break;
                case "seriesDoses":
                    position = checkElementOrder("seriesDoses", 20, position, false);
                    builder.seriesDoses(parseString("seriesDoses", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImmunizationRecommendation parseImmunizationRecommendation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImmunizationRecommendation.Builder builder = ImmunizationRecommendation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, recommendationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 9, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 10, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 11, position, false);
                    builder.authority(parseReference("authority", reader, -1));
                    break;
                case "recommendation":
                    position = checkElementOrder("recommendation", 12, position, true);
                    builder.recommendation(parseImmunizationRecommendationRecommendation("recommendation", reader, recommendationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImmunizationRecommendation.Recommendation parseImmunizationRecommendationRecommendation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImmunizationRecommendation.Recommendation.Builder builder = ImmunizationRecommendation.Recommendation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, vaccineCodeElementIndex = 0, targetDiseaseElementIndex = 0, contraindicatedVaccineCodeElementIndex = 0, forecastReasonElementIndex = 0, dateCriterionElementIndex = 0, supportingImmunizationElementIndex = 0, supportingPatientInformationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "vaccineCode":
                    position = checkElementOrder("vaccineCode", 2, position, true);
                    builder.vaccineCode(parseCodeableConcept("vaccineCode", reader, vaccineCodeElementIndex++));
                    break;
                case "targetDisease":
                    position = checkElementOrder("targetDisease", 3, position, true);
                    builder.targetDisease(parseCodeableConcept("targetDisease", reader, targetDiseaseElementIndex++));
                    break;
                case "contraindicatedVaccineCode":
                    position = checkElementOrder("contraindicatedVaccineCode", 4, position, true);
                    builder.contraindicatedVaccineCode(parseCodeableConcept("contraindicatedVaccineCode", reader, contraindicatedVaccineCodeElementIndex++));
                    break;
                case "forecastStatus":
                    position = checkElementOrder("forecastStatus", 5, position, false);
                    builder.forecastStatus(parseCodeableConcept("forecastStatus", reader, -1));
                    break;
                case "forecastReason":
                    position = checkElementOrder("forecastReason", 6, position, true);
                    builder.forecastReason(parseCodeableConcept("forecastReason", reader, forecastReasonElementIndex++));
                    break;
                case "dateCriterion":
                    position = checkElementOrder("dateCriterion", 7, position, true);
                    builder.dateCriterion(parseImmunizationRecommendationRecommendationDateCriterion("dateCriterion", reader, dateCriterionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 8, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "series":
                    position = checkElementOrder("series", 9, position, false);
                    builder.series(parseString("series", reader, -1));
                    break;
                case "doseNumber":
                    position = checkElementOrder("doseNumber", 10, position, false);
                    builder.doseNumber(parseString("doseNumber", reader, -1));
                    break;
                case "seriesDoses":
                    position = checkElementOrder("seriesDoses", 11, position, false);
                    builder.seriesDoses(parseString("seriesDoses", reader, -1));
                    break;
                case "supportingImmunization":
                    position = checkElementOrder("supportingImmunization", 12, position, true);
                    builder.supportingImmunization(parseReference("supportingImmunization", reader, supportingImmunizationElementIndex++));
                    break;
                case "supportingPatientInformation":
                    position = checkElementOrder("supportingPatientInformation", 13, position, true);
                    builder.supportingPatientInformation(parseReference("supportingPatientInformation", reader, supportingPatientInformationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImmunizationRecommendation.Recommendation.DateCriterion parseImmunizationRecommendationRecommendationDateCriterion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImmunizationRecommendation.Recommendation.DateCriterion.Builder builder = ImmunizationRecommendation.Recommendation.DateCriterion.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseDateTime("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide parseImplementationGuide(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Builder builder = ImplementationGuide.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, fhirVersionElementIndex = 0, dependsOnElementIndex = 0, globalElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "packageId":
                    position = checkElementOrder("packageId", 25, position, false);
                    builder.packageId((Id) parseString(Id.builder(), "packageId", reader, -1));
                    break;
                case "license":
                    position = checkElementOrder("license", 26, position, false);
                    builder.license((SPDXLicense) parseString(SPDXLicense.builder(), "license", reader, -1));
                    break;
                case "fhirVersion":
                    position = checkElementOrder("fhirVersion", 27, position, true);
                    builder.fhirVersion((FHIRVersion) parseString(FHIRVersion.builder(), "fhirVersion", reader, fhirVersionElementIndex++));
                    break;
                case "dependsOn":
                    position = checkElementOrder("dependsOn", 28, position, true);
                    builder.dependsOn(parseImplementationGuideDependsOn("dependsOn", reader, dependsOnElementIndex++));
                    break;
                case "global":
                    position = checkElementOrder("global", 29, position, true);
                    builder.global(parseImplementationGuideGlobal("global", reader, globalElementIndex++));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 30, position, false);
                    builder.definition(parseImplementationGuideDefinition("definition", reader, -1));
                    break;
                case "manifest":
                    position = checkElementOrder("manifest", 31, position, false);
                    builder.manifest(parseImplementationGuideManifest("manifest", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition parseImplementationGuideDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Builder builder = ImplementationGuide.Definition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, groupingElementIndex = 0, resourceElementIndex = 0, parameterElementIndex = 0, templateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "grouping":
                    position = checkElementOrder("grouping", 2, position, true);
                    builder.grouping(parseImplementationGuideDefinitionGrouping("grouping", reader, groupingElementIndex++));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, true);
                    builder.resource(parseImplementationGuideDefinitionResource("resource", reader, resourceElementIndex++));
                    break;
                case "page":
                    position = checkElementOrder("page", 4, position, false);
                    builder.page(parseImplementationGuideDefinitionPage("page", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 5, position, true);
                    builder.parameter(parseImplementationGuideDefinitionParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "template":
                    position = checkElementOrder("template", 6, position, true);
                    builder.template(parseImplementationGuideDefinitionTemplate("template", reader, templateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Grouping parseImplementationGuideDefinitionGrouping(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Grouping.Builder builder = ImplementationGuide.Definition.Grouping.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Page parseImplementationGuideDefinitionPage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Page.Builder builder = ImplementationGuide.Definition.Page.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, pageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sourceUrl":
                    position = checkElementOrder("source[x]", 2, position, false);
                    builder.source((Url) parseUri(Url.builder(), "sourceUrl", reader, -1));
                    break;
                case "sourceString":
                    position = checkElementOrder("source[x]", 2, position, false);
                    builder.source(parseString("sourceString", reader, -1));
                    break;
                case "sourceMarkdown":
                    position = checkElementOrder("source[x]", 2, position, false);
                    builder.source((Markdown) parseString(Markdown.builder(), "sourceMarkdown", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name((Url) parseUri(Url.builder(), "name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 4, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "generation":
                    position = checkElementOrder("generation", 5, position, false);
                    builder.generation((GuidePageGeneration) parseString(GuidePageGeneration.builder(), "generation", reader, -1));
                    break;
                case "page":
                    position = checkElementOrder("page", 6, position, true);
                    builder.page(parseImplementationGuideDefinitionPage("page", reader, pageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Parameter parseImplementationGuideDefinitionParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Parameter.Builder builder = ImplementationGuide.Definition.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCoding("code", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Resource parseImplementationGuideDefinitionResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Resource.Builder builder = ImplementationGuide.Definition.Resource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, fhirVersionElementIndex = 0, profileElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                case "fhirVersion":
                    position = checkElementOrder("fhirVersion", 3, position, true);
                    builder.fhirVersion((FHIRVersion) parseString(FHIRVersion.builder(), "fhirVersion", reader, fhirVersionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "isExample":
                    position = checkElementOrder("isExample", 6, position, false);
                    builder.isExample(parseBoolean("isExample", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 7, position, true);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, profileElementIndex++));
                    break;
                case "groupingId":
                    position = checkElementOrder("groupingId", 8, position, false);
                    builder.groupingId((Id) parseString(Id.builder(), "groupingId", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Template parseImplementationGuideDefinitionTemplate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Template.Builder builder = ImplementationGuide.Definition.Template.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, false);
                    builder.source(parseString("source", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 4, position, false);
                    builder.scope(parseString("scope", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.DependsOn parseImplementationGuideDependsOn(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.DependsOn.Builder builder = ImplementationGuide.DependsOn.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 2, position, false);
                    builder.uri((Canonical) parseUri(Canonical.builder(), "uri", reader, -1));
                    break;
                case "packageId":
                    position = checkElementOrder("packageId", 3, position, false);
                    builder.packageId((Id) parseString(Id.builder(), "packageId", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 4, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 5, position, false);
                    builder.reason((Markdown) parseString(Markdown.builder(), "reason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Global parseImplementationGuideGlobal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Global.Builder builder = ImplementationGuide.Global.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "type", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Manifest parseImplementationGuideManifest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Manifest.Builder builder = ImplementationGuide.Manifest.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, resourceElementIndex = 0, pageElementIndex = 0, imageElementIndex = 0, otherElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "rendering":
                    position = checkElementOrder("rendering", 2, position, false);
                    builder.rendering((Url) parseUri(Url.builder(), "rendering", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, true);
                    builder.resource(parseImplementationGuideManifestResource("resource", reader, resourceElementIndex++));
                    break;
                case "page":
                    position = checkElementOrder("page", 4, position, true);
                    builder.page(parseImplementationGuideManifestPage("page", reader, pageElementIndex++));
                    break;
                case "image":
                    position = checkElementOrder("image", 5, position, true);
                    builder.image(parseString("image", reader, imageElementIndex++));
                    break;
                case "other":
                    position = checkElementOrder("other", 6, position, true);
                    builder.other(parseString("other", reader, otherElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Manifest.Page parseImplementationGuideManifestPage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Manifest.Page.Builder builder = ImplementationGuide.Manifest.Page.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, anchorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 3, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "anchor":
                    position = checkElementOrder("anchor", 4, position, true);
                    builder.anchor(parseString("anchor", reader, anchorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Manifest.Resource parseImplementationGuideManifestResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Manifest.Resource.Builder builder = ImplementationGuide.Manifest.Resource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, profileElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                case "isExample":
                    position = checkElementOrder("isExample", 3, position, false);
                    builder.isExample(parseBoolean("isExample", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 4, position, true);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, profileElementIndex++));
                    break;
                case "relativePath":
                    position = checkElementOrder("relativePath", 5, position, false);
                    builder.relativePath((Url) parseUri(Url.builder(), "relativePath", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient parseIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Builder builder = Ingredient.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, forElementIndex = 0, functionElementIndex = 0, manufacturerElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "for":
                    position = checkElementOrder("for", 10, position, true);
                    builder._for(parseReference("for", reader, forElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 11, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "function":
                    position = checkElementOrder("function", 12, position, true);
                    builder.function(parseCodeableConcept("function", reader, functionElementIndex++));
                    break;
                case "group":
                    position = checkElementOrder("group", 13, position, false);
                    builder.group(parseCodeableConcept("group", reader, -1));
                    break;
                case "allergenicIndicator":
                    position = checkElementOrder("allergenicIndicator", 14, position, false);
                    builder.allergenicIndicator(parseBoolean("allergenicIndicator", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 15, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 16, position, true);
                    builder.manufacturer(parseIngredientManufacturer("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "substance":
                    position = checkElementOrder("substance", 17, position, false);
                    builder.substance(parseIngredientSubstance("substance", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient.Manufacturer parseIngredientManufacturer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Manufacturer.Builder builder = Ingredient.Manufacturer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role((IngredientManufacturerRole) parseString(IngredientManufacturerRole.builder(), "role", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 3, position, false);
                    builder.manufacturer(parseReference("manufacturer", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient.Substance parseIngredientSubstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Substance.Builder builder = Ingredient.Substance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, strengthElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableReference("code", reader, -1));
                    break;
                case "strength":
                    position = checkElementOrder("strength", 3, position, true);
                    builder.strength(parseIngredientSubstanceStrength("strength", reader, strengthElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient.Substance.Strength parseIngredientSubstanceStrength(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Substance.Strength.Builder builder = Ingredient.Substance.Strength.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, countryElementIndex = 0, referenceStrengthElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "presentationRatio":
                    position = checkElementOrder("presentation[x]", 2, position, false);
                    builder.presentation(parseRatio("presentationRatio", reader, -1));
                    break;
                case "presentationRatioRange":
                    position = checkElementOrder("presentation[x]", 2, position, false);
                    builder.presentation(parseRatioRange("presentationRatioRange", reader, -1));
                    break;
                case "presentationCodeableConcept":
                    position = checkElementOrder("presentation[x]", 2, position, false);
                    builder.presentation(parseCodeableConcept("presentationCodeableConcept", reader, -1));
                    break;
                case "presentationQuantity":
                    position = checkElementOrder("presentation[x]", 2, position, false);
                    builder.presentation(parseQuantity("presentationQuantity", reader, -1));
                    break;
                case "textPresentation":
                    position = checkElementOrder("textPresentation", 3, position, false);
                    builder.textPresentation(parseString("textPresentation", reader, -1));
                    break;
                case "concentrationRatio":
                    position = checkElementOrder("concentration[x]", 4, position, false);
                    builder.concentration(parseRatio("concentrationRatio", reader, -1));
                    break;
                case "concentrationRatioRange":
                    position = checkElementOrder("concentration[x]", 4, position, false);
                    builder.concentration(parseRatioRange("concentrationRatioRange", reader, -1));
                    break;
                case "concentrationCodeableConcept":
                    position = checkElementOrder("concentration[x]", 4, position, false);
                    builder.concentration(parseCodeableConcept("concentrationCodeableConcept", reader, -1));
                    break;
                case "concentrationQuantity":
                    position = checkElementOrder("concentration[x]", 4, position, false);
                    builder.concentration(parseQuantity("concentrationQuantity", reader, -1));
                    break;
                case "textConcentration":
                    position = checkElementOrder("textConcentration", 5, position, false);
                    builder.textConcentration(parseString("textConcentration", reader, -1));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 6, position, false);
                    builder.basis(parseCodeableConcept("basis", reader, -1));
                    break;
                case "measurementPoint":
                    position = checkElementOrder("measurementPoint", 7, position, false);
                    builder.measurementPoint(parseString("measurementPoint", reader, -1));
                    break;
                case "country":
                    position = checkElementOrder("country", 8, position, true);
                    builder.country(parseCodeableConcept("country", reader, countryElementIndex++));
                    break;
                case "referenceStrength":
                    position = checkElementOrder("referenceStrength", 9, position, true);
                    builder.referenceStrength(parseIngredientSubstanceStrengthReferenceStrength("referenceStrength", reader, referenceStrengthElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient.Substance.Strength.ReferenceStrength parseIngredientSubstanceStrengthReferenceStrength(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Substance.Strength.ReferenceStrength.Builder builder = Ingredient.Substance.Strength.ReferenceStrength.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, countryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "substance":
                    position = checkElementOrder("substance", 2, position, false);
                    builder.substance(parseCodeableReference("substance", reader, -1));
                    break;
                case "strengthRatio":
                    position = checkElementOrder("strength[x]", 3, position, false);
                    builder.strength(parseRatio("strengthRatio", reader, -1));
                    break;
                case "strengthRatioRange":
                    position = checkElementOrder("strength[x]", 3, position, false);
                    builder.strength(parseRatioRange("strengthRatioRange", reader, -1));
                    break;
                case "strengthQuantity":
                    position = checkElementOrder("strength[x]", 3, position, false);
                    builder.strength(parseQuantity("strengthQuantity", reader, -1));
                    break;
                case "measurementPoint":
                    position = checkElementOrder("measurementPoint", 4, position, false);
                    builder.measurementPoint(parseString("measurementPoint", reader, -1));
                    break;
                case "country":
                    position = checkElementOrder("country", 5, position, true);
                    builder.country(parseCodeableConcept("country", reader, countryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Instant parseInstant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Instant.Builder builder = Instant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan parseInsurancePlan(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Builder builder = InsurancePlan.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, typeElementIndex = 0, aliasElementIndex = 0, coverageAreaElementIndex = 0, contactElementIndex = 0, endpointElementIndex = 0, networkElementIndex = 0, coverageElementIndex = 0, planElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 12, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 13, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "ownedBy":
                    position = checkElementOrder("ownedBy", 14, position, false);
                    builder.ownedBy(parseReference("ownedBy", reader, -1));
                    break;
                case "administeredBy":
                    position = checkElementOrder("administeredBy", 15, position, false);
                    builder.administeredBy(parseReference("administeredBy", reader, -1));
                    break;
                case "coverageArea":
                    position = checkElementOrder("coverageArea", 16, position, true);
                    builder.coverageArea(parseReference("coverageArea", reader, coverageAreaElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseExtendedContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 18, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                case "network":
                    position = checkElementOrder("network", 19, position, true);
                    builder.network(parseReference("network", reader, networkElementIndex++));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 20, position, true);
                    builder.coverage(parseInsurancePlanCoverage("coverage", reader, coverageElementIndex++));
                    break;
                case "plan":
                    position = checkElementOrder("plan", 21, position, true);
                    builder.plan(parseInsurancePlanPlan("plan", reader, planElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Coverage parseInsurancePlanCoverage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Coverage.Builder builder = InsurancePlan.Coverage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, networkElementIndex = 0, benefitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 3, position, true);
                    builder.network(parseReference("network", reader, networkElementIndex++));
                    break;
                case "benefit":
                    position = checkElementOrder("benefit", 4, position, true);
                    builder.benefit(parseInsurancePlanCoverageBenefit("benefit", reader, benefitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Coverage.Benefit parseInsurancePlanCoverageBenefit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Coverage.Benefit.Builder builder = InsurancePlan.Coverage.Benefit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, limitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 3, position, false);
                    builder.requirement(parseString("requirement", reader, -1));
                    break;
                case "limit":
                    position = checkElementOrder("limit", 4, position, true);
                    builder.limit(parseInsurancePlanCoverageBenefitLimit("limit", reader, limitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Coverage.Benefit.Limit parseInsurancePlanCoverageBenefitLimit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Coverage.Benefit.Limit.Builder builder = InsurancePlan.Coverage.Benefit.Limit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 2, position, false);
                    builder.value(parseQuantity("value", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan parseInsurancePlanPlan(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.Builder builder = InsurancePlan.Plan.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, coverageAreaElementIndex = 0, networkElementIndex = 0, generalCostElementIndex = 0, specificCostElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "coverageArea":
                    position = checkElementOrder("coverageArea", 4, position, true);
                    builder.coverageArea(parseReference("coverageArea", reader, coverageAreaElementIndex++));
                    break;
                case "network":
                    position = checkElementOrder("network", 5, position, true);
                    builder.network(parseReference("network", reader, networkElementIndex++));
                    break;
                case "generalCost":
                    position = checkElementOrder("generalCost", 6, position, true);
                    builder.generalCost(parseInsurancePlanPlanGeneralCost("generalCost", reader, generalCostElementIndex++));
                    break;
                case "specificCost":
                    position = checkElementOrder("specificCost", 7, position, true);
                    builder.specificCost(parseInsurancePlanPlanSpecificCost("specificCost", reader, specificCostElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan.GeneralCost parseInsurancePlanPlanGeneralCost(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.GeneralCost.Builder builder = InsurancePlan.Plan.GeneralCost.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "groupSize":
                    position = checkElementOrder("groupSize", 3, position, false);
                    builder.groupSize((PositiveInt) parseInteger(PositiveInt.builder(), "groupSize", reader, -1));
                    break;
                case "cost":
                    position = checkElementOrder("cost", 4, position, false);
                    builder.cost(parseMoney("cost", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 5, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan.SpecificCost parseInsurancePlanPlanSpecificCost(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.SpecificCost.Builder builder = InsurancePlan.Plan.SpecificCost.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, benefitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "benefit":
                    position = checkElementOrder("benefit", 3, position, true);
                    builder.benefit(parseInsurancePlanPlanSpecificCostBenefit("benefit", reader, benefitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan.SpecificCost.Benefit parseInsurancePlanPlanSpecificCostBenefit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.SpecificCost.Benefit.Builder builder = InsurancePlan.Plan.SpecificCost.Benefit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, costElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "cost":
                    position = checkElementOrder("cost", 3, position, true);
                    builder.cost(parseInsurancePlanPlanSpecificCostBenefitCost("cost", reader, costElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan.SpecificCost.Benefit.Cost parseInsurancePlanPlanSpecificCostBenefitCost(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.SpecificCost.Benefit.Cost.Builder builder = InsurancePlan.Plan.SpecificCost.Benefit.Cost.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, qualifiersElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "applicability":
                    position = checkElementOrder("applicability", 3, position, false);
                    builder.applicability(parseCodeableConcept("applicability", reader, -1));
                    break;
                case "qualifiers":
                    position = checkElementOrder("qualifiers", 4, position, true);
                    builder.qualifiers(parseCodeableConcept("qualifiers", reader, qualifiersElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value(parseQuantity("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Integer parseInteger(Integer.Builder builder, java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Integer parseInteger(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        return parseInteger(Integer.builder(), elementName, reader, elementIndex);
    }

    private Integer64 parseInteger64(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Integer64.Builder builder = Integer64.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryItem parseInventoryItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryItem.Builder builder = InventoryItem.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, codeElementIndex = 0, nameElementIndex = 0, responsibleOrganizationElementIndex = 0, inventoryStatusElementIndex = 0, associationElementIndex = 0, characteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((InventoryItemStatus) parseString(InventoryItemStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 11, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, true);
                    builder.name(parseInventoryItemName("name", reader, nameElementIndex++));
                    break;
                case "responsibleOrganization":
                    position = checkElementOrder("responsibleOrganization", 13, position, true);
                    builder.responsibleOrganization(parseInventoryItemResponsibleOrganization("responsibleOrganization", reader, responsibleOrganizationElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 14, position, false);
                    builder.description(parseInventoryItemDescription("description", reader, -1));
                    break;
                case "inventoryStatus":
                    position = checkElementOrder("inventoryStatus", 15, position, true);
                    builder.inventoryStatus(parseCodeableConcept("inventoryStatus", reader, inventoryStatusElementIndex++));
                    break;
                case "baseUnit":
                    position = checkElementOrder("baseUnit", 16, position, false);
                    builder.baseUnit(parseCodeableConcept("baseUnit", reader, -1));
                    break;
                case "netContent":
                    position = checkElementOrder("netContent", 17, position, false);
                    builder.netContent((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "netContent", reader, -1));
                    break;
                case "association":
                    position = checkElementOrder("association", 18, position, true);
                    builder.association(parseInventoryItemAssociation("association", reader, associationElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 19, position, true);
                    builder.characteristic(parseInventoryItemCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 20, position, false);
                    builder.instance(parseInventoryItemInstance("instance", reader, -1));
                    break;
                case "productReference":
                    position = checkElementOrder("productReference", 21, position, false);
                    builder.productReference(parseReference("productReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryItem.Association parseInventoryItemAssociation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryItem.Association.Builder builder = InventoryItem.Association.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "associationType":
                    position = checkElementOrder("associationType", 2, position, false);
                    builder.associationType(parseCodeableConcept("associationType", reader, -1));
                    break;
                case "relatedItem":
                    position = checkElementOrder("relatedItem", 3, position, false);
                    builder.relatedItem(parseReference("relatedItem", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 4, position, false);
                    builder.quantity(parseRatio("quantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryItem.Characteristic parseInventoryItemCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryItem.Characteristic.Builder builder = InventoryItem.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "characteristicType":
                    position = checkElementOrder("characteristicType", 2, position, false);
                    builder.characteristicType(parseCodeableConcept("characteristicType", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryItem.Description parseInventoryItemDescription(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryItem.Description.Builder builder = InventoryItem.Description.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language((ItemDescriptionLanguage) parseString(ItemDescriptionLanguage.builder(), "language", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryItem.Instance parseInventoryItemInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryItem.Instance.Builder builder = InventoryItem.Instance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "lotNumber":
                    position = checkElementOrder("lotNumber", 3, position, false);
                    builder.lotNumber(parseString("lotNumber", reader, -1));
                    break;
                case "expiry":
                    position = checkElementOrder("expiry", 4, position, false);
                    builder.expiry(parseDateTime("expiry", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 5, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 6, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryItem.Name parseInventoryItemName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryItem.Name.Builder builder = InventoryItem.Name.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "nameType":
                    position = checkElementOrder("nameType", 2, position, false);
                    builder.nameType(parseCoding("nameType", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((NameLanguage) parseString(NameLanguage.builder(), "language", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryItem.ResponsibleOrganization parseInventoryItemResponsibleOrganization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryItem.ResponsibleOrganization.Builder builder = InventoryItem.ResponsibleOrganization.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 3, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryReport parseInventoryReport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryReport.Builder builder = InventoryReport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, inventoryListingElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((InventoryReportStatus) parseString(InventoryReportStatus.builder(), "status", reader, -1));
                    break;
                case "countType":
                    position = checkElementOrder("countType", 10, position, false);
                    builder.countType((InventoryCountType) parseString(InventoryCountType.builder(), "countType", reader, -1));
                    break;
                case "operationType":
                    position = checkElementOrder("operationType", 11, position, false);
                    builder.operationType(parseCodeableConcept("operationType", reader, -1));
                    break;
                case "operationTypeReason":
                    position = checkElementOrder("operationTypeReason", 12, position, false);
                    builder.operationTypeReason(parseCodeableConcept("operationTypeReason", reader, -1));
                    break;
                case "reportedDateTime":
                    position = checkElementOrder("reportedDateTime", 13, position, false);
                    builder.reportedDateTime(parseDateTime("reportedDateTime", reader, -1));
                    break;
                case "reporter":
                    position = checkElementOrder("reporter", 14, position, false);
                    builder.reporter(parseReference("reporter", reader, -1));
                    break;
                case "reportingPeriod":
                    position = checkElementOrder("reportingPeriod", 15, position, false);
                    builder.reportingPeriod(parsePeriod("reportingPeriod", reader, -1));
                    break;
                case "inventoryListing":
                    position = checkElementOrder("inventoryListing", 16, position, true);
                    builder.inventoryListing(parseInventoryReportInventoryListing("inventoryListing", reader, inventoryListingElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 17, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryReport.InventoryListing parseInventoryReportInventoryListing(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryReport.InventoryListing.Builder builder = InventoryReport.InventoryListing.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 2, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "itemStatus":
                    position = checkElementOrder("itemStatus", 3, position, false);
                    builder.itemStatus(parseCodeableConcept("itemStatus", reader, -1));
                    break;
                case "countingDateTime":
                    position = checkElementOrder("countingDateTime", 4, position, false);
                    builder.countingDateTime(parseDateTime("countingDateTime", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 5, position, true);
                    builder.item(parseInventoryReportInventoryListingItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InventoryReport.InventoryListing.Item parseInventoryReportInventoryListingItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InventoryReport.InventoryListing.Item.Builder builder = InventoryReport.InventoryListing.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 3, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 4, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Invoice parseInvoice(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Invoice.Builder builder = Invoice.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, participantElementIndex = 0, lineItemElementIndex = 0, totalPriceComponentElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((InvoiceStatus) parseString(InvoiceStatus.builder(), "status", reader, -1));
                    break;
                case "cancelledReason":
                    position = checkElementOrder("cancelledReason", 10, position, false);
                    builder.cancelledReason(parseString("cancelledReason", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 13, position, false);
                    builder.recipient(parseReference("recipient", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "creation":
                    position = checkElementOrder("creation", 15, position, false);
                    builder.creation(parseDateTime("creation", reader, -1));
                    break;
                case "periodDate":
                    position = checkElementOrder("period[x]", 16, position, false);
                    builder.period(parseDate("periodDate", reader, -1));
                    break;
                case "periodPeriod":
                    position = checkElementOrder("period[x]", 16, position, false);
                    builder.period(parsePeriod("periodPeriod", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 17, position, true);
                    builder.participant(parseInvoiceParticipant("participant", reader, participantElementIndex++));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 18, position, false);
                    builder.issuer(parseReference("issuer", reader, -1));
                    break;
                case "account":
                    position = checkElementOrder("account", 19, position, false);
                    builder.account(parseReference("account", reader, -1));
                    break;
                case "lineItem":
                    position = checkElementOrder("lineItem", 20, position, true);
                    builder.lineItem(parseInvoiceLineItem("lineItem", reader, lineItemElementIndex++));
                    break;
                case "totalPriceComponent":
                    position = checkElementOrder("totalPriceComponent", 21, position, true);
                    builder.totalPriceComponent(parseMonetaryComponent("totalPriceComponent", reader, totalPriceComponentElementIndex++));
                    break;
                case "totalNet":
                    position = checkElementOrder("totalNet", 22, position, false);
                    builder.totalNet(parseMoney("totalNet", reader, -1));
                    break;
                case "totalGross":
                    position = checkElementOrder("totalGross", 23, position, false);
                    builder.totalGross(parseMoney("totalGross", reader, -1));
                    break;
                case "paymentTerms":
                    position = checkElementOrder("paymentTerms", 24, position, false);
                    builder.paymentTerms((Markdown) parseString(Markdown.builder(), "paymentTerms", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 25, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Invoice.LineItem parseInvoiceLineItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Invoice.LineItem.Builder builder = Invoice.LineItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, priceComponentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 3, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 3, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "chargeItemReference":
                    position = checkElementOrder("chargeItem[x]", 4, position, false);
                    builder.chargeItem(parseReference("chargeItemReference", reader, -1));
                    break;
                case "chargeItemCodeableConcept":
                    position = checkElementOrder("chargeItem[x]", 4, position, false);
                    builder.chargeItem(parseCodeableConcept("chargeItemCodeableConcept", reader, -1));
                    break;
                case "priceComponent":
                    position = checkElementOrder("priceComponent", 5, position, true);
                    builder.priceComponent(parseMonetaryComponent("priceComponent", reader, priceComponentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Invoice.Participant parseInvoiceParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Invoice.Participant.Builder builder = Invoice.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Library parseLibrary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Library.Builder builder = Library.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, parameterElementIndex = 0, dataRequirementElementIndex = 0, contentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 14, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 17, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 18, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 18, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 19, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 20, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 21, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 22, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 23, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 24, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 25, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 26, position, false);
                    builder.usage((Markdown) parseString(Markdown.builder(), "usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 27, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 28, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 29, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 30, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 31, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 32, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 33, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 34, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 35, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 36, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 37, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 38, position, true);
                    builder.parameter(parseParameterDefinition("parameter", reader, parameterElementIndex++));
                    break;
                case "dataRequirement":
                    position = checkElementOrder("dataRequirement", 39, position, true);
                    builder.dataRequirement(parseDataRequirement("dataRequirement", reader, dataRequirementElementIndex++));
                    break;
                case "content":
                    position = checkElementOrder("content", 40, position, true);
                    builder.content(parseAttachment("content", reader, contentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Linkage parseLinkage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Linkage.Builder builder = Linkage.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 8, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 9, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 10, position, true);
                    builder.item(parseLinkageItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Linkage.Item parseLinkageItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Linkage.Item.Builder builder = Linkage.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((LinkageType) parseString(LinkageType.builder(), "type", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, false);
                    builder.resource(parseReference("resource", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private List parseList(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        List.Builder builder = List.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, subjectElementIndex = 0, noteElementIndex = 0, entryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ListStatus) parseString(ListStatus.builder(), "status", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 10, position, false);
                    builder.mode((ListMode) parseString(ListMode.builder(), "mode", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 11, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 12, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 16, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                case "orderedBy":
                    position = checkElementOrder("orderedBy", 17, position, false);
                    builder.orderedBy(parseCodeableConcept("orderedBy", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 18, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "entry":
                    position = checkElementOrder("entry", 19, position, true);
                    builder.entry(parseListEntry("entry", reader, entryElementIndex++));
                    break;
                case "emptyReason":
                    position = checkElementOrder("emptyReason", 20, position, false);
                    builder.emptyReason(parseCodeableConcept("emptyReason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private List.Entry parseListEntry(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        List.Entry.Builder builder = List.Entry.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "flag":
                    position = checkElementOrder("flag", 2, position, false);
                    builder.flag(parseCodeableConcept("flag", reader, -1));
                    break;
                case "deleted":
                    position = checkElementOrder("deleted", 3, position, false);
                    builder.deleted(parseBoolean("deleted", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 4, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 5, position, false);
                    builder.item(parseReference("item", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Location parseLocation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Location.Builder builder = Location.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, aliasElementIndex = 0, typeElementIndex = 0, contactElementIndex = 0, characteristicElementIndex = 0, hoursOfOperationElementIndex = 0, virtualServiceElementIndex = 0, endpointElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((LocationStatus) parseString(LocationStatus.builder(), "status", reader, -1));
                    break;
                case "operationalStatus":
                    position = checkElementOrder("operationalStatus", 10, position, false);
                    builder.operationalStatus(parseCoding("operationalStatus", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 12, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 13, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 14, position, false);
                    builder.mode((LocationMode) parseString(LocationMode.builder(), "mode", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 15, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 16, position, true);
                    builder.contact(parseExtendedContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 17, position, false);
                    builder.address(parseAddress("address", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 18, position, false);
                    builder.form(parseCodeableConcept("form", reader, -1));
                    break;
                case "position":
                    position = checkElementOrder("position", 19, position, false);
                    builder.position(parseLocationPosition("position", reader, -1));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 20, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 21, position, false);
                    builder.partOf(parseReference("partOf", reader, -1));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 22, position, true);
                    builder.characteristic(parseCodeableConcept("characteristic", reader, characteristicElementIndex++));
                    break;
                case "hoursOfOperation":
                    position = checkElementOrder("hoursOfOperation", 23, position, true);
                    builder.hoursOfOperation(parseAvailability("hoursOfOperation", reader, hoursOfOperationElementIndex++));
                    break;
                case "virtualService":
                    position = checkElementOrder("virtualService", 24, position, true);
                    builder.virtualService(parseVirtualServiceDetail("virtualService", reader, virtualServiceElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 25, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Location.Position parseLocationPosition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Location.Position.Builder builder = Location.Position.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "longitude":
                    position = checkElementOrder("longitude", 2, position, false);
                    builder.longitude(parseDecimal("longitude", reader, -1));
                    break;
                case "latitude":
                    position = checkElementOrder("latitude", 3, position, false);
                    builder.latitude(parseDecimal("latitude", reader, -1));
                    break;
                case "altitude":
                    position = checkElementOrder("altitude", 4, position, false);
                    builder.altitude(parseDecimal("altitude", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ManufacturedItemDefinition parseManufacturedItemDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ManufacturedItemDefinition.Builder builder = ManufacturedItemDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, manufacturerElementIndex = 0, marketingStatusElementIndex = 0, ingredientElementIndex = 0, propertyElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "manufacturedDoseForm":
                    position = checkElementOrder("manufacturedDoseForm", 11, position, false);
                    builder.manufacturedDoseForm(parseCodeableConcept("manufacturedDoseForm", reader, -1));
                    break;
                case "unitOfPresentation":
                    position = checkElementOrder("unitOfPresentation", 12, position, false);
                    builder.unitOfPresentation(parseCodeableConcept("unitOfPresentation", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 13, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "marketingStatus":
                    position = checkElementOrder("marketingStatus", 14, position, true);
                    builder.marketingStatus(parseMarketingStatus("marketingStatus", reader, marketingStatusElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 15, position, true);
                    builder.ingredient(parseCodeableConcept("ingredient", reader, ingredientElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 16, position, true);
                    builder.property(parseManufacturedItemDefinitionProperty("property", reader, propertyElementIndex++));
                    break;
                case "component":
                    position = checkElementOrder("component", 17, position, true);
                    builder.component(parseManufacturedItemDefinitionComponent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ManufacturedItemDefinition.Component parseManufacturedItemDefinitionComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ManufacturedItemDefinition.Component.Builder builder = ManufacturedItemDefinition.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, functionElementIndex = 0, amountElementIndex = 0, constituentElementIndex = 0, propertyElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "function":
                    position = checkElementOrder("function", 3, position, true);
                    builder.function(parseCodeableConcept("function", reader, functionElementIndex++));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 4, position, true);
                    builder.amount(parseQuantity("amount", reader, amountElementIndex++));
                    break;
                case "constituent":
                    position = checkElementOrder("constituent", 5, position, true);
                    builder.constituent(parseManufacturedItemDefinitionComponentConstituent("constituent", reader, constituentElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 6, position, true);
                    builder.property(parseManufacturedItemDefinitionProperty("property", reader, propertyElementIndex++));
                    break;
                case "component":
                    position = checkElementOrder("component", 7, position, true);
                    builder.component(parseManufacturedItemDefinitionComponent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ManufacturedItemDefinition.Component.Constituent parseManufacturedItemDefinitionComponentConstituent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ManufacturedItemDefinition.Component.Constituent.Builder builder = ManufacturedItemDefinition.Component.Constituent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, amountElementIndex = 0, locationElementIndex = 0, functionElementIndex = 0, hasIngredientElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 2, position, true);
                    builder.amount(parseQuantity("amount", reader, amountElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 3, position, true);
                    builder.location(parseCodeableConcept("location", reader, locationElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 4, position, true);
                    builder.function(parseCodeableConcept("function", reader, functionElementIndex++));
                    break;
                case "hasIngredient":
                    position = checkElementOrder("hasIngredient", 5, position, true);
                    builder.hasIngredient(parseCodeableReference("hasIngredient", reader, hasIngredientElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ManufacturedItemDefinition.Property parseManufacturedItemDefinitionProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ManufacturedItemDefinition.Property.Builder builder = ManufacturedItemDefinition.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MarketingStatus parseMarketingStatus(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MarketingStatus.Builder builder = MarketingStatus.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "country":
                    position = checkElementOrder("country", 2, position, false);
                    builder.country(parseCodeableConcept("country", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 3, position, false);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 4, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "dateRange":
                    position = checkElementOrder("dateRange", 5, position, false);
                    builder.dateRange(parsePeriod("dateRange", reader, -1));
                    break;
                case "restoreDate":
                    position = checkElementOrder("restoreDate", 6, position, false);
                    builder.restoreDate(parseDateTime("restoreDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure parseMeasure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Builder builder = Measure.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, libraryElementIndex = 0, typeElementIndex = 0, termElementIndex = 0, groupElementIndex = 0, supplementalDataElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 14, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 18, position, false);
                    builder.basis((BasisType) parseString(BasisType.builder(), "basis", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 19, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 20, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 21, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 22, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 23, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 24, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 25, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 26, position, false);
                    builder.usage((Markdown) parseString(Markdown.builder(), "usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 27, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 28, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 29, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 30, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 31, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 32, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 33, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 34, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 35, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 36, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 37, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "library":
                    position = checkElementOrder("library", 38, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "disclaimer":
                    position = checkElementOrder("disclaimer", 39, position, false);
                    builder.disclaimer((Markdown) parseString(Markdown.builder(), "disclaimer", reader, -1));
                    break;
                case "scoring":
                    position = checkElementOrder("scoring", 40, position, false);
                    builder.scoring(parseCodeableConcept("scoring", reader, -1));
                    break;
                case "scoringUnit":
                    position = checkElementOrder("scoringUnit", 41, position, false);
                    builder.scoringUnit(parseCodeableConcept("scoringUnit", reader, -1));
                    break;
                case "compositeScoring":
                    position = checkElementOrder("compositeScoring", 42, position, false);
                    builder.compositeScoring(parseCodeableConcept("compositeScoring", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 43, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "riskAdjustment":
                    position = checkElementOrder("riskAdjustment", 44, position, false);
                    builder.riskAdjustment((Markdown) parseString(Markdown.builder(), "riskAdjustment", reader, -1));
                    break;
                case "rateAggregation":
                    position = checkElementOrder("rateAggregation", 45, position, false);
                    builder.rateAggregation((Markdown) parseString(Markdown.builder(), "rateAggregation", reader, -1));
                    break;
                case "rationale":
                    position = checkElementOrder("rationale", 46, position, false);
                    builder.rationale((Markdown) parseString(Markdown.builder(), "rationale", reader, -1));
                    break;
                case "clinicalRecommendationStatement":
                    position = checkElementOrder("clinicalRecommendationStatement", 47, position, false);
                    builder.clinicalRecommendationStatement((Markdown) parseString(Markdown.builder(), "clinicalRecommendationStatement", reader, -1));
                    break;
                case "improvementNotation":
                    position = checkElementOrder("improvementNotation", 48, position, false);
                    builder.improvementNotation(parseCodeableConcept("improvementNotation", reader, -1));
                    break;
                case "term":
                    position = checkElementOrder("term", 49, position, true);
                    builder.term(parseMeasureTerm("term", reader, termElementIndex++));
                    break;
                case "guidance":
                    position = checkElementOrder("guidance", 50, position, false);
                    builder.guidance((Markdown) parseString(Markdown.builder(), "guidance", reader, -1));
                    break;
                case "group":
                    position = checkElementOrder("group", 51, position, true);
                    builder.group(parseMeasureGroup("group", reader, groupElementIndex++));
                    break;
                case "supplementalData":
                    position = checkElementOrder("supplementalData", 52, position, true);
                    builder.supplementalData(parseMeasureSupplementalData("supplementalData", reader, supplementalDataElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.Group parseMeasureGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Group.Builder builder = Measure.Group.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, libraryElementIndex = 0, populationElementIndex = 0, stratifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 6, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 6, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 7, position, false);
                    builder.basis((BasisType) parseString(BasisType.builder(), "basis", reader, -1));
                    break;
                case "scoring":
                    position = checkElementOrder("scoring", 8, position, false);
                    builder.scoring(parseCodeableConcept("scoring", reader, -1));
                    break;
                case "scoringUnit":
                    position = checkElementOrder("scoringUnit", 9, position, false);
                    builder.scoringUnit(parseCodeableConcept("scoringUnit", reader, -1));
                    break;
                case "rateAggregation":
                    position = checkElementOrder("rateAggregation", 10, position, false);
                    builder.rateAggregation((Markdown) parseString(Markdown.builder(), "rateAggregation", reader, -1));
                    break;
                case "improvementNotation":
                    position = checkElementOrder("improvementNotation", 11, position, false);
                    builder.improvementNotation(parseCodeableConcept("improvementNotation", reader, -1));
                    break;
                case "library":
                    position = checkElementOrder("library", 12, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "population":
                    position = checkElementOrder("population", 13, position, true);
                    builder.population(parseMeasureGroupPopulation("population", reader, populationElementIndex++));
                    break;
                case "stratifier":
                    position = checkElementOrder("stratifier", 14, position, true);
                    builder.stratifier(parseMeasureGroupStratifier("stratifier", reader, stratifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.Group.Population parseMeasureGroupPopulation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Group.Population.Builder builder = Measure.Group.Population.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "criteria":
                    position = checkElementOrder("criteria", 5, position, false);
                    builder.criteria(parseExpression("criteria", reader, -1));
                    break;
                case "groupDefinition":
                    position = checkElementOrder("groupDefinition", 6, position, false);
                    builder.groupDefinition(parseReference("groupDefinition", reader, -1));
                    break;
                case "inputPopulationId":
                    position = checkElementOrder("inputPopulationId", 7, position, false);
                    builder.inputPopulationId(parseString("inputPopulationId", reader, -1));
                    break;
                case "aggregateMethod":
                    position = checkElementOrder("aggregateMethod", 8, position, false);
                    builder.aggregateMethod(parseCodeableConcept("aggregateMethod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.Group.Stratifier parseMeasureGroupStratifier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Group.Stratifier.Builder builder = Measure.Group.Stratifier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "criteria":
                    position = checkElementOrder("criteria", 5, position, false);
                    builder.criteria(parseExpression("criteria", reader, -1));
                    break;
                case "groupDefinition":
                    position = checkElementOrder("groupDefinition", 6, position, false);
                    builder.groupDefinition(parseReference("groupDefinition", reader, -1));
                    break;
                case "component":
                    position = checkElementOrder("component", 7, position, true);
                    builder.component(parseMeasureGroupStratifierComponent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.Group.Stratifier.Component parseMeasureGroupStratifierComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Group.Stratifier.Component.Builder builder = Measure.Group.Stratifier.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "criteria":
                    position = checkElementOrder("criteria", 5, position, false);
                    builder.criteria(parseExpression("criteria", reader, -1));
                    break;
                case "groupDefinition":
                    position = checkElementOrder("groupDefinition", 6, position, false);
                    builder.groupDefinition(parseReference("groupDefinition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.SupplementalData parseMeasureSupplementalData(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.SupplementalData.Builder builder = Measure.SupplementalData.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, usageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 4, position, true);
                    builder.usage(parseCodeableConcept("usage", reader, usageElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "criteria":
                    position = checkElementOrder("criteria", 6, position, false);
                    builder.criteria(parseExpression("criteria", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.Term parseMeasureTerm(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Term.Builder builder = Measure.Term.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition((Markdown) parseString(Markdown.builder(), "definition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport parseMeasureReport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Builder builder = MeasureReport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, groupElementIndex = 0, supplementalDataElementIndex = 0, evaluatedResourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((MeasureReportStatus) parseString(MeasureReportStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type((MeasureReportType) parseString(MeasureReportType.builder(), "type", reader, -1));
                    break;
                case "dataUpdateType":
                    position = checkElementOrder("dataUpdateType", 11, position, false);
                    builder.dataUpdateType((SubmitDataUpdateType) parseString(SubmitDataUpdateType.builder(), "dataUpdateType", reader, -1));
                    break;
                case "measure":
                    position = checkElementOrder("measure", 12, position, false);
                    builder.measure((Canonical) parseUri(Canonical.builder(), "measure", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "reporter":
                    position = checkElementOrder("reporter", 15, position, false);
                    builder.reporter(parseReference("reporter", reader, -1));
                    break;
                case "reportingVendor":
                    position = checkElementOrder("reportingVendor", 16, position, false);
                    builder.reportingVendor(parseReference("reportingVendor", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 17, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 18, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "inputParameters":
                    position = checkElementOrder("inputParameters", 19, position, false);
                    builder.inputParameters(parseReference("inputParameters", reader, -1));
                    break;
                case "scoring":
                    position = checkElementOrder("scoring", 20, position, false);
                    builder.scoring(parseCodeableConcept("scoring", reader, -1));
                    break;
                case "improvementNotation":
                    position = checkElementOrder("improvementNotation", 21, position, false);
                    builder.improvementNotation(parseCodeableConcept("improvementNotation", reader, -1));
                    break;
                case "group":
                    position = checkElementOrder("group", 22, position, true);
                    builder.group(parseMeasureReportGroup("group", reader, groupElementIndex++));
                    break;
                case "supplementalData":
                    position = checkElementOrder("supplementalData", 23, position, true);
                    builder.supplementalData(parseReference("supplementalData", reader, supplementalDataElementIndex++));
                    break;
                case "evaluatedResource":
                    position = checkElementOrder("evaluatedResource", 24, position, true);
                    builder.evaluatedResource(parseReference("evaluatedResource", reader, evaluatedResourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group parseMeasureReportGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Builder builder = MeasureReport.Group.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, populationElementIndex = 0, stratifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 4, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "population":
                    position = checkElementOrder("population", 5, position, true);
                    builder.population(parseMeasureReportGroupPopulation("population", reader, populationElementIndex++));
                    break;
                case "measureScoreQuantity":
                    position = checkElementOrder("measureScore[x]", 6, position, false);
                    builder.measureScore(parseQuantity("measureScoreQuantity", reader, -1));
                    break;
                case "measureScoreDateTime":
                    position = checkElementOrder("measureScore[x]", 6, position, false);
                    builder.measureScore(parseDateTime("measureScoreDateTime", reader, -1));
                    break;
                case "measureScoreCodeableConcept":
                    position = checkElementOrder("measureScore[x]", 6, position, false);
                    builder.measureScore(parseCodeableConcept("measureScoreCodeableConcept", reader, -1));
                    break;
                case "measureScorePeriod":
                    position = checkElementOrder("measureScore[x]", 6, position, false);
                    builder.measureScore(parsePeriod("measureScorePeriod", reader, -1));
                    break;
                case "measureScoreRange":
                    position = checkElementOrder("measureScore[x]", 6, position, false);
                    builder.measureScore(parseRange("measureScoreRange", reader, -1));
                    break;
                case "measureScoreDuration":
                    position = checkElementOrder("measureScore[x]", 6, position, false);
                    builder.measureScore((Duration) parseQuantity(Duration.builder(), "measureScoreDuration", reader, -1));
                    break;
                case "stratifier":
                    position = checkElementOrder("stratifier", 7, position, true);
                    builder.stratifier(parseMeasureReportGroupStratifier("stratifier", reader, stratifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Population parseMeasureReportGroupPopulation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Population.Builder builder = MeasureReport.Group.Population.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, subjectReportElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 4, position, false);
                    builder.count(parseInteger("count", reader, -1));
                    break;
                case "subjectResults":
                    position = checkElementOrder("subjectResults", 5, position, false);
                    builder.subjectResults(parseReference("subjectResults", reader, -1));
                    break;
                case "subjectReport":
                    position = checkElementOrder("subjectReport", 6, position, true);
                    builder.subjectReport(parseReference("subjectReport", reader, subjectReportElementIndex++));
                    break;
                case "subjects":
                    position = checkElementOrder("subjects", 7, position, false);
                    builder.subjects(parseReference("subjects", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Stratifier parseMeasureReportGroupStratifier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Stratifier.Builder builder = MeasureReport.Group.Stratifier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, stratumElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "stratum":
                    position = checkElementOrder("stratum", 4, position, true);
                    builder.stratum(parseMeasureReportGroupStratifierStratum("stratum", reader, stratumElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Stratifier.Stratum parseMeasureReportGroupStratifierStratum(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Stratifier.Stratum.Builder builder = MeasureReport.Group.Stratifier.Stratum.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, componentElementIndex = 0, populationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "component":
                    position = checkElementOrder("component", 3, position, true);
                    builder.component(parseMeasureReportGroupStratifierStratumComponent("component", reader, componentElementIndex++));
                    break;
                case "population":
                    position = checkElementOrder("population", 4, position, true);
                    builder.population(parseMeasureReportGroupStratifierStratumPopulation("population", reader, populationElementIndex++));
                    break;
                case "measureScoreQuantity":
                    position = checkElementOrder("measureScore[x]", 5, position, false);
                    builder.measureScore(parseQuantity("measureScoreQuantity", reader, -1));
                    break;
                case "measureScoreDateTime":
                    position = checkElementOrder("measureScore[x]", 5, position, false);
                    builder.measureScore(parseDateTime("measureScoreDateTime", reader, -1));
                    break;
                case "measureScoreCodeableConcept":
                    position = checkElementOrder("measureScore[x]", 5, position, false);
                    builder.measureScore(parseCodeableConcept("measureScoreCodeableConcept", reader, -1));
                    break;
                case "measureScorePeriod":
                    position = checkElementOrder("measureScore[x]", 5, position, false);
                    builder.measureScore(parsePeriod("measureScorePeriod", reader, -1));
                    break;
                case "measureScoreRange":
                    position = checkElementOrder("measureScore[x]", 5, position, false);
                    builder.measureScore(parseRange("measureScoreRange", reader, -1));
                    break;
                case "measureScoreDuration":
                    position = checkElementOrder("measureScore[x]", 5, position, false);
                    builder.measureScore((Duration) parseQuantity(Duration.builder(), "measureScoreDuration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Stratifier.Stratum.Component parseMeasureReportGroupStratifierStratumComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Stratifier.Stratum.Component.Builder builder = MeasureReport.Group.Stratifier.Stratum.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Stratifier.Stratum.Population parseMeasureReportGroupStratifierStratumPopulation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Stratifier.Stratum.Population.Builder builder = MeasureReport.Group.Stratifier.Stratum.Population.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, subjectReportElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 4, position, false);
                    builder.count(parseInteger("count", reader, -1));
                    break;
                case "subjectResults":
                    position = checkElementOrder("subjectResults", 5, position, false);
                    builder.subjectResults(parseReference("subjectResults", reader, -1));
                    break;
                case "subjectReport":
                    position = checkElementOrder("subjectReport", 6, position, true);
                    builder.subjectReport(parseReference("subjectReport", reader, subjectReportElementIndex++));
                    break;
                case "subjects":
                    position = checkElementOrder("subjects", 7, position, false);
                    builder.subjects(parseReference("subjects", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Medication parseMedication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Medication.Builder builder = Medication.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, ingredientElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((MedicationStatus) parseString(MedicationStatus.builder(), "status", reader, -1));
                    break;
                case "marketingAuthorizationHolder":
                    position = checkElementOrder("marketingAuthorizationHolder", 11, position, false);
                    builder.marketingAuthorizationHolder(parseReference("marketingAuthorizationHolder", reader, -1));
                    break;
                case "doseForm":
                    position = checkElementOrder("doseForm", 12, position, false);
                    builder.doseForm(parseCodeableConcept("doseForm", reader, -1));
                    break;
                case "totalVolume":
                    position = checkElementOrder("totalVolume", 13, position, false);
                    builder.totalVolume(parseQuantity("totalVolume", reader, -1));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 14, position, true);
                    builder.ingredient(parseMedicationIngredient("ingredient", reader, ingredientElementIndex++));
                    break;
                case "batch":
                    position = checkElementOrder("batch", 15, position, false);
                    builder.batch(parseMedicationBatch("batch", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 16, position, false);
                    builder.definition(parseReference("definition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Medication.Batch parseMedicationBatch(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Medication.Batch.Builder builder = Medication.Batch.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "lotNumber":
                    position = checkElementOrder("lotNumber", 2, position, false);
                    builder.lotNumber(parseString("lotNumber", reader, -1));
                    break;
                case "expirationDate":
                    position = checkElementOrder("expirationDate", 3, position, false);
                    builder.expirationDate(parseDateTime("expirationDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Medication.Ingredient parseMedicationIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Medication.Ingredient.Builder builder = Medication.Ingredient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 2, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "isActive":
                    position = checkElementOrder("isActive", 3, position, false);
                    builder.isActive(parseBoolean("isActive", reader, -1));
                    break;
                case "strengthRatio":
                    position = checkElementOrder("strength[x]", 4, position, false);
                    builder.strength(parseRatio("strengthRatio", reader, -1));
                    break;
                case "strengthCodeableConcept":
                    position = checkElementOrder("strength[x]", 4, position, false);
                    builder.strength(parseCodeableConcept("strengthCodeableConcept", reader, -1));
                    break;
                case "strengthQuantity":
                    position = checkElementOrder("strength[x]", 4, position, false);
                    builder.strength(parseQuantity("strengthQuantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationAdministration parseMedicationAdministration(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationAdministration.Builder builder = MedicationAdministration.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, statusReasonElementIndex = 0, categoryElementIndex = 0, supportingInformationElementIndex = 0, subPotentReasonElementIndex = 0, performerElementIndex = 0, reasonElementIndex = 0, deviceElementIndex = 0, noteElementIndex = 0, eventHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((MedicationAdministrationStatus) parseString(MedicationAdministrationStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 12, position, true);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, statusReasonElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 13, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "medication":
                    position = checkElementOrder("medication", 14, position, false);
                    builder.medication(parseCodeableReference("medication", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 15, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 16, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 17, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "occurenceDateTime":
                    position = checkElementOrder("occurence[x]", 18, position, false);
                    builder.occurence(parseDateTime("occurenceDateTime", reader, -1));
                    break;
                case "occurencePeriod":
                    position = checkElementOrder("occurence[x]", 18, position, false);
                    builder.occurence(parsePeriod("occurencePeriod", reader, -1));
                    break;
                case "occurenceTiming":
                    position = checkElementOrder("occurence[x]", 18, position, false);
                    builder.occurence(parseTiming("occurenceTiming", reader, -1));
                    break;
                case "recorded":
                    position = checkElementOrder("recorded", 19, position, false);
                    builder.recorded(parseDateTime("recorded", reader, -1));
                    break;
                case "isSubPotent":
                    position = checkElementOrder("isSubPotent", 20, position, false);
                    builder.isSubPotent(parseBoolean("isSubPotent", reader, -1));
                    break;
                case "subPotentReason":
                    position = checkElementOrder("subPotentReason", 21, position, true);
                    builder.subPotentReason(parseCodeableConcept("subPotentReason", reader, subPotentReasonElementIndex++));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 22, position, true);
                    builder.performer(parseMedicationAdministrationPerformer("performer", reader, performerElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 23, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "request":
                    position = checkElementOrder("request", 24, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 25, position, true);
                    builder.device(parseCodeableReference("device", reader, deviceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 26, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 27, position, false);
                    builder.dosage(parseMedicationAdministrationDosage("dosage", reader, -1));
                    break;
                case "eventHistory":
                    position = checkElementOrder("eventHistory", 28, position, true);
                    builder.eventHistory(parseReference("eventHistory", reader, eventHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationAdministration.Dosage parseMedicationAdministrationDosage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationAdministration.Dosage.Builder builder = MedicationAdministration.Dosage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 2, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "site":
                    position = checkElementOrder("site", 3, position, false);
                    builder.site(parseCodeableConcept("site", reader, -1));
                    break;
                case "route":
                    position = checkElementOrder("route", 4, position, false);
                    builder.route(parseCodeableConcept("route", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 5, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "dose":
                    position = checkElementOrder("dose", 6, position, false);
                    builder.dose((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "dose", reader, -1));
                    break;
                case "rateRatio":
                    position = checkElementOrder("rate[x]", 7, position, false);
                    builder.rate(parseRatio("rateRatio", reader, -1));
                    break;
                case "rateQuantity":
                    position = checkElementOrder("rate[x]", 7, position, false);
                    builder.rate((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "rateQuantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationAdministration.Performer parseMedicationAdministrationPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationAdministration.Performer.Builder builder = MedicationAdministration.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseCodeableReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationDispense parseMedicationDispense(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationDispense.Builder builder = MedicationDispense.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, categoryElementIndex = 0, supportingInformationElementIndex = 0, performerElementIndex = 0, authorizingPrescriptionElementIndex = 0, receiverElementIndex = 0, noteElementIndex = 0, dosageInstructionElementIndex = 0, eventHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((MedicationDispenseStatus) parseString(MedicationDispenseStatus.builder(), "status", reader, -1));
                    break;
                case "notPerformedReason":
                    position = checkElementOrder("notPerformedReason", 12, position, false);
                    builder.notPerformedReason(parseCodeableReference("notPerformedReason", reader, -1));
                    break;
                case "statusChanged":
                    position = checkElementOrder("statusChanged", 13, position, false);
                    builder.statusChanged(parseDateTime("statusChanged", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 14, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "medication":
                    position = checkElementOrder("medication", 15, position, false);
                    builder.medication(parseCodeableReference("medication", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 16, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 17, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 18, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 19, position, true);
                    builder.performer(parseMedicationDispensePerformer("performer", reader, performerElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 20, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "authorizingPrescription":
                    position = checkElementOrder("authorizingPrescription", 21, position, true);
                    builder.authorizingPrescription(parseReference("authorizingPrescription", reader, authorizingPrescriptionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 22, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 23, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "daysSupply":
                    position = checkElementOrder("daysSupply", 24, position, false);
                    builder.daysSupply((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "daysSupply", reader, -1));
                    break;
                case "recorded":
                    position = checkElementOrder("recorded", 25, position, false);
                    builder.recorded(parseDateTime("recorded", reader, -1));
                    break;
                case "whenPrepared":
                    position = checkElementOrder("whenPrepared", 26, position, false);
                    builder.whenPrepared(parseDateTime("whenPrepared", reader, -1));
                    break;
                case "whenHandedOver":
                    position = checkElementOrder("whenHandedOver", 27, position, false);
                    builder.whenHandedOver(parseDateTime("whenHandedOver", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 28, position, false);
                    builder.destination(parseReference("destination", reader, -1));
                    break;
                case "receiver":
                    position = checkElementOrder("receiver", 29, position, true);
                    builder.receiver(parseReference("receiver", reader, receiverElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 30, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "renderedDosageInstruction":
                    position = checkElementOrder("renderedDosageInstruction", 31, position, false);
                    builder.renderedDosageInstruction((Markdown) parseString(Markdown.builder(), "renderedDosageInstruction", reader, -1));
                    break;
                case "dosageInstruction":
                    position = checkElementOrder("dosageInstruction", 32, position, true);
                    builder.dosageInstruction(parseDosage("dosageInstruction", reader, dosageInstructionElementIndex++));
                    break;
                case "substitution":
                    position = checkElementOrder("substitution", 33, position, false);
                    builder.substitution(parseMedicationDispenseSubstitution("substitution", reader, -1));
                    break;
                case "eventHistory":
                    position = checkElementOrder("eventHistory", 34, position, true);
                    builder.eventHistory(parseReference("eventHistory", reader, eventHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationDispense.Performer parseMedicationDispensePerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationDispense.Performer.Builder builder = MedicationDispense.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationDispense.Substitution parseMedicationDispenseSubstitution(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationDispense.Substitution.Builder builder = MedicationDispense.Substitution.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, reasonElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "wasSubstituted":
                    position = checkElementOrder("wasSubstituted", 2, position, false);
                    builder.wasSubstituted(parseBoolean("wasSubstituted", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 4, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                case "responsibleParty":
                    position = checkElementOrder("responsibleParty", 5, position, false);
                    builder.responsibleParty(parseReference("responsibleParty", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge parseMedicationKnowledge(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Builder builder = MedicationKnowledge.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, intendedJurisdictionElementIndex = 0, nameElementIndex = 0, relatedMedicationKnowledgeElementIndex = 0, associatedMedicationElementIndex = 0, productTypeElementIndex = 0, monographElementIndex = 0, costElementIndex = 0, monitoringProgramElementIndex = 0, indicationGuidelineElementIndex = 0, medicineClassificationElementIndex = 0, packagingElementIndex = 0, clinicalUseIssueElementIndex = 0, storageGuidelineElementIndex = 0, regulatoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((MedicationKnowledgeStatus) parseString(MedicationKnowledgeStatus.builder(), "status", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 11, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "intendedJurisdiction":
                    position = checkElementOrder("intendedJurisdiction", 12, position, true);
                    builder.intendedJurisdiction(parseCodeableConcept("intendedJurisdiction", reader, intendedJurisdictionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 13, position, true);
                    builder.name(parseString("name", reader, nameElementIndex++));
                    break;
                case "relatedMedicationKnowledge":
                    position = checkElementOrder("relatedMedicationKnowledge", 14, position, true);
                    builder.relatedMedicationKnowledge(parseMedicationKnowledgeRelatedMedicationKnowledge("relatedMedicationKnowledge", reader, relatedMedicationKnowledgeElementIndex++));
                    break;
                case "associatedMedication":
                    position = checkElementOrder("associatedMedication", 15, position, true);
                    builder.associatedMedication(parseReference("associatedMedication", reader, associatedMedicationElementIndex++));
                    break;
                case "productType":
                    position = checkElementOrder("productType", 16, position, true);
                    builder.productType(parseCodeableConcept("productType", reader, productTypeElementIndex++));
                    break;
                case "monograph":
                    position = checkElementOrder("monograph", 17, position, true);
                    builder.monograph(parseMedicationKnowledgeMonograph("monograph", reader, monographElementIndex++));
                    break;
                case "preparationInstruction":
                    position = checkElementOrder("preparationInstruction", 18, position, false);
                    builder.preparationInstruction((Markdown) parseString(Markdown.builder(), "preparationInstruction", reader, -1));
                    break;
                case "cost":
                    position = checkElementOrder("cost", 19, position, true);
                    builder.cost(parseMedicationKnowledgeCost("cost", reader, costElementIndex++));
                    break;
                case "monitoringProgram":
                    position = checkElementOrder("monitoringProgram", 20, position, true);
                    builder.monitoringProgram(parseMedicationKnowledgeMonitoringProgram("monitoringProgram", reader, monitoringProgramElementIndex++));
                    break;
                case "indicationGuideline":
                    position = checkElementOrder("indicationGuideline", 21, position, true);
                    builder.indicationGuideline(parseMedicationKnowledgeIndicationGuideline("indicationGuideline", reader, indicationGuidelineElementIndex++));
                    break;
                case "medicineClassification":
                    position = checkElementOrder("medicineClassification", 22, position, true);
                    builder.medicineClassification(parseMedicationKnowledgeMedicineClassification("medicineClassification", reader, medicineClassificationElementIndex++));
                    break;
                case "packaging":
                    position = checkElementOrder("packaging", 23, position, true);
                    builder.packaging(parseMedicationKnowledgePackaging("packaging", reader, packagingElementIndex++));
                    break;
                case "clinicalUseIssue":
                    position = checkElementOrder("clinicalUseIssue", 24, position, true);
                    builder.clinicalUseIssue(parseReference("clinicalUseIssue", reader, clinicalUseIssueElementIndex++));
                    break;
                case "storageGuideline":
                    position = checkElementOrder("storageGuideline", 25, position, true);
                    builder.storageGuideline(parseMedicationKnowledgeStorageGuideline("storageGuideline", reader, storageGuidelineElementIndex++));
                    break;
                case "regulatory":
                    position = checkElementOrder("regulatory", 26, position, true);
                    builder.regulatory(parseMedicationKnowledgeRegulatory("regulatory", reader, regulatoryElementIndex++));
                    break;
                case "definitional":
                    position = checkElementOrder("definitional", 27, position, false);
                    builder.definitional(parseMedicationKnowledgeDefinitional("definitional", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Cost parseMedicationKnowledgeCost(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Cost.Builder builder = MedicationKnowledge.Cost.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, effectiveDateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "effectiveDate":
                    position = checkElementOrder("effectiveDate", 2, position, true);
                    builder.effectiveDate(parsePeriod("effectiveDate", reader, effectiveDateElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 4, position, false);
                    builder.source(parseString("source", reader, -1));
                    break;
                case "costMoney":
                    position = checkElementOrder("cost[x]", 5, position, false);
                    builder.cost(parseMoney("costMoney", reader, -1));
                    break;
                case "costCodeableConcept":
                    position = checkElementOrder("cost[x]", 5, position, false);
                    builder.cost(parseCodeableConcept("costCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Definitional parseMedicationKnowledgeDefinitional(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Definitional.Builder builder = MedicationKnowledge.Definitional.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, definitionElementIndex = 0, intendedRouteElementIndex = 0, ingredientElementIndex = 0, drugCharacteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 2, position, true);
                    builder.definition(parseReference("definition", reader, definitionElementIndex++));
                    break;
                case "doseForm":
                    position = checkElementOrder("doseForm", 3, position, false);
                    builder.doseForm(parseCodeableConcept("doseForm", reader, -1));
                    break;
                case "intendedRoute":
                    position = checkElementOrder("intendedRoute", 4, position, true);
                    builder.intendedRoute(parseCodeableConcept("intendedRoute", reader, intendedRouteElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 5, position, true);
                    builder.ingredient(parseMedicationKnowledgeDefinitionalIngredient("ingredient", reader, ingredientElementIndex++));
                    break;
                case "drugCharacteristic":
                    position = checkElementOrder("drugCharacteristic", 6, position, true);
                    builder.drugCharacteristic(parseMedicationKnowledgeDefinitionalDrugCharacteristic("drugCharacteristic", reader, drugCharacteristicElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Definitional.DrugCharacteristic parseMedicationKnowledgeDefinitionalDrugCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Definitional.DrugCharacteristic.Builder builder = MedicationKnowledge.Definitional.DrugCharacteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "valueQuantity", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Definitional.Ingredient parseMedicationKnowledgeDefinitionalIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Definitional.Ingredient.Builder builder = MedicationKnowledge.Definitional.Ingredient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 2, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "strengthRatio":
                    position = checkElementOrder("strength[x]", 4, position, false);
                    builder.strength(parseRatio("strengthRatio", reader, -1));
                    break;
                case "strengthCodeableConcept":
                    position = checkElementOrder("strength[x]", 4, position, false);
                    builder.strength(parseCodeableConcept("strengthCodeableConcept", reader, -1));
                    break;
                case "strengthQuantity":
                    position = checkElementOrder("strength[x]", 4, position, false);
                    builder.strength(parseQuantity("strengthQuantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.IndicationGuideline parseMedicationKnowledgeIndicationGuideline(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.IndicationGuideline.Builder builder = MedicationKnowledge.IndicationGuideline.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, indicationElementIndex = 0, dosingGuidelineElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 2, position, true);
                    builder.indication(parseCodeableReference("indication", reader, indicationElementIndex++));
                    break;
                case "dosingGuideline":
                    position = checkElementOrder("dosingGuideline", 3, position, true);
                    builder.dosingGuideline(parseMedicationKnowledgeIndicationGuidelineDosingGuideline("dosingGuideline", reader, dosingGuidelineElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.IndicationGuideline.DosingGuideline parseMedicationKnowledgeIndicationGuidelineDosingGuideline(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.IndicationGuideline.DosingGuideline.Builder builder = MedicationKnowledge.IndicationGuideline.DosingGuideline.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dosageElementIndex = 0, patientCharacteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "treatmentIntent":
                    position = checkElementOrder("treatmentIntent", 2, position, false);
                    builder.treatmentIntent(parseCodeableConcept("treatmentIntent", reader, -1));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 3, position, true);
                    builder.dosage(parseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage("dosage", reader, dosageElementIndex++));
                    break;
                case "administrationTreatment":
                    position = checkElementOrder("administrationTreatment", 4, position, false);
                    builder.administrationTreatment(parseCodeableConcept("administrationTreatment", reader, -1));
                    break;
                case "patientCharacteristic":
                    position = checkElementOrder("patientCharacteristic", 5, position, true);
                    builder.patientCharacteristic(parseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic("patientCharacteristic", reader, patientCharacteristicElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.IndicationGuideline.DosingGuideline.Dosage parseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.IndicationGuideline.DosingGuideline.Dosage.Builder builder = MedicationKnowledge.IndicationGuideline.DosingGuideline.Dosage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dosageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 3, position, true);
                    builder.dosage(parseDosage("dosage", reader, dosageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.IndicationGuideline.DosingGuideline.PatientCharacteristic parseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.IndicationGuideline.DosingGuideline.PatientCharacteristic.Builder builder = MedicationKnowledge.IndicationGuideline.DosingGuideline.PatientCharacteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.MedicineClassification parseMedicationKnowledgeMedicineClassification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.MedicineClassification.Builder builder = MedicationKnowledge.MedicineClassification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, classificationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "sourceString":
                    position = checkElementOrder("source[x]", 3, position, false);
                    builder.source(parseString("sourceString", reader, -1));
                    break;
                case "sourceUri":
                    position = checkElementOrder("source[x]", 3, position, false);
                    builder.source(parseUri("sourceUri", reader, -1));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 4, position, true);
                    builder.classification(parseCodeableConcept("classification", reader, classificationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.MonitoringProgram parseMedicationKnowledgeMonitoringProgram(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.MonitoringProgram.Builder builder = MedicationKnowledge.MonitoringProgram.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Monograph parseMedicationKnowledgeMonograph(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Monograph.Builder builder = MedicationKnowledge.Monograph.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Packaging parseMedicationKnowledgePackaging(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Packaging.Builder builder = MedicationKnowledge.Packaging.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, costElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "cost":
                    position = checkElementOrder("cost", 2, position, true);
                    builder.cost(parseMedicationKnowledgeCost("cost", reader, costElementIndex++));
                    break;
                case "packagedProduct":
                    position = checkElementOrder("packagedProduct", 3, position, false);
                    builder.packagedProduct(parseReference("packagedProduct", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Regulatory parseMedicationKnowledgeRegulatory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Regulatory.Builder builder = MedicationKnowledge.Regulatory.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, substitutionElementIndex = 0, scheduleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "regulatoryAuthority":
                    position = checkElementOrder("regulatoryAuthority", 2, position, false);
                    builder.regulatoryAuthority(parseReference("regulatoryAuthority", reader, -1));
                    break;
                case "substitution":
                    position = checkElementOrder("substitution", 3, position, true);
                    builder.substitution(parseMedicationKnowledgeRegulatorySubstitution("substitution", reader, substitutionElementIndex++));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 4, position, true);
                    builder.schedule(parseCodeableConcept("schedule", reader, scheduleElementIndex++));
                    break;
                case "maxDispense":
                    position = checkElementOrder("maxDispense", 5, position, false);
                    builder.maxDispense(parseMedicationKnowledgeRegulatoryMaxDispense("maxDispense", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Regulatory.MaxDispense parseMedicationKnowledgeRegulatoryMaxDispense(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Regulatory.MaxDispense.Builder builder = MedicationKnowledge.Regulatory.MaxDispense.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period((Duration) parseQuantity(Duration.builder(), "period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Regulatory.Substitution parseMedicationKnowledgeRegulatorySubstitution(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Regulatory.Substitution.Builder builder = MedicationKnowledge.Regulatory.Substitution.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "allowed":
                    position = checkElementOrder("allowed", 3, position, false);
                    builder.allowed(parseBoolean("allowed", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.RelatedMedicationKnowledge parseMedicationKnowledgeRelatedMedicationKnowledge(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.RelatedMedicationKnowledge.Builder builder = MedicationKnowledge.RelatedMedicationKnowledge.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, referenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, true);
                    builder.reference(parseReference("reference", reader, referenceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.StorageGuideline parseMedicationKnowledgeStorageGuideline(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.StorageGuideline.Builder builder = MedicationKnowledge.StorageGuideline.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, environmentalSettingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseUri("reference", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "stabilityDuration":
                    position = checkElementOrder("stabilityDuration", 4, position, false);
                    builder.stabilityDuration((Duration) parseQuantity(Duration.builder(), "stabilityDuration", reader, -1));
                    break;
                case "environmentalSetting":
                    position = checkElementOrder("environmentalSetting", 5, position, true);
                    builder.environmentalSetting(parseMedicationKnowledgeStorageGuidelineEnvironmentalSetting("environmentalSetting", reader, environmentalSettingElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.StorageGuideline.EnvironmentalSetting parseMedicationKnowledgeStorageGuidelineEnvironmentalSetting(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.StorageGuideline.EnvironmentalSetting.Builder builder = MedicationKnowledge.StorageGuideline.EnvironmentalSetting.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationRequest parseMedicationRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationRequest.Builder builder = MedicationRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, categoryElementIndex = 0, informationSourceElementIndex = 0, supportingInformationElementIndex = 0, performerElementIndex = 0, deviceElementIndex = 0, reasonElementIndex = 0, insuranceElementIndex = 0, noteElementIndex = 0, dosageInstructionElementIndex = 0, eventHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "priorPrescription":
                    position = checkElementOrder("priorPrescription", 10, position, false);
                    builder.priorPrescription(parseReference("priorPrescription", reader, -1));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 11, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((MedicationRequestStatus) parseString(MedicationRequestStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 13, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "statusChanged":
                    position = checkElementOrder("statusChanged", 14, position, false);
                    builder.statusChanged(parseDateTime("statusChanged", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((MedicationRequestIntent) parseString(MedicationRequestIntent.builder(), "intent", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 16, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 17, position, false);
                    builder.priority((MedicationRequestPriority) parseString(MedicationRequestPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 18, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "medication":
                    position = checkElementOrder("medication", 19, position, false);
                    builder.medication(parseCodeableReference("medication", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 20, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "informationSource":
                    position = checkElementOrder("informationSource", 21, position, true);
                    builder.informationSource(parseReference("informationSource", reader, informationSourceElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 22, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 23, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 24, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 25, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "reported":
                    position = checkElementOrder("reported", 26, position, false);
                    builder.reported(parseBoolean("reported", reader, -1));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 27, position, false);
                    builder.performerType(parseCodeableConcept("performerType", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 28, position, true);
                    builder.performer(parseReference("performer", reader, performerElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 29, position, true);
                    builder.device(parseCodeableReference("device", reader, deviceElementIndex++));
                    break;
                case "recorder":
                    position = checkElementOrder("recorder", 30, position, false);
                    builder.recorder(parseReference("recorder", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 31, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "courseOfTherapyType":
                    position = checkElementOrder("courseOfTherapyType", 32, position, false);
                    builder.courseOfTherapyType(parseCodeableConcept("courseOfTherapyType", reader, -1));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 33, position, true);
                    builder.insurance(parseReference("insurance", reader, insuranceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 34, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "renderedDosageInstruction":
                    position = checkElementOrder("renderedDosageInstruction", 35, position, false);
                    builder.renderedDosageInstruction((Markdown) parseString(Markdown.builder(), "renderedDosageInstruction", reader, -1));
                    break;
                case "effectiveDosePeriod":
                    position = checkElementOrder("effectiveDosePeriod", 36, position, false);
                    builder.effectiveDosePeriod(parsePeriod("effectiveDosePeriod", reader, -1));
                    break;
                case "dosageInstruction":
                    position = checkElementOrder("dosageInstruction", 37, position, true);
                    builder.dosageInstruction(parseDosage("dosageInstruction", reader, dosageInstructionElementIndex++));
                    break;
                case "dispenseRequest":
                    position = checkElementOrder("dispenseRequest", 38, position, false);
                    builder.dispenseRequest(parseMedicationRequestDispenseRequest("dispenseRequest", reader, -1));
                    break;
                case "substitution":
                    position = checkElementOrder("substitution", 39, position, false);
                    builder.substitution(parseMedicationRequestSubstitution("substitution", reader, -1));
                    break;
                case "eventHistory":
                    position = checkElementOrder("eventHistory", 40, position, true);
                    builder.eventHistory(parseReference("eventHistory", reader, eventHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationRequest.DispenseRequest parseMedicationRequestDispenseRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationRequest.DispenseRequest.Builder builder = MedicationRequest.DispenseRequest.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dispenserInstructionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "initialFill":
                    position = checkElementOrder("initialFill", 2, position, false);
                    builder.initialFill(parseMedicationRequestDispenseRequestInitialFill("initialFill", reader, -1));
                    break;
                case "dispenseInterval":
                    position = checkElementOrder("dispenseInterval", 3, position, false);
                    builder.dispenseInterval((Duration) parseQuantity(Duration.builder(), "dispenseInterval", reader, -1));
                    break;
                case "validityPeriod":
                    position = checkElementOrder("validityPeriod", 4, position, false);
                    builder.validityPeriod(parsePeriod("validityPeriod", reader, -1));
                    break;
                case "numberOfRepeatsAllowed":
                    position = checkElementOrder("numberOfRepeatsAllowed", 5, position, false);
                    builder.numberOfRepeatsAllowed((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfRepeatsAllowed", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 6, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "expectedSupplyDuration":
                    position = checkElementOrder("expectedSupplyDuration", 7, position, false);
                    builder.expectedSupplyDuration((Duration) parseQuantity(Duration.builder(), "expectedSupplyDuration", reader, -1));
                    break;
                case "dispenser":
                    position = checkElementOrder("dispenser", 8, position, false);
                    builder.dispenser(parseReference("dispenser", reader, -1));
                    break;
                case "dispenserInstruction":
                    position = checkElementOrder("dispenserInstruction", 9, position, true);
                    builder.dispenserInstruction(parseAnnotation("dispenserInstruction", reader, dispenserInstructionElementIndex++));
                    break;
                case "doseAdministrationAid":
                    position = checkElementOrder("doseAdministrationAid", 10, position, false);
                    builder.doseAdministrationAid(parseCodeableConcept("doseAdministrationAid", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationRequest.DispenseRequest.InitialFill parseMedicationRequestDispenseRequestInitialFill(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationRequest.DispenseRequest.InitialFill.Builder builder = MedicationRequest.DispenseRequest.InitialFill.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 3, position, false);
                    builder.duration((Duration) parseQuantity(Duration.builder(), "duration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationRequest.Substitution parseMedicationRequestSubstitution(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationRequest.Substitution.Builder builder = MedicationRequest.Substitution.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "allowedBoolean":
                    position = checkElementOrder("allowed[x]", 2, position, false);
                    builder.allowed(parseBoolean("allowedBoolean", reader, -1));
                    break;
                case "allowedCodeableConcept":
                    position = checkElementOrder("allowed[x]", 2, position, false);
                    builder.allowed(parseCodeableConcept("allowedCodeableConcept", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationStatement parseMedicationStatement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationStatement.Builder builder = MedicationStatement.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, partOfElementIndex = 0, categoryElementIndex = 0, informationSourceElementIndex = 0, derivedFromElementIndex = 0, reasonElementIndex = 0, noteElementIndex = 0, relatedClinicalInformationElementIndex = 0, dosageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 9, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((MedicationStatementStatus) parseString(MedicationStatementStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "medication":
                    position = checkElementOrder("medication", 12, position, false);
                    builder.medication(parseCodeableReference("medication", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "effectiveDateTime":
                    position = checkElementOrder("effective[x]", 15, position, false);
                    builder.effective(parseDateTime("effectiveDateTime", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effective[x]", 15, position, false);
                    builder.effective(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "effectiveTiming":
                    position = checkElementOrder("effective[x]", 15, position, false);
                    builder.effective(parseTiming("effectiveTiming", reader, -1));
                    break;
                case "dateAsserted":
                    position = checkElementOrder("dateAsserted", 16, position, false);
                    builder.dateAsserted(parseDateTime("dateAsserted", reader, -1));
                    break;
                case "informationSource":
                    position = checkElementOrder("informationSource", 17, position, true);
                    builder.informationSource(parseReference("informationSource", reader, informationSourceElementIndex++));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 18, position, true);
                    builder.derivedFrom(parseReference("derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 19, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 20, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "relatedClinicalInformation":
                    position = checkElementOrder("relatedClinicalInformation", 21, position, true);
                    builder.relatedClinicalInformation(parseReference("relatedClinicalInformation", reader, relatedClinicalInformationElementIndex++));
                    break;
                case "renderedDosageInstruction":
                    position = checkElementOrder("renderedDosageInstruction", 22, position, false);
                    builder.renderedDosageInstruction((Markdown) parseString(Markdown.builder(), "renderedDosageInstruction", reader, -1));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 23, position, true);
                    builder.dosage(parseDosage("dosage", reader, dosageElementIndex++));
                    break;
                case "adherence":
                    position = checkElementOrder("adherence", 24, position, false);
                    builder.adherence(parseMedicationStatementAdherence("adherence", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationStatement.Adherence parseMedicationStatementAdherence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationStatement.Adherence.Builder builder = MedicationStatement.Adherence.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition parseMedicinalProductDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Builder builder = MedicinalProductDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, routeElementIndex = 0, specialMeasuresElementIndex = 0, classificationElementIndex = 0, marketingStatusElementIndex = 0, packagedMedicinalProductElementIndex = 0, comprisedOfElementIndex = 0, ingredientElementIndex = 0, impurityElementIndex = 0, attachedDocumentElementIndex = 0, masterFileElementIndex = 0, contactElementIndex = 0, clinicalTrialElementIndex = 0, codeElementIndex = 0, nameElementIndex = 0, crossReferenceElementIndex = 0, operationElementIndex = 0, characteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "domain":
                    position = checkElementOrder("domain", 10, position, false);
                    builder.domain(parseCodeableConcept("domain", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 11, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 13, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 14, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "combinedPharmaceuticalDoseForm":
                    position = checkElementOrder("combinedPharmaceuticalDoseForm", 15, position, false);
                    builder.combinedPharmaceuticalDoseForm(parseCodeableConcept("combinedPharmaceuticalDoseForm", reader, -1));
                    break;
                case "route":
                    position = checkElementOrder("route", 16, position, true);
                    builder.route(parseCodeableConcept("route", reader, routeElementIndex++));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 17, position, false);
                    builder.indication((Markdown) parseString(Markdown.builder(), "indication", reader, -1));
                    break;
                case "legalStatusOfSupply":
                    position = checkElementOrder("legalStatusOfSupply", 18, position, false);
                    builder.legalStatusOfSupply(parseCodeableConcept("legalStatusOfSupply", reader, -1));
                    break;
                case "additionalMonitoringIndicator":
                    position = checkElementOrder("additionalMonitoringIndicator", 19, position, false);
                    builder.additionalMonitoringIndicator(parseCodeableConcept("additionalMonitoringIndicator", reader, -1));
                    break;
                case "specialMeasures":
                    position = checkElementOrder("specialMeasures", 20, position, true);
                    builder.specialMeasures(parseCodeableConcept("specialMeasures", reader, specialMeasuresElementIndex++));
                    break;
                case "pediatricUseIndicator":
                    position = checkElementOrder("pediatricUseIndicator", 21, position, false);
                    builder.pediatricUseIndicator(parseCodeableConcept("pediatricUseIndicator", reader, -1));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 22, position, true);
                    builder.classification(parseCodeableConcept("classification", reader, classificationElementIndex++));
                    break;
                case "marketingStatus":
                    position = checkElementOrder("marketingStatus", 23, position, true);
                    builder.marketingStatus(parseMarketingStatus("marketingStatus", reader, marketingStatusElementIndex++));
                    break;
                case "packagedMedicinalProduct":
                    position = checkElementOrder("packagedMedicinalProduct", 24, position, true);
                    builder.packagedMedicinalProduct(parseCodeableConcept("packagedMedicinalProduct", reader, packagedMedicinalProductElementIndex++));
                    break;
                case "comprisedOf":
                    position = checkElementOrder("comprisedOf", 25, position, true);
                    builder.comprisedOf(parseReference("comprisedOf", reader, comprisedOfElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 26, position, true);
                    builder.ingredient(parseCodeableConcept("ingredient", reader, ingredientElementIndex++));
                    break;
                case "impurity":
                    position = checkElementOrder("impurity", 27, position, true);
                    builder.impurity(parseCodeableReference("impurity", reader, impurityElementIndex++));
                    break;
                case "attachedDocument":
                    position = checkElementOrder("attachedDocument", 28, position, true);
                    builder.attachedDocument(parseReference("attachedDocument", reader, attachedDocumentElementIndex++));
                    break;
                case "masterFile":
                    position = checkElementOrder("masterFile", 29, position, true);
                    builder.masterFile(parseReference("masterFile", reader, masterFileElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 30, position, true);
                    builder.contact(parseMedicinalProductDefinitionContact("contact", reader, contactElementIndex++));
                    break;
                case "clinicalTrial":
                    position = checkElementOrder("clinicalTrial", 31, position, true);
                    builder.clinicalTrial(parseReference("clinicalTrial", reader, clinicalTrialElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 32, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 33, position, true);
                    builder.name(parseMedicinalProductDefinitionName("name", reader, nameElementIndex++));
                    break;
                case "crossReference":
                    position = checkElementOrder("crossReference", 34, position, true);
                    builder.crossReference(parseMedicinalProductDefinitionCrossReference("crossReference", reader, crossReferenceElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 35, position, true);
                    builder.operation(parseMedicinalProductDefinitionOperation("operation", reader, operationElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 36, position, true);
                    builder.characteristic(parseMedicinalProductDefinitionCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Characteristic parseMedicinalProductDefinitionCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Characteristic.Builder builder = MedicinalProductDefinition.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Contact parseMedicinalProductDefinitionContact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Contact.Builder builder = MedicinalProductDefinition.Contact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 3, position, false);
                    builder.contact(parseReference("contact", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.CrossReference parseMedicinalProductDefinitionCrossReference(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.CrossReference.Builder builder = MedicinalProductDefinition.CrossReference.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "product":
                    position = checkElementOrder("product", 2, position, false);
                    builder.product(parseCodeableReference("product", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Name parseMedicinalProductDefinitionName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Name.Builder builder = MedicinalProductDefinition.Name.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, partElementIndex = 0, usageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "productName":
                    position = checkElementOrder("productName", 2, position, false);
                    builder.productName(parseString("productName", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "part":
                    position = checkElementOrder("part", 4, position, true);
                    builder.part(parseMedicinalProductDefinitionNamePart("part", reader, partElementIndex++));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 5, position, true);
                    builder.usage(parseMedicinalProductDefinitionNameUsage("usage", reader, usageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Name.Part parseMedicinalProductDefinitionNamePart(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Name.Part.Builder builder = MedicinalProductDefinition.Name.Part.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "part":
                    position = checkElementOrder("part", 2, position, false);
                    builder.part(parseString("part", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Name.Usage parseMedicinalProductDefinitionNameUsage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Name.Usage.Builder builder = MedicinalProductDefinition.Name.Usage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "country":
                    position = checkElementOrder("country", 2, position, false);
                    builder.country(parseCodeableConcept("country", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 3, position, false);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 4, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Operation parseMedicinalProductDefinitionOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Operation.Builder builder = MedicinalProductDefinition.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, organizationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableReference("type", reader, -1));
                    break;
                case "effectiveDate":
                    position = checkElementOrder("effectiveDate", 3, position, false);
                    builder.effectiveDate(parsePeriod("effectiveDate", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 4, position, true);
                    builder.organization(parseReference("organization", reader, organizationElementIndex++));
                    break;
                case "confidentialityIndicator":
                    position = checkElementOrder("confidentialityIndicator", 5, position, false);
                    builder.confidentialityIndicator(parseCodeableConcept("confidentialityIndicator", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageDefinition parseMessageDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageDefinition.Builder builder = MessageDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, replacesElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, parentElementIndex = 0, focusElementIndex = 0, allowedResponseElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 14, position, true);
                    builder.replaces((Canonical) parseUri(Canonical.builder(), "replaces", reader, replacesElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 24, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 25, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 26, position, false);
                    builder.base((Canonical) parseUri(Canonical.builder(), "base", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 27, position, true);
                    builder.parent((Canonical) parseUri(Canonical.builder(), "parent", reader, parentElementIndex++));
                    break;
                case "eventCoding":
                    position = checkElementOrder("event[x]", 28, position, false);
                    builder.event(parseCoding("eventCoding", reader, -1));
                    break;
                case "eventUri":
                    position = checkElementOrder("event[x]", 28, position, false);
                    builder.event(parseUri("eventUri", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 29, position, false);
                    builder.category((MessageSignificanceCategory) parseString(MessageSignificanceCategory.builder(), "category", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 30, position, true);
                    builder.focus(parseMessageDefinitionFocus("focus", reader, focusElementIndex++));
                    break;
                case "responseRequired":
                    position = checkElementOrder("responseRequired", 31, position, false);
                    builder.responseRequired((MessageHeaderResponseRequest) parseString(MessageHeaderResponseRequest.builder(), "responseRequired", reader, -1));
                    break;
                case "allowedResponse":
                    position = checkElementOrder("allowedResponse", 32, position, true);
                    builder.allowedResponse(parseMessageDefinitionAllowedResponse("allowedResponse", reader, allowedResponseElementIndex++));
                    break;
                case "graph":
                    position = checkElementOrder("graph", 33, position, false);
                    builder.graph((Canonical) parseUri(Canonical.builder(), "graph", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageDefinition.AllowedResponse parseMessageDefinitionAllowedResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageDefinition.AllowedResponse.Builder builder = MessageDefinition.AllowedResponse.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "message":
                    position = checkElementOrder("message", 2, position, false);
                    builder.message((Canonical) parseUri(Canonical.builder(), "message", reader, -1));
                    break;
                case "situation":
                    position = checkElementOrder("situation", 3, position, false);
                    builder.situation((Markdown) parseString(Markdown.builder(), "situation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageDefinition.Focus parseMessageDefinitionFocus(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageDefinition.Focus.Builder builder = MessageDefinition.Focus.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "code", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 4, position, false);
                    builder.min((UnsignedInt) parseInteger(UnsignedInt.builder(), "min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 5, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageHeader parseMessageHeader(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageHeader.Builder builder = MessageHeader.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, destinationElementIndex = 0, focusElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "eventCoding":
                    position = checkElementOrder("event[x]", 8, position, false);
                    builder.event(parseCoding("eventCoding", reader, -1));
                    break;
                case "eventCanonical":
                    position = checkElementOrder("event[x]", 8, position, false);
                    builder.event((Canonical) parseUri(Canonical.builder(), "eventCanonical", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 9, position, true);
                    builder.destination(parseMessageHeaderDestination("destination", reader, destinationElementIndex++));
                    break;
                case "sender":
                    position = checkElementOrder("sender", 10, position, false);
                    builder.sender(parseReference("sender", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 11, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 12, position, false);
                    builder.source(parseMessageHeaderSource("source", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 13, position, false);
                    builder.responsible(parseReference("responsible", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 14, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 15, position, false);
                    builder.response(parseMessageHeaderResponse("response", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 16, position, true);
                    builder.focus(parseReference("focus", reader, focusElementIndex++));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 17, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageHeader.Destination parseMessageHeaderDestination(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageHeader.Destination.Builder builder = MessageHeader.Destination.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "endpointUrl":
                    position = checkElementOrder("endpoint[x]", 2, position, false);
                    builder.endpoint((Url) parseUri(Url.builder(), "endpointUrl", reader, -1));
                    break;
                case "endpointReference":
                    position = checkElementOrder("endpoint[x]", 2, position, false);
                    builder.endpoint(parseReference("endpointReference", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 4, position, false);
                    builder.target(parseReference("target", reader, -1));
                    break;
                case "receiver":
                    position = checkElementOrder("receiver", 5, position, false);
                    builder.receiver(parseReference("receiver", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageHeader.Response parseMessageHeaderResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageHeader.Response.Builder builder = MessageHeader.Response.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code((ResponseType) parseString(ResponseType.builder(), "code", reader, -1));
                    break;
                case "details":
                    position = checkElementOrder("details", 4, position, false);
                    builder.details(parseReference("details", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageHeader.Source parseMessageHeaderSource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageHeader.Source.Builder builder = MessageHeader.Source.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "endpointUrl":
                    position = checkElementOrder("endpoint[x]", 2, position, false);
                    builder.endpoint((Url) parseUri(Url.builder(), "endpointUrl", reader, -1));
                    break;
                case "endpointReference":
                    position = checkElementOrder("endpoint[x]", 2, position, false);
                    builder.endpoint(parseReference("endpointReference", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "software":
                    position = checkElementOrder("software", 4, position, false);
                    builder.software(parseString("software", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 5, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 6, position, false);
                    builder.contact(parseContactPoint("contact", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Meta parseMeta(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Meta.Builder builder = Meta.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, profileElementIndex = 0, securityElementIndex = 0, tagElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "versionId":
                    position = checkElementOrder("versionId", 1, position, false);
                    builder.versionId((Id) parseString(Id.builder(), "versionId", reader, -1));
                    break;
                case "lastUpdated":
                    position = checkElementOrder("lastUpdated", 2, position, false);
                    builder.lastUpdated(parseInstant("lastUpdated", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, false);
                    builder.source(parseUri("source", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 4, position, true);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, profileElementIndex++));
                    break;
                case "security":
                    position = checkElementOrder("security", 5, position, true);
                    builder.security(parseCoding("security", reader, securityElementIndex++));
                    break;
                case "tag":
                    position = checkElementOrder("tag", 6, position, true);
                    builder.tag(parseCoding("tag", reader, tagElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence parseMolecularSequence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.Builder builder = MolecularSequence.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, focusElementIndex = 0, formattedElementIndex = 0, relativeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type((SequenceType) parseString(SequenceType.builder(), "type", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 10, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 11, position, true);
                    builder.focus(parseReference("focus", reader, focusElementIndex++));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 12, position, false);
                    builder.specimen(parseReference("specimen", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 13, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 14, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "literal":
                    position = checkElementOrder("literal", 15, position, false);
                    builder.literal(parseString("literal", reader, -1));
                    break;
                case "formatted":
                    position = checkElementOrder("formatted", 16, position, true);
                    builder.formatted(parseAttachment("formatted", reader, formattedElementIndex++));
                    break;
                case "relative":
                    position = checkElementOrder("relative", 17, position, true);
                    builder.relative(parseMolecularSequenceRelative("relative", reader, relativeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.Relative parseMolecularSequenceRelative(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.Relative.Builder builder = MolecularSequence.Relative.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, editElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "coordinateSystem":
                    position = checkElementOrder("coordinateSystem", 2, position, false);
                    builder.coordinateSystem(parseCodeableConcept("coordinateSystem", reader, -1));
                    break;
                case "ordinalPosition":
                    position = checkElementOrder("ordinalPosition", 3, position, false);
                    builder.ordinalPosition(parseInteger("ordinalPosition", reader, -1));
                    break;
                case "sequenceRange":
                    position = checkElementOrder("sequenceRange", 4, position, false);
                    builder.sequenceRange(parseRange("sequenceRange", reader, -1));
                    break;
                case "startingSequence":
                    position = checkElementOrder("startingSequence", 5, position, false);
                    builder.startingSequence(parseMolecularSequenceRelativeStartingSequence("startingSequence", reader, -1));
                    break;
                case "edit":
                    position = checkElementOrder("edit", 6, position, true);
                    builder.edit(parseMolecularSequenceRelativeEdit("edit", reader, editElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.Relative.Edit parseMolecularSequenceRelativeEdit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.Relative.Edit.Builder builder = MolecularSequence.Relative.Edit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "start":
                    position = checkElementOrder("start", 2, position, false);
                    builder.start(parseInteger("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 3, position, false);
                    builder.end(parseInteger("end", reader, -1));
                    break;
                case "replacementSequence":
                    position = checkElementOrder("replacementSequence", 4, position, false);
                    builder.replacementSequence(parseString("replacementSequence", reader, -1));
                    break;
                case "replacedSequence":
                    position = checkElementOrder("replacedSequence", 5, position, false);
                    builder.replacedSequence(parseString("replacedSequence", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.Relative.StartingSequence parseMolecularSequenceRelativeStartingSequence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.Relative.StartingSequence.Builder builder = MolecularSequence.Relative.StartingSequence.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "genomeAssembly":
                    position = checkElementOrder("genomeAssembly", 2, position, false);
                    builder.genomeAssembly(parseCodeableConcept("genomeAssembly", reader, -1));
                    break;
                case "chromosome":
                    position = checkElementOrder("chromosome", 3, position, false);
                    builder.chromosome(parseCodeableConcept("chromosome", reader, -1));
                    break;
                case "sequenceCodeableConcept":
                    position = checkElementOrder("sequence[x]", 4, position, false);
                    builder.sequence(parseCodeableConcept("sequenceCodeableConcept", reader, -1));
                    break;
                case "sequenceString":
                    position = checkElementOrder("sequence[x]", 4, position, false);
                    builder.sequence(parseString("sequenceString", reader, -1));
                    break;
                case "sequenceReference":
                    position = checkElementOrder("sequence[x]", 4, position, false);
                    builder.sequence(parseReference("sequenceReference", reader, -1));
                    break;
                case "windowStart":
                    position = checkElementOrder("windowStart", 5, position, false);
                    builder.windowStart(parseInteger("windowStart", reader, -1));
                    break;
                case "windowEnd":
                    position = checkElementOrder("windowEnd", 6, position, false);
                    builder.windowEnd(parseInteger("windowEnd", reader, -1));
                    break;
                case "orientation":
                    position = checkElementOrder("orientation", 7, position, false);
                    builder.orientation((OrientationType) parseString(OrientationType.builder(), "orientation", reader, -1));
                    break;
                case "strand":
                    position = checkElementOrder("strand", 8, position, false);
                    builder.strand((StrandType) parseString(StrandType.builder(), "strand", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MonetaryComponent parseMonetaryComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MonetaryComponent.Builder builder = MonetaryComponent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, false);
                    builder.type((PriceComponentType) parseString(PriceComponentType.builder(), "type", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 3, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 4, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Money parseMoney(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Money.Builder builder = Money.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 1, position, false);
                    builder.value(parseDecimal("value", reader, -1));
                    break;
                case "currency":
                    position = checkElementOrder("currency", 2, position, false);
                    builder.currency((Code) parseString(Code.builder(), "currency", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NamingSystem parseNamingSystem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NamingSystem.Builder builder = NamingSystem.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, uniqueIdElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 15, position, false);
                    builder.kind((NamingSystemType) parseString(NamingSystemType.builder(), "kind", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 20, position, false);
                    builder.responsible(parseString("responsible", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 21, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 22, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 23, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 24, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 25, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 26, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 27, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 28, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 29, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 30, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 31, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 32, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 33, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 34, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 35, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 36, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 37, position, false);
                    builder.usage(parseString("usage", reader, -1));
                    break;
                case "uniqueId":
                    position = checkElementOrder("uniqueId", 38, position, true);
                    builder.uniqueId(parseNamingSystemUniqueId("uniqueId", reader, uniqueIdElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NamingSystem.UniqueId parseNamingSystemUniqueId(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NamingSystem.UniqueId.Builder builder = NamingSystem.UniqueId.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((NamingSystemIdentifierType) parseString(NamingSystemIdentifierType.builder(), "type", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 4, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 5, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 6, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "authoritative":
                    position = checkElementOrder("authoritative", 7, position, false);
                    builder.authoritative(parseBoolean("authoritative", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Narrative parseNarrative(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Narrative.Builder builder = Narrative.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                if ("div".equals(localName)) {
                    requireNamespace(reader, XHTML_NS_URI);
                } else {
                    requireNamespace(reader, FHIR_NS_URI);
                }
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 1, position, false);
                    builder.status((NarrativeStatus) parseString(NarrativeStatus.builder(), "status", reader, -1));
                    break;
                case "div":
                    position = checkElementOrder("div", 2, position, false);
                    builder.div(parseXhtml("div", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionIntake parseNutritionIntake(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionIntake.Builder builder = NutritionIntake.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, statusReasonElementIndex = 0, consumedItemElementIndex = 0, ingredientLabelElementIndex = 0, performerElementIndex = 0, derivedFromElementIndex = 0, reasonElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 12, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((NutritionIntakeStatus) parseString(NutritionIntakeStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 14, position, true);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, statusReasonElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 15, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 16, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 17, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 18, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 18, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "recorded":
                    position = checkElementOrder("recorded", 19, position, false);
                    builder.recorded(parseDateTime("recorded", reader, -1));
                    break;
                case "reportedBoolean":
                    position = checkElementOrder("reported[x]", 20, position, false);
                    builder.reported(parseBoolean("reportedBoolean", reader, -1));
                    break;
                case "reportedReference":
                    position = checkElementOrder("reported[x]", 20, position, false);
                    builder.reported(parseReference("reportedReference", reader, -1));
                    break;
                case "consumedItem":
                    position = checkElementOrder("consumedItem", 21, position, true);
                    builder.consumedItem(parseNutritionIntakeConsumedItem("consumedItem", reader, consumedItemElementIndex++));
                    break;
                case "ingredientLabel":
                    position = checkElementOrder("ingredientLabel", 22, position, true);
                    builder.ingredientLabel(parseNutritionIntakeIngredientLabel("ingredientLabel", reader, ingredientLabelElementIndex++));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 23, position, true);
                    builder.performer(parseNutritionIntakePerformer("performer", reader, performerElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 24, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 25, position, true);
                    builder.derivedFrom(parseReference("derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 26, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 27, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionIntake.ConsumedItem parseNutritionIntakeConsumedItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionIntake.ConsumedItem.Builder builder = NutritionIntake.ConsumedItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "nutritionProduct":
                    position = checkElementOrder("nutritionProduct", 3, position, false);
                    builder.nutritionProduct(parseCodeableReference("nutritionProduct", reader, -1));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 4, position, false);
                    builder.schedule(parseTiming("schedule", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 5, position, false);
                    builder.amount((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "amount", reader, -1));
                    break;
                case "rate":
                    position = checkElementOrder("rate", 6, position, false);
                    builder.rate((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "rate", reader, -1));
                    break;
                case "notConsumed":
                    position = checkElementOrder("notConsumed", 7, position, false);
                    builder.notConsumed(parseBoolean("notConsumed", reader, -1));
                    break;
                case "notConsumedReason":
                    position = checkElementOrder("notConsumedReason", 8, position, false);
                    builder.notConsumedReason(parseCodeableConcept("notConsumedReason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionIntake.IngredientLabel parseNutritionIntakeIngredientLabel(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionIntake.IngredientLabel.Builder builder = NutritionIntake.IngredientLabel.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "nutrient":
                    position = checkElementOrder("nutrient", 2, position, false);
                    builder.nutrient(parseCodeableReference("nutrient", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, false);
                    builder.amount((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionIntake.Performer parseNutritionIntakePerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionIntake.Performer.Builder builder = NutritionIntake.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder parseNutritionOrder(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.Builder builder = NutritionOrder.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, instantiatesElementIndex = 0, basedOnElementIndex = 0, supportingInformationElementIndex = 0, performerElementIndex = 0, allergyIntoleranceElementIndex = 0, foodPreferenceModifierElementIndex = 0, excludeFoodModifierElementIndex = 0, supplementElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "instantiates":
                    position = checkElementOrder("instantiates", 11, position, true);
                    builder.instantiates(parseUri("instantiates", reader, instantiatesElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 12, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 13, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((NutritionOrderStatus) parseString(NutritionOrderStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((NutritionOrderIntent) parseString(NutritionOrderIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 16, position, false);
                    builder.priority((NutritionOrderPriority) parseString(NutritionOrderPriority.builder(), "priority", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 17, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 18, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 19, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "dateTime":
                    position = checkElementOrder("dateTime", 20, position, false);
                    builder.dateTime(parseDateTime("dateTime", reader, -1));
                    break;
                case "orderer":
                    position = checkElementOrder("orderer", 21, position, false);
                    builder.orderer(parseReference("orderer", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 22, position, true);
                    builder.performer(parseCodeableReference("performer", reader, performerElementIndex++));
                    break;
                case "allergyIntolerance":
                    position = checkElementOrder("allergyIntolerance", 23, position, true);
                    builder.allergyIntolerance(parseReference("allergyIntolerance", reader, allergyIntoleranceElementIndex++));
                    break;
                case "foodPreferenceModifier":
                    position = checkElementOrder("foodPreferenceModifier", 24, position, true);
                    builder.foodPreferenceModifier(parseCodeableConcept("foodPreferenceModifier", reader, foodPreferenceModifierElementIndex++));
                    break;
                case "excludeFoodModifier":
                    position = checkElementOrder("excludeFoodModifier", 25, position, true);
                    builder.excludeFoodModifier(parseCodeableConcept("excludeFoodModifier", reader, excludeFoodModifierElementIndex++));
                    break;
                case "outsideFoodAllowed":
                    position = checkElementOrder("outsideFoodAllowed", 26, position, false);
                    builder.outsideFoodAllowed(parseBoolean("outsideFoodAllowed", reader, -1));
                    break;
                case "oralDiet":
                    position = checkElementOrder("oralDiet", 27, position, false);
                    builder.oralDiet(parseNutritionOrderOralDiet("oralDiet", reader, -1));
                    break;
                case "supplement":
                    position = checkElementOrder("supplement", 28, position, true);
                    builder.supplement(parseNutritionOrderSupplement("supplement", reader, supplementElementIndex++));
                    break;
                case "enteralFormula":
                    position = checkElementOrder("enteralFormula", 29, position, false);
                    builder.enteralFormula(parseNutritionOrderEnteralFormula("enteralFormula", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 30, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.EnteralFormula parseNutritionOrderEnteralFormula(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.EnteralFormula.Builder builder = NutritionOrder.EnteralFormula.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, deliveryDeviceElementIndex = 0, additiveElementIndex = 0, administrationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "baseFormulaType":
                    position = checkElementOrder("baseFormulaType", 2, position, false);
                    builder.baseFormulaType(parseCodeableReference("baseFormulaType", reader, -1));
                    break;
                case "baseFormulaProductName":
                    position = checkElementOrder("baseFormulaProductName", 3, position, false);
                    builder.baseFormulaProductName(parseString("baseFormulaProductName", reader, -1));
                    break;
                case "deliveryDevice":
                    position = checkElementOrder("deliveryDevice", 4, position, true);
                    builder.deliveryDevice(parseCodeableReference("deliveryDevice", reader, deliveryDeviceElementIndex++));
                    break;
                case "additive":
                    position = checkElementOrder("additive", 5, position, true);
                    builder.additive(parseNutritionOrderEnteralFormulaAdditive("additive", reader, additiveElementIndex++));
                    break;
                case "caloricDensity":
                    position = checkElementOrder("caloricDensity", 6, position, false);
                    builder.caloricDensity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "caloricDensity", reader, -1));
                    break;
                case "routeOfAdministration":
                    position = checkElementOrder("routeOfAdministration", 7, position, false);
                    builder.routeOfAdministration(parseCodeableConcept("routeOfAdministration", reader, -1));
                    break;
                case "administration":
                    position = checkElementOrder("administration", 8, position, true);
                    builder.administration(parseNutritionOrderEnteralFormulaAdministration("administration", reader, administrationElementIndex++));
                    break;
                case "maxVolumeToDeliver":
                    position = checkElementOrder("maxVolumeToDeliver", 9, position, false);
                    builder.maxVolumeToDeliver((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "maxVolumeToDeliver", reader, -1));
                    break;
                case "administrationInstruction":
                    position = checkElementOrder("administrationInstruction", 10, position, false);
                    builder.administrationInstruction((Markdown) parseString(Markdown.builder(), "administrationInstruction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.EnteralFormula.Additive parseNutritionOrderEnteralFormulaAdditive(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.EnteralFormula.Additive.Builder builder = NutritionOrder.EnteralFormula.Additive.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableReference("type", reader, -1));
                    break;
                case "productName":
                    position = checkElementOrder("productName", 3, position, false);
                    builder.productName(parseString("productName", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 4, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.EnteralFormula.Administration parseNutritionOrderEnteralFormulaAdministration(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.EnteralFormula.Administration.Builder builder = NutritionOrder.EnteralFormula.Administration.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 2, position, false);
                    builder.schedule(parseNutritionOrderEnteralFormulaAdministrationSchedule("schedule", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 3, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "rateQuantity":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "rateQuantity", reader, -1));
                    break;
                case "rateRatio":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate(parseRatio("rateRatio", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.EnteralFormula.Administration.Schedule parseNutritionOrderEnteralFormulaAdministrationSchedule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.EnteralFormula.Administration.Schedule.Builder builder = NutritionOrder.EnteralFormula.Administration.Schedule.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, timingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "timing":
                    position = checkElementOrder("timing", 2, position, true);
                    builder.timing(parseTiming("timing", reader, timingElementIndex++));
                    break;
                case "asNeeded":
                    position = checkElementOrder("asNeeded", 3, position, false);
                    builder.asNeeded(parseBoolean("asNeeded", reader, -1));
                    break;
                case "asNeededFor":
                    position = checkElementOrder("asNeededFor", 4, position, false);
                    builder.asNeededFor(parseCodeableConcept("asNeededFor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.OralDiet parseNutritionOrderOralDiet(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.OralDiet.Builder builder = NutritionOrder.OralDiet.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, nutrientElementIndex = 0, textureElementIndex = 0, fluidConsistencyTypeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 3, position, false);
                    builder.schedule(parseNutritionOrderOralDietSchedule("schedule", reader, -1));
                    break;
                case "nutrient":
                    position = checkElementOrder("nutrient", 4, position, true);
                    builder.nutrient(parseNutritionOrderOralDietNutrient("nutrient", reader, nutrientElementIndex++));
                    break;
                case "texture":
                    position = checkElementOrder("texture", 5, position, true);
                    builder.texture(parseNutritionOrderOralDietTexture("texture", reader, textureElementIndex++));
                    break;
                case "fluidConsistencyType":
                    position = checkElementOrder("fluidConsistencyType", 6, position, true);
                    builder.fluidConsistencyType(parseCodeableConcept("fluidConsistencyType", reader, fluidConsistencyTypeElementIndex++));
                    break;
                case "instruction":
                    position = checkElementOrder("instruction", 7, position, false);
                    builder.instruction(parseString("instruction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.OralDiet.Nutrient parseNutritionOrderOralDietNutrient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.OralDiet.Nutrient.Builder builder = NutritionOrder.OralDiet.Nutrient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 2, position, false);
                    builder.modifier(parseCodeableConcept("modifier", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, false);
                    builder.amount((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.OralDiet.Schedule parseNutritionOrderOralDietSchedule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.OralDiet.Schedule.Builder builder = NutritionOrder.OralDiet.Schedule.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, timingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "timing":
                    position = checkElementOrder("timing", 2, position, true);
                    builder.timing(parseTiming("timing", reader, timingElementIndex++));
                    break;
                case "asNeeded":
                    position = checkElementOrder("asNeeded", 3, position, false);
                    builder.asNeeded(parseBoolean("asNeeded", reader, -1));
                    break;
                case "asNeededFor":
                    position = checkElementOrder("asNeededFor", 4, position, false);
                    builder.asNeededFor(parseCodeableConcept("asNeededFor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.OralDiet.Texture parseNutritionOrderOralDietTexture(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.OralDiet.Texture.Builder builder = NutritionOrder.OralDiet.Texture.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 2, position, false);
                    builder.modifier(parseCodeableConcept("modifier", reader, -1));
                    break;
                case "foodType":
                    position = checkElementOrder("foodType", 3, position, false);
                    builder.foodType(parseCodeableConcept("foodType", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.Supplement parseNutritionOrderSupplement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.Supplement.Builder builder = NutritionOrder.Supplement.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableReference("type", reader, -1));
                    break;
                case "productName":
                    position = checkElementOrder("productName", 3, position, false);
                    builder.productName(parseString("productName", reader, -1));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 4, position, false);
                    builder.schedule(parseNutritionOrderSupplementSchedule("schedule", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "instruction":
                    position = checkElementOrder("instruction", 6, position, false);
                    builder.instruction(parseString("instruction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.Supplement.Schedule parseNutritionOrderSupplementSchedule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.Supplement.Schedule.Builder builder = NutritionOrder.Supplement.Schedule.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, timingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "timing":
                    position = checkElementOrder("timing", 2, position, true);
                    builder.timing(parseTiming("timing", reader, timingElementIndex++));
                    break;
                case "asNeeded":
                    position = checkElementOrder("asNeeded", 3, position, false);
                    builder.asNeeded(parseBoolean("asNeeded", reader, -1));
                    break;
                case "asNeededFor":
                    position = checkElementOrder("asNeededFor", 4, position, false);
                    builder.asNeededFor(parseCodeableConcept("asNeededFor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct parseNutritionProduct(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.Builder builder = NutritionProduct.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, categoryElementIndex = 0, manufacturerElementIndex = 0, nutrientElementIndex = 0, ingredientElementIndex = 0, knownAllergenElementIndex = 0, characteristicElementIndex = 0, instanceElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 8, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((NutritionProductStatus) parseString(NutritionProductStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 11, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "nutrient":
                    position = checkElementOrder("nutrient", 12, position, true);
                    builder.nutrient(parseNutritionProductNutrient("nutrient", reader, nutrientElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 13, position, true);
                    builder.ingredient(parseNutritionProductIngredient("ingredient", reader, ingredientElementIndex++));
                    break;
                case "knownAllergen":
                    position = checkElementOrder("knownAllergen", 14, position, true);
                    builder.knownAllergen(parseCodeableReference("knownAllergen", reader, knownAllergenElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 15, position, true);
                    builder.characteristic(parseNutritionProductCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 16, position, true);
                    builder.instance(parseNutritionProductInstance("instance", reader, instanceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 17, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct.Characteristic parseNutritionProductCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.Characteristic.Builder builder = NutritionProduct.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "valueQuantity", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct.Ingredient parseNutritionProductIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.Ingredient.Builder builder = NutritionProduct.Ingredient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, amountElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 2, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, true);
                    builder.amount(parseRatio("amount", reader, amountElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct.Instance parseNutritionProductInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.Instance.Builder builder = NutritionProduct.Instance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "lotNumber":
                    position = checkElementOrder("lotNumber", 5, position, false);
                    builder.lotNumber(parseString("lotNumber", reader, -1));
                    break;
                case "expiry":
                    position = checkElementOrder("expiry", 6, position, false);
                    builder.expiry(parseDateTime("expiry", reader, -1));
                    break;
                case "useBy":
                    position = checkElementOrder("useBy", 7, position, false);
                    builder.useBy(parseDateTime("useBy", reader, -1));
                    break;
                case "biologicalSourceEvent":
                    position = checkElementOrder("biologicalSourceEvent", 8, position, false);
                    builder.biologicalSourceEvent(parseIdentifier("biologicalSourceEvent", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct.Nutrient parseNutritionProductNutrient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.Nutrient.Builder builder = NutritionProduct.Nutrient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, amountElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 2, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, true);
                    builder.amount(parseRatio("amount", reader, amountElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Observation parseObservation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Observation.Builder builder = Observation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, triggeredByElementIndex = 0, partOfElementIndex = 0, categoryElementIndex = 0, focusElementIndex = 0, performerElementIndex = 0, interpretationElementIndex = 0, noteElementIndex = 0, referenceRangeElementIndex = 0, hasMemberElementIndex = 0, derivedFromElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiates[x]", 9, position, false);
                    builder.instantiates((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, -1));
                    break;
                case "instantiatesReference":
                    position = checkElementOrder("instantiates[x]", 9, position, false);
                    builder.instantiates(parseReference("instantiatesReference", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 10, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "triggeredBy":
                    position = checkElementOrder("triggeredBy", 11, position, true);
                    builder.triggeredBy(parseObservationTriggeredBy("triggeredBy", reader, triggeredByElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 12, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((ObservationStatus) parseString(ObservationStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 14, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 15, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 16, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 17, position, true);
                    builder.focus(parseReference("focus", reader, focusElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 18, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "effectiveDateTime":
                    position = checkElementOrder("effective[x]", 19, position, false);
                    builder.effective(parseDateTime("effectiveDateTime", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effective[x]", 19, position, false);
                    builder.effective(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "effectiveTiming":
                    position = checkElementOrder("effective[x]", 19, position, false);
                    builder.effective(parseTiming("effectiveTiming", reader, -1));
                    break;
                case "effectiveInstant":
                    position = checkElementOrder("effective[x]", 19, position, false);
                    builder.effective(parseInstant("effectiveInstant", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 20, position, false);
                    builder.issued(parseInstant("issued", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 21, position, true);
                    builder.performer(parseReference("performer", reader, performerElementIndex++));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 22, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "dataAbsentReason":
                    position = checkElementOrder("dataAbsentReason", 23, position, false);
                    builder.dataAbsentReason(parseCodeableConcept("dataAbsentReason", reader, -1));
                    break;
                case "interpretation":
                    position = checkElementOrder("interpretation", 24, position, true);
                    builder.interpretation(parseCodeableConcept("interpretation", reader, interpretationElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 25, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 26, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "bodyStructure":
                    position = checkElementOrder("bodyStructure", 27, position, false);
                    builder.bodyStructure(parseReference("bodyStructure", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 28, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 29, position, false);
                    builder.specimen(parseReference("specimen", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 30, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "referenceRange":
                    position = checkElementOrder("referenceRange", 31, position, true);
                    builder.referenceRange(parseObservationReferenceRange("referenceRange", reader, referenceRangeElementIndex++));
                    break;
                case "hasMember":
                    position = checkElementOrder("hasMember", 32, position, true);
                    builder.hasMember(parseReference("hasMember", reader, hasMemberElementIndex++));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 33, position, true);
                    builder.derivedFrom(parseReference("derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "component":
                    position = checkElementOrder("component", 34, position, true);
                    builder.component(parseObservationComponent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Observation.Component parseObservationComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Observation.Component.Builder builder = Observation.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, interpretationElementIndex = 0, referenceRangeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "dataAbsentReason":
                    position = checkElementOrder("dataAbsentReason", 4, position, false);
                    builder.dataAbsentReason(parseCodeableConcept("dataAbsentReason", reader, -1));
                    break;
                case "interpretation":
                    position = checkElementOrder("interpretation", 5, position, true);
                    builder.interpretation(parseCodeableConcept("interpretation", reader, interpretationElementIndex++));
                    break;
                case "referenceRange":
                    position = checkElementOrder("referenceRange", 6, position, true);
                    builder.referenceRange(parseObservationReferenceRange("referenceRange", reader, referenceRangeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Observation.ReferenceRange parseObservationReferenceRange(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Observation.ReferenceRange.Builder builder = Observation.ReferenceRange.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, appliesToElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "low":
                    position = checkElementOrder("low", 2, position, false);
                    builder.low((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "low", reader, -1));
                    break;
                case "high":
                    position = checkElementOrder("high", 3, position, false);
                    builder.high((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "high", reader, -1));
                    break;
                case "normalValue":
                    position = checkElementOrder("normalValue", 4, position, false);
                    builder.normalValue(parseCodeableConcept("normalValue", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "appliesTo":
                    position = checkElementOrder("appliesTo", 6, position, true);
                    builder.appliesTo(parseCodeableConcept("appliesTo", reader, appliesToElementIndex++));
                    break;
                case "age":
                    position = checkElementOrder("age", 7, position, false);
                    builder.age(parseRange("age", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 8, position, false);
                    builder.text((Markdown) parseString(Markdown.builder(), "text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Observation.TriggeredBy parseObservationTriggeredBy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Observation.TriggeredBy.Builder builder = Observation.TriggeredBy.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "observation":
                    position = checkElementOrder("observation", 2, position, false);
                    builder.observation(parseReference("observation", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((TriggeredByType) parseString(TriggeredByType.builder(), "type", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 4, position, false);
                    builder.reason(parseString("reason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ObservationDefinition parseObservationDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ObservationDefinition.Builder builder = ObservationDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, derivedFromCanonicalElementIndex = 0, derivedFromUriElementIndex = 0, subjectElementIndex = 0, categoryElementIndex = 0, permittedDataTypeElementIndex = 0, specimenElementIndex = 0, deviceElementIndex = 0, permittedUnitElementIndex = 0, qualifiedValueElementIndex = 0, hasMemberElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 25, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 26, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 27, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "derivedFromCanonical":
                    position = checkElementOrder("derivedFromCanonical", 28, position, true);
                    builder.derivedFromCanonical((Canonical) parseUri(Canonical.builder(), "derivedFromCanonical", reader, derivedFromCanonicalElementIndex++));
                    break;
                case "derivedFromUri":
                    position = checkElementOrder("derivedFromUri", 29, position, true);
                    builder.derivedFromUri(parseUri("derivedFromUri", reader, derivedFromUriElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 30, position, true);
                    builder.subject(parseCodeableConcept("subject", reader, subjectElementIndex++));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 31, position, false);
                    builder.performerType(parseCodeableConcept("performerType", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 32, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 33, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "permittedDataType":
                    position = checkElementOrder("permittedDataType", 34, position, true);
                    builder.permittedDataType((ObservationDataType) parseString(ObservationDataType.builder(), "permittedDataType", reader, permittedDataTypeElementIndex++));
                    break;
                case "multipleResultsAllowed":
                    position = checkElementOrder("multipleResultsAllowed", 35, position, false);
                    builder.multipleResultsAllowed(parseBoolean("multipleResultsAllowed", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 36, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 37, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 38, position, true);
                    builder.specimen(parseReference("specimen", reader, specimenElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 39, position, true);
                    builder.device(parseReference("device", reader, deviceElementIndex++));
                    break;
                case "preferredReportName":
                    position = checkElementOrder("preferredReportName", 40, position, false);
                    builder.preferredReportName(parseString("preferredReportName", reader, -1));
                    break;
                case "permittedUnit":
                    position = checkElementOrder("permittedUnit", 41, position, true);
                    builder.permittedUnit(parseCoding("permittedUnit", reader, permittedUnitElementIndex++));
                    break;
                case "qualifiedValue":
                    position = checkElementOrder("qualifiedValue", 42, position, true);
                    builder.qualifiedValue(parseObservationDefinitionQualifiedValue("qualifiedValue", reader, qualifiedValueElementIndex++));
                    break;
                case "hasMember":
                    position = checkElementOrder("hasMember", 43, position, true);
                    builder.hasMember(parseReference("hasMember", reader, hasMemberElementIndex++));
                    break;
                case "component":
                    position = checkElementOrder("component", 44, position, true);
                    builder.component(parseObservationDefinitionComponent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ObservationDefinition.Component parseObservationDefinitionComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ObservationDefinition.Component.Builder builder = ObservationDefinition.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, permittedDataTypeElementIndex = 0, permittedUnitElementIndex = 0, qualifiedValueElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "permittedDataType":
                    position = checkElementOrder("permittedDataType", 3, position, true);
                    builder.permittedDataType((ObservationDataType) parseString(ObservationDataType.builder(), "permittedDataType", reader, permittedDataTypeElementIndex++));
                    break;
                case "permittedUnit":
                    position = checkElementOrder("permittedUnit", 4, position, true);
                    builder.permittedUnit(parseCoding("permittedUnit", reader, permittedUnitElementIndex++));
                    break;
                case "qualifiedValue":
                    position = checkElementOrder("qualifiedValue", 5, position, true);
                    builder.qualifiedValue(parseObservationDefinitionQualifiedValue("qualifiedValue", reader, qualifiedValueElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ObservationDefinition.QualifiedValue parseObservationDefinitionQualifiedValue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ObservationDefinition.QualifiedValue.Builder builder = ObservationDefinition.QualifiedValue.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, appliesToElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "context":
                    position = checkElementOrder("context", 2, position, false);
                    builder.context(parseCodeableConcept("context", reader, -1));
                    break;
                case "appliesTo":
                    position = checkElementOrder("appliesTo", 3, position, true);
                    builder.appliesTo(parseCodeableConcept("appliesTo", reader, appliesToElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 4, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "age":
                    position = checkElementOrder("age", 5, position, false);
                    builder.age(parseRange("age", reader, -1));
                    break;
                case "gestationalAge":
                    position = checkElementOrder("gestationalAge", 6, position, false);
                    builder.gestationalAge(parseRange("gestationalAge", reader, -1));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 7, position, false);
                    builder.condition(parseString("condition", reader, -1));
                    break;
                case "rangeCategory":
                    position = checkElementOrder("rangeCategory", 8, position, false);
                    builder.rangeCategory((ObservationRangeCategory) parseString(ObservationRangeCategory.builder(), "rangeCategory", reader, -1));
                    break;
                case "range":
                    position = checkElementOrder("range", 9, position, false);
                    builder.range(parseRange("range", reader, -1));
                    break;
                case "validCodedValueSet":
                    position = checkElementOrder("validCodedValueSet", 10, position, false);
                    builder.validCodedValueSet((Canonical) parseUri(Canonical.builder(), "validCodedValueSet", reader, -1));
                    break;
                case "normalCodedValueSet":
                    position = checkElementOrder("normalCodedValueSet", 11, position, false);
                    builder.normalCodedValueSet((Canonical) parseUri(Canonical.builder(), "normalCodedValueSet", reader, -1));
                    break;
                case "abnormalCodedValueSet":
                    position = checkElementOrder("abnormalCodedValueSet", 12, position, false);
                    builder.abnormalCodedValueSet((Canonical) parseUri(Canonical.builder(), "abnormalCodedValueSet", reader, -1));
                    break;
                case "criticalCodedValueSet":
                    position = checkElementOrder("criticalCodedValueSet", 13, position, false);
                    builder.criticalCodedValueSet((Canonical) parseUri(Canonical.builder(), "criticalCodedValueSet", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition parseOperationDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Builder builder = OperationDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, resourceElementIndex = 0, parameterElementIndex = 0, overloadElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 15, position, false);
                    builder.kind((OperationKind) parseString(OperationKind.builder(), "kind", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 24, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 25, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "affectsState":
                    position = checkElementOrder("affectsState", 26, position, false);
                    builder.affectsState(parseBoolean("affectsState", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 27, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 28, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 29, position, false);
                    builder.base((Canonical) parseUri(Canonical.builder(), "base", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 30, position, true);
                    builder.resource((FHIRTypes) parseString(FHIRTypes.builder(), "resource", reader, resourceElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 31, position, false);
                    builder.system(parseBoolean("system", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 32, position, false);
                    builder.type(parseBoolean("type", reader, -1));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 33, position, false);
                    builder.instance(parseBoolean("instance", reader, -1));
                    break;
                case "inputProfile":
                    position = checkElementOrder("inputProfile", 34, position, false);
                    builder.inputProfile((Canonical) parseUri(Canonical.builder(), "inputProfile", reader, -1));
                    break;
                case "outputProfile":
                    position = checkElementOrder("outputProfile", 35, position, false);
                    builder.outputProfile((Canonical) parseUri(Canonical.builder(), "outputProfile", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 36, position, true);
                    builder.parameter(parseOperationDefinitionParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "overload":
                    position = checkElementOrder("overload", 37, position, true);
                    builder.overload(parseOperationDefinitionOverload("overload", reader, overloadElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition.Overload parseOperationDefinitionOverload(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Overload.Builder builder = OperationDefinition.Overload.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, parameterNameElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "parameterName":
                    position = checkElementOrder("parameterName", 2, position, true);
                    builder.parameterName(parseString("parameterName", reader, parameterNameElementIndex++));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 3, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition.Parameter parseOperationDefinitionParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Parameter.Builder builder = OperationDefinition.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, scopeElementIndex = 0, allowedTypeElementIndex = 0, targetProfileElementIndex = 0, referencedFromElementIndex = 0, partElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Code) parseString(Code.builder(), "name", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use((OperationParameterUse) parseString(OperationParameterUse.builder(), "use", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 4, position, true);
                    builder.scope((OperationParameterScope) parseString(OperationParameterScope.builder(), "scope", reader, scopeElementIndex++));
                    break;
                case "min":
                    position = checkElementOrder("min", 5, position, false);
                    builder.min(parseInteger("min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 6, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 7, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 8, position, false);
                    builder.type((FHIRAllTypes) parseString(FHIRAllTypes.builder(), "type", reader, -1));
                    break;
                case "allowedType":
                    position = checkElementOrder("allowedType", 9, position, true);
                    builder.allowedType((FHIRAllTypes) parseString(FHIRAllTypes.builder(), "allowedType", reader, allowedTypeElementIndex++));
                    break;
                case "targetProfile":
                    position = checkElementOrder("targetProfile", 10, position, true);
                    builder.targetProfile((Canonical) parseUri(Canonical.builder(), "targetProfile", reader, targetProfileElementIndex++));
                    break;
                case "searchType":
                    position = checkElementOrder("searchType", 11, position, false);
                    builder.searchType((SearchParamType) parseString(SearchParamType.builder(), "searchType", reader, -1));
                    break;
                case "binding":
                    position = checkElementOrder("binding", 12, position, false);
                    builder.binding(parseOperationDefinitionParameterBinding("binding", reader, -1));
                    break;
                case "referencedFrom":
                    position = checkElementOrder("referencedFrom", 13, position, true);
                    builder.referencedFrom(parseOperationDefinitionParameterReferencedFrom("referencedFrom", reader, referencedFromElementIndex++));
                    break;
                case "part":
                    position = checkElementOrder("part", 14, position, true);
                    builder.part(parseOperationDefinitionParameter("part", reader, partElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition.Parameter.Binding parseOperationDefinitionParameterBinding(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Parameter.Binding.Builder builder = OperationDefinition.Parameter.Binding.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "strength":
                    position = checkElementOrder("strength", 2, position, false);
                    builder.strength((BindingStrength) parseString(BindingStrength.builder(), "strength", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 3, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition.Parameter.ReferencedFrom parseOperationDefinitionParameterReferencedFrom(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Parameter.ReferencedFrom.Builder builder = OperationDefinition.Parameter.ReferencedFrom.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 2, position, false);
                    builder.source(parseString("source", reader, -1));
                    break;
                case "sourceId":
                    position = checkElementOrder("sourceId", 3, position, false);
                    builder.sourceId(parseString("sourceId", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationOutcome parseOperationOutcome(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationOutcome.Builder builder = OperationOutcome.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, issueElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "issue":
                    position = checkElementOrder("issue", 8, position, true);
                    builder.issue(parseOperationOutcomeIssue("issue", reader, issueElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationOutcome.Issue parseOperationOutcomeIssue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationOutcome.Issue.Builder builder = OperationOutcome.Issue.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, locationElementIndex = 0, expressionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 2, position, false);
                    builder.severity((IssueSeverity) parseString(IssueSeverity.builder(), "severity", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code((IssueType) parseString(IssueType.builder(), "code", reader, -1));
                    break;
                case "details":
                    position = checkElementOrder("details", 4, position, false);
                    builder.details(parseCodeableConcept("details", reader, -1));
                    break;
                case "diagnostics":
                    position = checkElementOrder("diagnostics", 5, position, false);
                    builder.diagnostics(parseString("diagnostics", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 6, position, true);
                    builder.location(parseString("location", reader, locationElementIndex++));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 7, position, true);
                    builder.expression(parseString("expression", reader, expressionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Organization parseOrganization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Organization.Builder builder = Organization.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, typeElementIndex = 0, aliasElementIndex = 0, contactElementIndex = 0, endpointElementIndex = 0, qualificationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 12, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 13, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 14, position, true);
                    builder.contact(parseExtendedContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 15, position, false);
                    builder.partOf(parseReference("partOf", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 16, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                case "qualification":
                    position = checkElementOrder("qualification", 17, position, true);
                    builder.qualification(parseOrganizationQualification("qualification", reader, qualificationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Organization.Qualification parseOrganizationQualification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Organization.Qualification.Builder builder = Organization.Qualification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 5, position, false);
                    builder.issuer(parseReference("issuer", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OrganizationAffiliation parseOrganizationAffiliation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OrganizationAffiliation.Builder builder = OrganizationAffiliation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, networkElementIndex = 0, codeElementIndex = 0, specialtyElementIndex = 0, locationElementIndex = 0, healthcareServiceElementIndex = 0, contactElementIndex = 0, endpointElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 11, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "participatingOrganization":
                    position = checkElementOrder("participatingOrganization", 12, position, false);
                    builder.participatingOrganization(parseReference("participatingOrganization", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 13, position, true);
                    builder.network(parseReference("network", reader, networkElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 14, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 15, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 16, position, true);
                    builder.location(parseReference("location", reader, locationElementIndex++));
                    break;
                case "healthcareService":
                    position = checkElementOrder("healthcareService", 17, position, true);
                    builder.healthcareService(parseReference("healthcareService", reader, healthcareServiceElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseExtendedContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 19, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition parsePackagedProductDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.Builder builder = PackagedProductDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, packageForElementIndex = 0, containedItemQuantityElementIndex = 0, legalStatusOfSupplyElementIndex = 0, marketingStatusElementIndex = 0, manufacturerElementIndex = 0, attachedDocumentElementIndex = 0, characteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 9, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "packageFor":
                    position = checkElementOrder("packageFor", 11, position, true);
                    builder.packageFor(parseReference("packageFor", reader, packageForElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 13, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "containedItemQuantity":
                    position = checkElementOrder("containedItemQuantity", 14, position, true);
                    builder.containedItemQuantity(parseQuantity("containedItemQuantity", reader, containedItemQuantityElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 15, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "legalStatusOfSupply":
                    position = checkElementOrder("legalStatusOfSupply", 16, position, true);
                    builder.legalStatusOfSupply(parsePackagedProductDefinitionLegalStatusOfSupply("legalStatusOfSupply", reader, legalStatusOfSupplyElementIndex++));
                    break;
                case "marketingStatus":
                    position = checkElementOrder("marketingStatus", 17, position, true);
                    builder.marketingStatus(parseMarketingStatus("marketingStatus", reader, marketingStatusElementIndex++));
                    break;
                case "copackagedIndicator":
                    position = checkElementOrder("copackagedIndicator", 18, position, false);
                    builder.copackagedIndicator(parseBoolean("copackagedIndicator", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 19, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "attachedDocument":
                    position = checkElementOrder("attachedDocument", 20, position, true);
                    builder.attachedDocument(parseReference("attachedDocument", reader, attachedDocumentElementIndex++));
                    break;
                case "packaging":
                    position = checkElementOrder("packaging", 21, position, false);
                    builder.packaging(parsePackagedProductDefinitionPackaging("packaging", reader, -1));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 22, position, true);
                    builder.characteristic(parsePackagedProductDefinitionPackagingProperty("characteristic", reader, characteristicElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition.LegalStatusOfSupply parsePackagedProductDefinitionLegalStatusOfSupply(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.LegalStatusOfSupply.Builder builder = PackagedProductDefinition.LegalStatusOfSupply.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 3, position, false);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition.Packaging parsePackagedProductDefinitionPackaging(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.Packaging.Builder builder = PackagedProductDefinition.Packaging.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, materialElementIndex = 0, alternateMaterialElementIndex = 0, shelfLifeStorageElementIndex = 0, manufacturerElementIndex = 0, propertyElementIndex = 0, containedItemElementIndex = 0, packagingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "componentPart":
                    position = checkElementOrder("componentPart", 4, position, false);
                    builder.componentPart(parseBoolean("componentPart", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity(parseInteger("quantity", reader, -1));
                    break;
                case "material":
                    position = checkElementOrder("material", 6, position, true);
                    builder.material(parseCodeableConcept("material", reader, materialElementIndex++));
                    break;
                case "alternateMaterial":
                    position = checkElementOrder("alternateMaterial", 7, position, true);
                    builder.alternateMaterial(parseCodeableConcept("alternateMaterial", reader, alternateMaterialElementIndex++));
                    break;
                case "shelfLifeStorage":
                    position = checkElementOrder("shelfLifeStorage", 8, position, true);
                    builder.shelfLifeStorage(parseProductShelfLife("shelfLifeStorage", reader, shelfLifeStorageElementIndex++));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 9, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 10, position, true);
                    builder.property(parsePackagedProductDefinitionPackagingProperty("property", reader, propertyElementIndex++));
                    break;
                case "containedItem":
                    position = checkElementOrder("containedItem", 11, position, true);
                    builder.containedItem(parsePackagedProductDefinitionPackagingContainedItem("containedItem", reader, containedItemElementIndex++));
                    break;
                case "packaging":
                    position = checkElementOrder("packaging", 12, position, true);
                    builder.packaging(parsePackagedProductDefinitionPackaging("packaging", reader, packagingElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition.Packaging.ContainedItem parsePackagedProductDefinitionPackagingContainedItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.Packaging.ContainedItem.Builder builder = PackagedProductDefinition.Packaging.ContainedItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 2, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, false);
                    builder.amount(parseQuantity("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition.Packaging.Property parsePackagedProductDefinitionPackagingProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.Packaging.Property.Builder builder = PackagedProductDefinition.Packaging.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ParameterDefinition parseParameterDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ParameterDefinition.Builder builder = ParameterDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 1, position, false);
                    builder.name((Code) parseString(Code.builder(), "name", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 2, position, false);
                    builder.use((ParameterUse) parseString(ParameterUse.builder(), "use", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 3, position, false);
                    builder.min(parseInteger("min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 4, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 6, position, false);
                    builder.type((FHIRTypes) parseString(FHIRTypes.builder(), "type", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 7, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Parameters parseParameters(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Parameters.Builder builder = Parameters.builder();
        builder.setValidating(validating);
        int position = -1;
        int parameterElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 4, position, true);
                    builder.parameter(parseParametersParameter("parameter", reader, parameterElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Parameters.Parameter parseParametersParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Parameters.Parameter.Builder builder = Parameters.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, partElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueInteger64":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger64("valueInteger64", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCodeableReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableReference("valueCodeableReference", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRatioRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatioRange("valueRatioRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueAvailability":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAvailability("valueAvailability", reader, -1));
                    break;
                case "valueExtendedContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExtendedContactDetail("valueExtendedContactDetail", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 4, position, false);
                    builder.resource(parseResource("resource", reader, -1));
                    break;
                case "part":
                    position = checkElementOrder("part", 5, position, true);
                    builder.part(parseParametersParameter("part", reader, partElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Patient parsePatient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Patient.Builder builder = Patient.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, nameElementIndex = 0, telecomElementIndex = 0, addressElementIndex = 0, photoElementIndex = 0, contactElementIndex = 0, communicationElementIndex = 0, generalPractitionerElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, true);
                    builder.name(parseHumanName("name", reader, nameElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 11, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 12, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "birthDate":
                    position = checkElementOrder("birthDate", 13, position, false);
                    builder.birthDate(parseDate("birthDate", reader, -1));
                    break;
                case "deceasedBoolean":
                    position = checkElementOrder("deceased[x]", 14, position, false);
                    builder.deceased(parseBoolean("deceasedBoolean", reader, -1));
                    break;
                case "deceasedDateTime":
                    position = checkElementOrder("deceased[x]", 14, position, false);
                    builder.deceased(parseDateTime("deceasedDateTime", reader, -1));
                    break;
                case "address":
                    position = checkElementOrder("address", 15, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "maritalStatus":
                    position = checkElementOrder("maritalStatus", 16, position, false);
                    builder.maritalStatus(parseCodeableConcept("maritalStatus", reader, -1));
                    break;
                case "multipleBirthBoolean":
                    position = checkElementOrder("multipleBirth[x]", 17, position, false);
                    builder.multipleBirth(parseBoolean("multipleBirthBoolean", reader, -1));
                    break;
                case "multipleBirthInteger":
                    position = checkElementOrder("multipleBirth[x]", 17, position, false);
                    builder.multipleBirth(parseInteger("multipleBirthInteger", reader, -1));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 18, position, true);
                    builder.photo(parseAttachment("photo", reader, photoElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parsePatientContact("contact", reader, contactElementIndex++));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 20, position, true);
                    builder.communication(parsePatientCommunication("communication", reader, communicationElementIndex++));
                    break;
                case "generalPractitioner":
                    position = checkElementOrder("generalPractitioner", 21, position, true);
                    builder.generalPractitioner(parseReference("generalPractitioner", reader, generalPractitionerElementIndex++));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 22, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 23, position, true);
                    builder.link(parsePatientLink("link", reader, linkElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Patient.Communication parsePatientCommunication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Patient.Communication.Builder builder = Patient.Communication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 3, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Patient.Contact parsePatientContact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Patient.Contact.Builder builder = Patient.Contact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, relationshipElementIndex = 0, telecomElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 2, position, true);
                    builder.relationship(parseCodeableConcept("relationship", reader, relationshipElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseHumanName("name", reader, -1));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 4, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 5, position, false);
                    builder.address(parseAddress("address", reader, -1));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 6, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 7, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 8, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Patient.Link parsePatientLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Patient.Link.Builder builder = Patient.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "other":
                    position = checkElementOrder("other", 2, position, false);
                    builder.other(parseReference("other", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((LinkType) parseString(LinkType.builder(), "type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PaymentNotice parsePaymentNotice(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PaymentNotice.Builder builder = PaymentNotice.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PaymentNoticeStatus) parseString(PaymentNoticeStatus.builder(), "status", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 10, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 11, position, false);
                    builder.response(parseReference("response", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 12, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "reporter":
                    position = checkElementOrder("reporter", 13, position, false);
                    builder.reporter(parseReference("reporter", reader, -1));
                    break;
                case "payment":
                    position = checkElementOrder("payment", 14, position, false);
                    builder.payment(parseReference("payment", reader, -1));
                    break;
                case "paymentDate":
                    position = checkElementOrder("paymentDate", 15, position, false);
                    builder.paymentDate(parseDate("paymentDate", reader, -1));
                    break;
                case "payee":
                    position = checkElementOrder("payee", 16, position, false);
                    builder.payee(parseReference("payee", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 17, position, false);
                    builder.recipient(parseReference("recipient", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 18, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "paymentStatus":
                    position = checkElementOrder("paymentStatus", 19, position, false);
                    builder.paymentStatus(parseCodeableConcept("paymentStatus", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PaymentReconciliation parsePaymentReconciliation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PaymentReconciliation.Builder builder = PaymentReconciliation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, allocationElementIndex = 0, processNoteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((PaymentReconciliationStatus) parseString(PaymentReconciliationStatus.builder(), "status", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 11, position, false);
                    builder.kind(parseCodeableConcept("kind", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 12, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 13, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 14, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "issuerType":
                    position = checkElementOrder("issuerType", 15, position, false);
                    builder.issuerType(parseCodeableConcept("issuerType", reader, -1));
                    break;
                case "paymentIssuer":
                    position = checkElementOrder("paymentIssuer", 16, position, false);
                    builder.paymentIssuer(parseReference("paymentIssuer", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 17, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "requestor":
                    position = checkElementOrder("requestor", 18, position, false);
                    builder.requestor(parseReference("requestor", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 19, position, false);
                    builder.outcome((PaymentOutcome) parseString(PaymentOutcome.builder(), "outcome", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 20, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 21, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 22, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 23, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "cardBrand":
                    position = checkElementOrder("cardBrand", 24, position, false);
                    builder.cardBrand(parseString("cardBrand", reader, -1));
                    break;
                case "accountNumber":
                    position = checkElementOrder("accountNumber", 25, position, false);
                    builder.accountNumber(parseString("accountNumber", reader, -1));
                    break;
                case "expirationDate":
                    position = checkElementOrder("expirationDate", 26, position, false);
                    builder.expirationDate(parseDate("expirationDate", reader, -1));
                    break;
                case "processor":
                    position = checkElementOrder("processor", 27, position, false);
                    builder.processor(parseString("processor", reader, -1));
                    break;
                case "referenceNumber":
                    position = checkElementOrder("referenceNumber", 28, position, false);
                    builder.referenceNumber(parseString("referenceNumber", reader, -1));
                    break;
                case "authorization":
                    position = checkElementOrder("authorization", 29, position, false);
                    builder.authorization(parseString("authorization", reader, -1));
                    break;
                case "tenderedAmount":
                    position = checkElementOrder("tenderedAmount", 30, position, false);
                    builder.tenderedAmount(parseMoney("tenderedAmount", reader, -1));
                    break;
                case "returnedAmount":
                    position = checkElementOrder("returnedAmount", 31, position, false);
                    builder.returnedAmount(parseMoney("returnedAmount", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 32, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "paymentIdentifier":
                    position = checkElementOrder("paymentIdentifier", 33, position, false);
                    builder.paymentIdentifier(parseIdentifier("paymentIdentifier", reader, -1));
                    break;
                case "allocation":
                    position = checkElementOrder("allocation", 34, position, true);
                    builder.allocation(parsePaymentReconciliationAllocation("allocation", reader, allocationElementIndex++));
                    break;
                case "formCode":
                    position = checkElementOrder("formCode", 35, position, false);
                    builder.formCode(parseCodeableConcept("formCode", reader, -1));
                    break;
                case "processNote":
                    position = checkElementOrder("processNote", 36, position, true);
                    builder.processNote(parsePaymentReconciliationProcessNote("processNote", reader, processNoteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PaymentReconciliation.Allocation parsePaymentReconciliationAllocation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PaymentReconciliation.Allocation.Builder builder = PaymentReconciliation.Allocation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "predecessor":
                    position = checkElementOrder("predecessor", 3, position, false);
                    builder.predecessor(parseIdentifier("predecessor", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 4, position, false);
                    builder.target(parseReference("target", reader, -1));
                    break;
                case "targetItemString":
                    position = checkElementOrder("targetItem[x]", 5, position, false);
                    builder.targetItem(parseString("targetItemString", reader, -1));
                    break;
                case "targetItemIdentifier":
                    position = checkElementOrder("targetItem[x]", 5, position, false);
                    builder.targetItem(parseIdentifier("targetItemIdentifier", reader, -1));
                    break;
                case "targetItemPositiveInt":
                    position = checkElementOrder("targetItem[x]", 5, position, false);
                    builder.targetItem((PositiveInt) parseInteger(PositiveInt.builder(), "targetItemPositiveInt", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 6, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "account":
                    position = checkElementOrder("account", 7, position, false);
                    builder.account(parseReference("account", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 8, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "submitter":
                    position = checkElementOrder("submitter", 9, position, false);
                    builder.submitter(parseReference("submitter", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 10, position, false);
                    builder.response(parseReference("response", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 11, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 12, position, false);
                    builder.responsible(parseReference("responsible", reader, -1));
                    break;
                case "payee":
                    position = checkElementOrder("payee", 13, position, false);
                    builder.payee(parseReference("payee", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 14, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PaymentReconciliation.ProcessNote parsePaymentReconciliationProcessNote(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PaymentReconciliation.ProcessNote.Builder builder = PaymentReconciliation.ProcessNote.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((NoteType) parseString(NoteType.builder(), "type", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 3, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Period parsePeriod(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Period.Builder builder = Period.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "start":
                    position = checkElementOrder("start", 1, position, false);
                    builder.start(parseDateTime("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 2, position, false);
                    builder.end(parseDateTime("end", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Permission parsePermission(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Permission.Builder builder = Permission.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, dateElementIndex = 0, ruleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 8, position, false);
                    builder.status((PermissionStatus) parseString(PermissionStatus.builder(), "status", reader, -1));
                    break;
                case "asserter":
                    position = checkElementOrder("asserter", 9, position, false);
                    builder.asserter(parseReference("asserter", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 10, position, true);
                    builder.date(parseDateTime("date", reader, dateElementIndex++));
                    break;
                case "validity":
                    position = checkElementOrder("validity", 11, position, false);
                    builder.validity(parsePeriod("validity", reader, -1));
                    break;
                case "justification":
                    position = checkElementOrder("justification", 12, position, false);
                    builder.justification(parsePermissionJustification("justification", reader, -1));
                    break;
                case "combining":
                    position = checkElementOrder("combining", 13, position, false);
                    builder.combining((PermissionCombining) parseString(PermissionCombining.builder(), "combining", reader, -1));
                    break;
                case "rule":
                    position = checkElementOrder("rule", 14, position, true);
                    builder.rule(parsePermissionRule("rule", reader, ruleElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Permission.Justification parsePermissionJustification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Permission.Justification.Builder builder = Permission.Justification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, basisElementIndex = 0, evidenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 2, position, true);
                    builder.basis(parseCodeableConcept("basis", reader, basisElementIndex++));
                    break;
                case "evidence":
                    position = checkElementOrder("evidence", 3, position, true);
                    builder.evidence(parseReference("evidence", reader, evidenceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Permission.Rule parsePermissionRule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Permission.Rule.Builder builder = Permission.Rule.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dataElementIndex = 0, activityElementIndex = 0, limitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((PermissionProvisionType) parseString(PermissionProvisionType.builder(), "type", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 3, position, true);
                    builder.data(parsePermissionRuleData("data", reader, dataElementIndex++));
                    break;
                case "activity":
                    position = checkElementOrder("activity", 4, position, true);
                    builder.activity(parsePermissionRuleActivity("activity", reader, activityElementIndex++));
                    break;
                case "limit":
                    position = checkElementOrder("limit", 5, position, true);
                    builder.limit(parseCodeableConcept("limit", reader, limitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Permission.Rule.Activity parsePermissionRuleActivity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Permission.Rule.Activity.Builder builder = Permission.Rule.Activity.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actorElementIndex = 0, actionElementIndex = 0, purposeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 2, position, true);
                    builder.actor(parseReference("actor", reader, actorElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 3, position, true);
                    builder.action(parseCodeableConcept("action", reader, actionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 4, position, true);
                    builder.purpose(parseCodeableConcept("purpose", reader, purposeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Permission.Rule.Data parsePermissionRuleData(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Permission.Rule.Data.Builder builder = Permission.Rule.Data.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, resourceElementIndex = 0, securityElementIndex = 0, periodElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 2, position, true);
                    builder.resource(parsePermissionRuleDataResource("resource", reader, resourceElementIndex++));
                    break;
                case "security":
                    position = checkElementOrder("security", 3, position, true);
                    builder.security(parseCoding("security", reader, securityElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, true);
                    builder.period(parsePeriod("period", reader, periodElementIndex++));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 5, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Permission.Rule.Data.Resource parsePermissionRuleDataResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Permission.Rule.Data.Resource.Builder builder = Permission.Rule.Data.Resource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "meaning":
                    position = checkElementOrder("meaning", 2, position, false);
                    builder.meaning((ConsentDataMeaning) parseString(ConsentDataMeaning.builder(), "meaning", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Person parsePerson(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Person.Builder builder = Person.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, nameElementIndex = 0, telecomElementIndex = 0, addressElementIndex = 0, photoElementIndex = 0, communicationElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, true);
                    builder.name(parseHumanName("name", reader, nameElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 11, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 12, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "birthDate":
                    position = checkElementOrder("birthDate", 13, position, false);
                    builder.birthDate(parseDate("birthDate", reader, -1));
                    break;
                case "deceasedBoolean":
                    position = checkElementOrder("deceased[x]", 14, position, false);
                    builder.deceased(parseBoolean("deceasedBoolean", reader, -1));
                    break;
                case "deceasedDateTime":
                    position = checkElementOrder("deceased[x]", 14, position, false);
                    builder.deceased(parseDateTime("deceasedDateTime", reader, -1));
                    break;
                case "address":
                    position = checkElementOrder("address", 15, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "maritalStatus":
                    position = checkElementOrder("maritalStatus", 16, position, false);
                    builder.maritalStatus(parseCodeableConcept("maritalStatus", reader, -1));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 17, position, true);
                    builder.photo(parseAttachment("photo", reader, photoElementIndex++));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 18, position, true);
                    builder.communication(parsePersonCommunication("communication", reader, communicationElementIndex++));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 19, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 20, position, true);
                    builder.link(parsePersonLink("link", reader, linkElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Person.Communication parsePersonCommunication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Person.Communication.Builder builder = Person.Communication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 3, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Person.Link parsePersonLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Person.Link.Builder builder = Person.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 2, position, false);
                    builder.target(parseReference("target", reader, -1));
                    break;
                case "assurance":
                    position = checkElementOrder("assurance", 3, position, false);
                    builder.assurance((IdentityAssuranceLevel) parseString(IdentityAssuranceLevel.builder(), "assurance", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition parsePlanDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Builder builder = PlanDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, libraryElementIndex = 0, goalElementIndex = 0, actorElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 14, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 15, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 16, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 17, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 18, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 18, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "subjectCanonical":
                    position = checkElementOrder("subject[x]", 18, position, false);
                    builder.subject((Canonical) parseUri(Canonical.builder(), "subjectCanonical", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 19, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 20, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 21, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 22, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 23, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 24, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 25, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 26, position, false);
                    builder.usage((Markdown) parseString(Markdown.builder(), "usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 27, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 28, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 29, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 30, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 31, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 32, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 33, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 34, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 35, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 36, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 37, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "library":
                    position = checkElementOrder("library", 38, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "goal":
                    position = checkElementOrder("goal", 39, position, true);
                    builder.goal(parsePlanDefinitionGoal("goal", reader, goalElementIndex++));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 40, position, true);
                    builder.actor(parsePlanDefinitionActor("actor", reader, actorElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 41, position, true);
                    builder.action(parsePlanDefinitionAction("action", reader, actionElementIndex++));
                    break;
                case "asNeededBoolean":
                    position = checkElementOrder("asNeeded[x]", 42, position, false);
                    builder.asNeeded(parseBoolean("asNeededBoolean", reader, -1));
                    break;
                case "asNeededCodeableConcept":
                    position = checkElementOrder("asNeeded[x]", 42, position, false);
                    builder.asNeeded(parseCodeableConcept("asNeededCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action parsePlanDefinitionAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.Builder builder = PlanDefinition.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, reasonElementIndex = 0, documentationElementIndex = 0, goalIdElementIndex = 0, triggerElementIndex = 0, conditionElementIndex = 0, inputElementIndex = 0, outputElementIndex = 0, relatedActionElementIndex = 0, participantElementIndex = 0, dynamicValueElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "prefix":
                    position = checkElementOrder("prefix", 3, position, false);
                    builder.prefix(parseString("prefix", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 4, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "textEquivalent":
                    position = checkElementOrder("textEquivalent", 6, position, false);
                    builder.textEquivalent((Markdown) parseString(Markdown.builder(), "textEquivalent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 7, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 8, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 9, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 10, position, true);
                    builder.documentation(parseRelatedArtifact("documentation", reader, documentationElementIndex++));
                    break;
                case "goalId":
                    position = checkElementOrder("goalId", 11, position, true);
                    builder.goalId((Id) parseString(Id.builder(), "goalId", reader, goalIdElementIndex++));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 12, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 12, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "subjectCanonical":
                    position = checkElementOrder("subject[x]", 12, position, false);
                    builder.subject((Canonical) parseUri(Canonical.builder(), "subjectCanonical", reader, -1));
                    break;
                case "trigger":
                    position = checkElementOrder("trigger", 13, position, true);
                    builder.trigger(parseTriggerDefinition("trigger", reader, triggerElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 14, position, true);
                    builder.condition(parsePlanDefinitionActionCondition("condition", reader, conditionElementIndex++));
                    break;
                case "input":
                    position = checkElementOrder("input", 15, position, true);
                    builder.input(parsePlanDefinitionActionInput("input", reader, inputElementIndex++));
                    break;
                case "output":
                    position = checkElementOrder("output", 16, position, true);
                    builder.output(parsePlanDefinitionActionOutput("output", reader, outputElementIndex++));
                    break;
                case "relatedAction":
                    position = checkElementOrder("relatedAction", 17, position, true);
                    builder.relatedAction(parsePlanDefinitionActionRelatedAction("relatedAction", reader, relatedActionElementIndex++));
                    break;
                case "timingAge":
                    position = checkElementOrder("timing[x]", 18, position, false);
                    builder.timing((Age) parseQuantity(Age.builder(), "timingAge", reader, -1));
                    break;
                case "timingDuration":
                    position = checkElementOrder("timing[x]", 18, position, false);
                    builder.timing((Duration) parseQuantity(Duration.builder(), "timingDuration", reader, -1));
                    break;
                case "timingRange":
                    position = checkElementOrder("timing[x]", 18, position, false);
                    builder.timing(parseRange("timingRange", reader, -1));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 18, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 19, position, false);
                    builder.location(parseCodeableReference("location", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 20, position, true);
                    builder.participant(parsePlanDefinitionActionParticipant("participant", reader, participantElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 21, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "groupingBehavior":
                    position = checkElementOrder("groupingBehavior", 22, position, false);
                    builder.groupingBehavior((ActionGroupingBehavior) parseString(ActionGroupingBehavior.builder(), "groupingBehavior", reader, -1));
                    break;
                case "selectionBehavior":
                    position = checkElementOrder("selectionBehavior", 23, position, false);
                    builder.selectionBehavior((ActionSelectionBehavior) parseString(ActionSelectionBehavior.builder(), "selectionBehavior", reader, -1));
                    break;
                case "requiredBehavior":
                    position = checkElementOrder("requiredBehavior", 24, position, false);
                    builder.requiredBehavior((ActionRequiredBehavior) parseString(ActionRequiredBehavior.builder(), "requiredBehavior", reader, -1));
                    break;
                case "precheckBehavior":
                    position = checkElementOrder("precheckBehavior", 25, position, false);
                    builder.precheckBehavior((ActionPrecheckBehavior) parseString(ActionPrecheckBehavior.builder(), "precheckBehavior", reader, -1));
                    break;
                case "cardinalityBehavior":
                    position = checkElementOrder("cardinalityBehavior", 26, position, false);
                    builder.cardinalityBehavior((ActionCardinalityBehavior) parseString(ActionCardinalityBehavior.builder(), "cardinalityBehavior", reader, -1));
                    break;
                case "definitionCanonical":
                    position = checkElementOrder("definition[x]", 27, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definitionCanonical", reader, -1));
                    break;
                case "definitionUri":
                    position = checkElementOrder("definition[x]", 27, position, false);
                    builder.definition(parseUri("definitionUri", reader, -1));
                    break;
                case "transform":
                    position = checkElementOrder("transform", 28, position, false);
                    builder.transform((Canonical) parseUri(Canonical.builder(), "transform", reader, -1));
                    break;
                case "dynamicValue":
                    position = checkElementOrder("dynamicValue", 29, position, true);
                    builder.dynamicValue(parsePlanDefinitionActionDynamicValue("dynamicValue", reader, dynamicValueElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 30, position, true);
                    builder.action(parsePlanDefinitionAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.Condition parsePlanDefinitionActionCondition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.Condition.Builder builder = PlanDefinition.Action.Condition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 2, position, false);
                    builder.kind((ActionConditionKind) parseString(ActionConditionKind.builder(), "kind", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.DynamicValue parsePlanDefinitionActionDynamicValue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.DynamicValue.Builder builder = PlanDefinition.Action.DynamicValue.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.Input parsePlanDefinitionActionInput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.Input.Builder builder = PlanDefinition.Action.Input.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 3, position, false);
                    builder.requirement(parseDataRequirement("requirement", reader, -1));
                    break;
                case "relatedData":
                    position = checkElementOrder("relatedData", 4, position, false);
                    builder.relatedData((Id) parseString(Id.builder(), "relatedData", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.Output parsePlanDefinitionActionOutput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.Output.Builder builder = PlanDefinition.Action.Output.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 3, position, false);
                    builder.requirement(parseDataRequirement("requirement", reader, -1));
                    break;
                case "relatedData":
                    position = checkElementOrder("relatedData", 4, position, false);
                    builder.relatedData(parseString("relatedData", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.Participant parsePlanDefinitionActionParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.Participant.Builder builder = PlanDefinition.Action.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "actorId":
                    position = checkElementOrder("actorId", 2, position, false);
                    builder.actorId(parseString("actorId", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((ActivityParticipantType) parseString(ActivityParticipantType.builder(), "type", reader, -1));
                    break;
                case "typeCanonical":
                    position = checkElementOrder("typeCanonical", 4, position, false);
                    builder.typeCanonical((Canonical) parseUri(Canonical.builder(), "typeCanonical", reader, -1));
                    break;
                case "typeReference":
                    position = checkElementOrder("typeReference", 5, position, false);
                    builder.typeReference(parseReference("typeReference", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 6, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "function":
                    position = checkElementOrder("function", 7, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.RelatedAction parsePlanDefinitionActionRelatedAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.RelatedAction.Builder builder = PlanDefinition.Action.RelatedAction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "targetId":
                    position = checkElementOrder("targetId", 2, position, false);
                    builder.targetId((Id) parseString(Id.builder(), "targetId", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 3, position, false);
                    builder.relationship((ActionRelationshipType) parseString(ActionRelationshipType.builder(), "relationship", reader, -1));
                    break;
                case "endRelationship":
                    position = checkElementOrder("endRelationship", 4, position, false);
                    builder.endRelationship((ActionRelationshipType) parseString(ActionRelationshipType.builder(), "endRelationship", reader, -1));
                    break;
                case "offsetDuration":
                    position = checkElementOrder("offset[x]", 5, position, false);
                    builder.offset((Duration) parseQuantity(Duration.builder(), "offsetDuration", reader, -1));
                    break;
                case "offsetRange":
                    position = checkElementOrder("offset[x]", 5, position, false);
                    builder.offset(parseRange("offsetRange", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Actor parsePlanDefinitionActor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Actor.Builder builder = PlanDefinition.Actor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, optionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "option":
                    position = checkElementOrder("option", 4, position, true);
                    builder.option(parsePlanDefinitionActorOption("option", reader, optionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Actor.Option parsePlanDefinitionActorOption(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Actor.Option.Builder builder = PlanDefinition.Actor.Option.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ActivityParticipantType) parseString(ActivityParticipantType.builder(), "type", reader, -1));
                    break;
                case "typeCanonical":
                    position = checkElementOrder("typeCanonical", 3, position, false);
                    builder.typeCanonical((Canonical) parseUri(Canonical.builder(), "typeCanonical", reader, -1));
                    break;
                case "typeReference":
                    position = checkElementOrder("typeReference", 4, position, false);
                    builder.typeReference(parseReference("typeReference", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 5, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Goal parsePlanDefinitionGoal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Goal.Builder builder = PlanDefinition.Goal.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, addressesElementIndex = 0, documentationElementIndex = 0, targetElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseCodeableConcept("description", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 4, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 5, position, false);
                    builder.start(parseCodeableConcept("start", reader, -1));
                    break;
                case "addresses":
                    position = checkElementOrder("addresses", 6, position, true);
                    builder.addresses(parseCodeableConcept("addresses", reader, addressesElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 7, position, true);
                    builder.documentation(parseRelatedArtifact("documentation", reader, documentationElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 8, position, true);
                    builder.target(parsePlanDefinitionGoalTarget("target", reader, targetElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Goal.Target parsePlanDefinitionGoalTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Goal.Target.Builder builder = PlanDefinition.Goal.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "measure":
                    position = checkElementOrder("measure", 2, position, false);
                    builder.measure(parseCodeableConcept("measure", reader, -1));
                    break;
                case "detailQuantity":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseQuantity("detailQuantity", reader, -1));
                    break;
                case "detailRange":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseRange("detailRange", reader, -1));
                    break;
                case "detailCodeableConcept":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseCodeableConcept("detailCodeableConcept", reader, -1));
                    break;
                case "detailString":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseString("detailString", reader, -1));
                    break;
                case "detailBoolean":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseBoolean("detailBoolean", reader, -1));
                    break;
                case "detailInteger":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseInteger("detailInteger", reader, -1));
                    break;
                case "detailRatio":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseRatio("detailRatio", reader, -1));
                    break;
                case "due":
                    position = checkElementOrder("due", 4, position, false);
                    builder.due((Duration) parseQuantity(Duration.builder(), "due", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Practitioner parsePractitioner(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Practitioner.Builder builder = Practitioner.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, nameElementIndex = 0, telecomElementIndex = 0, addressElementIndex = 0, photoElementIndex = 0, qualificationElementIndex = 0, communicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, true);
                    builder.name(parseHumanName("name", reader, nameElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 11, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 12, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "birthDate":
                    position = checkElementOrder("birthDate", 13, position, false);
                    builder.birthDate(parseDate("birthDate", reader, -1));
                    break;
                case "deceasedBoolean":
                    position = checkElementOrder("deceased[x]", 14, position, false);
                    builder.deceased(parseBoolean("deceasedBoolean", reader, -1));
                    break;
                case "deceasedDateTime":
                    position = checkElementOrder("deceased[x]", 14, position, false);
                    builder.deceased(parseDateTime("deceasedDateTime", reader, -1));
                    break;
                case "address":
                    position = checkElementOrder("address", 15, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 16, position, true);
                    builder.photo(parseAttachment("photo", reader, photoElementIndex++));
                    break;
                case "qualification":
                    position = checkElementOrder("qualification", 17, position, true);
                    builder.qualification(parsePractitionerQualification("qualification", reader, qualificationElementIndex++));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 18, position, true);
                    builder.communication(parsePractitionerCommunication("communication", reader, communicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Practitioner.Communication parsePractitionerCommunication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Practitioner.Communication.Builder builder = Practitioner.Communication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 3, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Practitioner.Qualification parsePractitionerQualification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Practitioner.Qualification.Builder builder = Practitioner.Qualification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 5, position, false);
                    builder.issuer(parseReference("issuer", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PractitionerRole parsePractitionerRole(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PractitionerRole.Builder builder = PractitionerRole.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, codeElementIndex = 0, specialtyElementIndex = 0, locationElementIndex = 0, healthcareServiceElementIndex = 0, contactElementIndex = 0, characteristicElementIndex = 0, communicationElementIndex = 0, availabilityElementIndex = 0, endpointElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "practitioner":
                    position = checkElementOrder("practitioner", 11, position, false);
                    builder.practitioner(parseReference("practitioner", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 12, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 13, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 14, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 15, position, true);
                    builder.location(parseReference("location", reader, locationElementIndex++));
                    break;
                case "healthcareService":
                    position = checkElementOrder("healthcareService", 16, position, true);
                    builder.healthcareService(parseReference("healthcareService", reader, healthcareServiceElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseExtendedContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 18, position, true);
                    builder.characteristic(parseCodeableConcept("characteristic", reader, characteristicElementIndex++));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 19, position, true);
                    builder.communication(parseCodeableConcept("communication", reader, communicationElementIndex++));
                    break;
                case "availability":
                    position = checkElementOrder("availability", 20, position, true);
                    builder.availability(parseAvailability("availability", reader, availabilityElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 21, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Procedure parseProcedure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Procedure.Builder builder = Procedure.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, categoryElementIndex = 0, performerElementIndex = 0, reasonElementIndex = 0, bodySiteElementIndex = 0, reportElementIndex = 0, complicationElementIndex = 0, followUpElementIndex = 0, noteElementIndex = 0, focalDeviceElementIndex = 0, usedElementIndex = 0, supportingInfoElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 12, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((ProcedureStatus) parseString(ProcedureStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 14, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 15, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 16, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 17, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 18, position, false);
                    builder.focus(parseReference("focus", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 19, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 20, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 20, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceString":
                    position = checkElementOrder("occurrence[x]", 20, position, false);
                    builder.occurrence(parseString("occurrenceString", reader, -1));
                    break;
                case "occurrenceAge":
                    position = checkElementOrder("occurrence[x]", 20, position, false);
                    builder.occurrence((Age) parseQuantity(Age.builder(), "occurrenceAge", reader, -1));
                    break;
                case "occurrenceRange":
                    position = checkElementOrder("occurrence[x]", 20, position, false);
                    builder.occurrence(parseRange("occurrenceRange", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 20, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "recorded":
                    position = checkElementOrder("recorded", 21, position, false);
                    builder.recorded(parseDateTime("recorded", reader, -1));
                    break;
                case "recorder":
                    position = checkElementOrder("recorder", 22, position, false);
                    builder.recorder(parseReference("recorder", reader, -1));
                    break;
                case "reportedBoolean":
                    position = checkElementOrder("reported[x]", 23, position, false);
                    builder.reported(parseBoolean("reportedBoolean", reader, -1));
                    break;
                case "reportedReference":
                    position = checkElementOrder("reported[x]", 23, position, false);
                    builder.reported(parseReference("reportedReference", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 24, position, true);
                    builder.performer(parseProcedurePerformer("performer", reader, performerElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 25, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 26, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 27, position, true);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 28, position, false);
                    builder.outcome(parseCodeableConcept("outcome", reader, -1));
                    break;
                case "report":
                    position = checkElementOrder("report", 29, position, true);
                    builder.report(parseReference("report", reader, reportElementIndex++));
                    break;
                case "complication":
                    position = checkElementOrder("complication", 30, position, true);
                    builder.complication(parseCodeableReference("complication", reader, complicationElementIndex++));
                    break;
                case "followUp":
                    position = checkElementOrder("followUp", 31, position, true);
                    builder.followUp(parseCodeableConcept("followUp", reader, followUpElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 32, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "focalDevice":
                    position = checkElementOrder("focalDevice", 33, position, true);
                    builder.focalDevice(parseProcedureFocalDevice("focalDevice", reader, focalDeviceElementIndex++));
                    break;
                case "used":
                    position = checkElementOrder("used", 34, position, true);
                    builder.used(parseCodeableReference("used", reader, usedElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 35, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Procedure.FocalDevice parseProcedureFocalDevice(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Procedure.FocalDevice.Builder builder = Procedure.FocalDevice.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, false);
                    builder.action(parseCodeableConcept("action", reader, -1));
                    break;
                case "manipulated":
                    position = checkElementOrder("manipulated", 3, position, false);
                    builder.manipulated(parseReference("manipulated", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Procedure.Performer parseProcedurePerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Procedure.Performer.Builder builder = Procedure.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 4, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ProductShelfLife parseProductShelfLife(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ProductShelfLife.Builder builder = ProductShelfLife.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, specialPrecautionsForStorageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "periodDuration":
                    position = checkElementOrder("period[x]", 3, position, false);
                    builder.period((Duration) parseQuantity(Duration.builder(), "periodDuration", reader, -1));
                    break;
                case "periodString":
                    position = checkElementOrder("period[x]", 3, position, false);
                    builder.period(parseString("periodString", reader, -1));
                    break;
                case "specialPrecautionsForStorage":
                    position = checkElementOrder("specialPrecautionsForStorage", 4, position, true);
                    builder.specialPrecautionsForStorage(parseCodeableConcept("specialPrecautionsForStorage", reader, specialPrecautionsForStorageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Provenance parseProvenance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Provenance.Builder builder = Provenance.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetElementIndex = 0, policyElementIndex = 0, authorizationElementIndex = 0, basedOnElementIndex = 0, agentElementIndex = 0, entityElementIndex = 0, signatureElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 8, position, true);
                    builder.target(parseReference("target", reader, targetElementIndex++));
                    break;
                case "occurredPeriod":
                    position = checkElementOrder("occurred[x]", 9, position, false);
                    builder.occurred(parsePeriod("occurredPeriod", reader, -1));
                    break;
                case "occurredDateTime":
                    position = checkElementOrder("occurred[x]", 9, position, false);
                    builder.occurred(parseDateTime("occurredDateTime", reader, -1));
                    break;
                case "recorded":
                    position = checkElementOrder("recorded", 10, position, false);
                    builder.recorded(parseInstant("recorded", reader, -1));
                    break;
                case "policy":
                    position = checkElementOrder("policy", 11, position, true);
                    builder.policy(parseUri("policy", reader, policyElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 12, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "authorization":
                    position = checkElementOrder("authorization", 13, position, true);
                    builder.authorization(parseCodeableReference("authorization", reader, authorizationElementIndex++));
                    break;
                case "activity":
                    position = checkElementOrder("activity", 14, position, false);
                    builder.activity(parseCodeableConcept("activity", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 15, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 16, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 17, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "agent":
                    position = checkElementOrder("agent", 18, position, true);
                    builder.agent(parseProvenanceAgent("agent", reader, agentElementIndex++));
                    break;
                case "entity":
                    position = checkElementOrder("entity", 19, position, true);
                    builder.entity(parseProvenanceEntity("entity", reader, entityElementIndex++));
                    break;
                case "signature":
                    position = checkElementOrder("signature", 20, position, true);
                    builder.signature(parseSignature("signature", reader, signatureElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Provenance.Agent parseProvenanceAgent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Provenance.Agent.Builder builder = Provenance.Agent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, roleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, true);
                    builder.role(parseCodeableConcept("role", reader, roleElementIndex++));
                    break;
                case "who":
                    position = checkElementOrder("who", 4, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 5, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Provenance.Entity parseProvenanceEntity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Provenance.Entity.Builder builder = Provenance.Entity.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, agentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role((ProvenanceEntityRole) parseString(ProvenanceEntityRole.builder(), "role", reader, -1));
                    break;
                case "what":
                    position = checkElementOrder("what", 3, position, false);
                    builder.what(parseReference("what", reader, -1));
                    break;
                case "agent":
                    position = checkElementOrder("agent", 4, position, true);
                    builder.agent(parseProvenanceAgent("agent", reader, agentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Quantity parseQuantity(Quantity.Builder builder, java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 1, position, false);
                    builder.value(parseDecimal("value", reader, -1));
                    break;
                case "comparator":
                    position = checkElementOrder("comparator", 2, position, false);
                    builder.comparator((QuantityComparator) parseString(QuantityComparator.builder(), "comparator", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 3, position, false);
                    builder.unit(parseString("unit", reader, -1));
                    break;
                case "system":
                    position = checkElementOrder("system", 4, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 5, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Quantity parseQuantity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        return parseQuantity(Quantity.builder(), elementName, reader, elementIndex);
    }

    private Questionnaire parseQuestionnaire(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Builder builder = Questionnaire.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, derivedFromElementIndex = 0, subjectTypeElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, codeElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 14, position, true);
                    builder.derivedFrom((Canonical) parseUri(Canonical.builder(), "derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectType":
                    position = checkElementOrder("subjectType", 17, position, true);
                    builder.subjectType((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "subjectType", reader, subjectTypeElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 18, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 19, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 20, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 21, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 22, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 23, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 24, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 25, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 26, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 27, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 28, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 29, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 30, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 31, position, true);
                    builder.item(parseQuestionnaireItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Questionnaire.Item parseQuestionnaireItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Item.Builder builder = Questionnaire.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, enableWhenElementIndex = 0, answerOptionElementIndex = 0, initialElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition(parseUri("definition", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 4, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                case "prefix":
                    position = checkElementOrder("prefix", 5, position, false);
                    builder.prefix(parseString("prefix", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 6, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 7, position, false);
                    builder.type((QuestionnaireItemType) parseString(QuestionnaireItemType.builder(), "type", reader, -1));
                    break;
                case "enableWhen":
                    position = checkElementOrder("enableWhen", 8, position, true);
                    builder.enableWhen(parseQuestionnaireItemEnableWhen("enableWhen", reader, enableWhenElementIndex++));
                    break;
                case "enableBehavior":
                    position = checkElementOrder("enableBehavior", 9, position, false);
                    builder.enableBehavior((EnableWhenBehavior) parseString(EnableWhenBehavior.builder(), "enableBehavior", reader, -1));
                    break;
                case "disabledDisplay":
                    position = checkElementOrder("disabledDisplay", 10, position, false);
                    builder.disabledDisplay((DisabledDisplay) parseString(DisabledDisplay.builder(), "disabledDisplay", reader, -1));
                    break;
                case "required":
                    position = checkElementOrder("required", 11, position, false);
                    builder.required(parseBoolean("required", reader, -1));
                    break;
                case "repeats":
                    position = checkElementOrder("repeats", 12, position, false);
                    builder.repeats(parseBoolean("repeats", reader, -1));
                    break;
                case "readOnly":
                    position = checkElementOrder("readOnly", 13, position, false);
                    builder.readOnly(parseBoolean("readOnly", reader, -1));
                    break;
                case "maxLength":
                    position = checkElementOrder("maxLength", 14, position, false);
                    builder.maxLength(parseInteger("maxLength", reader, -1));
                    break;
                case "answerConstraint":
                    position = checkElementOrder("answerConstraint", 15, position, false);
                    builder.answerConstraint((QuestionnaireAnswerConstraint) parseString(QuestionnaireAnswerConstraint.builder(), "answerConstraint", reader, -1));
                    break;
                case "answerValueSet":
                    position = checkElementOrder("answerValueSet", 16, position, false);
                    builder.answerValueSet((Canonical) parseUri(Canonical.builder(), "answerValueSet", reader, -1));
                    break;
                case "answerOption":
                    position = checkElementOrder("answerOption", 17, position, true);
                    builder.answerOption(parseQuestionnaireItemAnswerOption("answerOption", reader, answerOptionElementIndex++));
                    break;
                case "initial":
                    position = checkElementOrder("initial", 18, position, true);
                    builder.initial(parseQuestionnaireItemInitial("initial", reader, initialElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 19, position, true);
                    builder.item(parseQuestionnaireItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Questionnaire.Item.AnswerOption parseQuestionnaireItemAnswerOption(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Item.AnswerOption.Builder builder = Questionnaire.Item.AnswerOption.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "initialSelected":
                    position = checkElementOrder("initialSelected", 3, position, false);
                    builder.initialSelected(parseBoolean("initialSelected", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Questionnaire.Item.EnableWhen parseQuestionnaireItemEnableWhen(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Item.EnableWhen.Builder builder = Questionnaire.Item.EnableWhen.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "question":
                    position = checkElementOrder("question", 2, position, false);
                    builder.question(parseString("question", reader, -1));
                    break;
                case "operator":
                    position = checkElementOrder("operator", 3, position, false);
                    builder.operator((QuestionnaireItemOperator) parseString(QuestionnaireItemOperator.builder(), "operator", reader, -1));
                    break;
                case "answerBoolean":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseBoolean("answerBoolean", reader, -1));
                    break;
                case "answerDecimal":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseDecimal("answerDecimal", reader, -1));
                    break;
                case "answerInteger":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseInteger("answerInteger", reader, -1));
                    break;
                case "answerDate":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseDate("answerDate", reader, -1));
                    break;
                case "answerDateTime":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseDateTime("answerDateTime", reader, -1));
                    break;
                case "answerTime":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseTime("answerTime", reader, -1));
                    break;
                case "answerString":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseString("answerString", reader, -1));
                    break;
                case "answerCoding":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseCoding("answerCoding", reader, -1));
                    break;
                case "answerQuantity":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseQuantity("answerQuantity", reader, -1));
                    break;
                case "answerReference":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseReference("answerReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Questionnaire.Item.Initial parseQuestionnaireItemInitial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Item.Initial.Builder builder = Questionnaire.Item.Initial.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private QuestionnaireResponse parseQuestionnaireResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        QuestionnaireResponse.Builder builder = QuestionnaireResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "questionnaire":
                    position = checkElementOrder("questionnaire", 11, position, false);
                    builder.questionnaire((Canonical) parseUri(Canonical.builder(), "questionnaire", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((QuestionnaireResponseStatus) parseString(QuestionnaireResponseStatus.builder(), "status", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "authored":
                    position = checkElementOrder("authored", 15, position, false);
                    builder.authored(parseDateTime("authored", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 16, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 17, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 18, position, true);
                    builder.item(parseQuestionnaireResponseItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private QuestionnaireResponse.Item parseQuestionnaireResponseItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        QuestionnaireResponse.Item.Builder builder = QuestionnaireResponse.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, answerElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition(parseUri("definition", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "answer":
                    position = checkElementOrder("answer", 5, position, true);
                    builder.answer(parseQuestionnaireResponseItemAnswer("answer", reader, answerElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 6, position, true);
                    builder.item(parseQuestionnaireResponseItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private QuestionnaireResponse.Item.Answer parseQuestionnaireResponseItemAnswer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        QuestionnaireResponse.Item.Answer.Builder builder = QuestionnaireResponse.Item.Answer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "valueQuantity", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 3, position, true);
                    builder.item(parseQuestionnaireResponseItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Range parseRange(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Range.Builder builder = Range.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "low":
                    position = checkElementOrder("low", 1, position, false);
                    builder.low((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "low", reader, -1));
                    break;
                case "high":
                    position = checkElementOrder("high", 2, position, false);
                    builder.high((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "high", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ratio parseRatio(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ratio.Builder builder = Ratio.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "numerator":
                    position = checkElementOrder("numerator", 1, position, false);
                    builder.numerator(parseQuantity("numerator", reader, -1));
                    break;
                case "denominator":
                    position = checkElementOrder("denominator", 2, position, false);
                    builder.denominator((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "denominator", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RatioRange parseRatioRange(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RatioRange.Builder builder = RatioRange.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "lowNumerator":
                    position = checkElementOrder("lowNumerator", 1, position, false);
                    builder.lowNumerator((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "lowNumerator", reader, -1));
                    break;
                case "highNumerator":
                    position = checkElementOrder("highNumerator", 2, position, false);
                    builder.highNumerator((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "highNumerator", reader, -1));
                    break;
                case "denominator":
                    position = checkElementOrder("denominator", 3, position, false);
                    builder.denominator((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "denominator", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Reference parseReference(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Reference.Builder builder = Reference.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 1, position, false);
                    builder.reference(parseString("reference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseUri("type", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RegulatedAuthorization parseRegulatedAuthorization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RegulatedAuthorization.Builder builder = RegulatedAuthorization.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, subjectElementIndex = 0, regionElementIndex = 0, indicationElementIndex = 0, basisElementIndex = 0, attachedDocumentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 9, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 11, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "region":
                    position = checkElementOrder("region", 12, position, true);
                    builder.region(parseCodeableConcept("region", reader, regionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 14, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "validityPeriod":
                    position = checkElementOrder("validityPeriod", 15, position, false);
                    builder.validityPeriod(parsePeriod("validityPeriod", reader, -1));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 16, position, true);
                    builder.indication(parseCodeableReference("indication", reader, indicationElementIndex++));
                    break;
                case "intendedUse":
                    position = checkElementOrder("intendedUse", 17, position, false);
                    builder.intendedUse(parseCodeableConcept("intendedUse", reader, -1));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 18, position, true);
                    builder.basis(parseCodeableConcept("basis", reader, basisElementIndex++));
                    break;
                case "holder":
                    position = checkElementOrder("holder", 19, position, false);
                    builder.holder(parseReference("holder", reader, -1));
                    break;
                case "regulator":
                    position = checkElementOrder("regulator", 20, position, false);
                    builder.regulator(parseReference("regulator", reader, -1));
                    break;
                case "attachedDocument":
                    position = checkElementOrder("attachedDocument", 21, position, true);
                    builder.attachedDocument(parseReference("attachedDocument", reader, attachedDocumentElementIndex++));
                    break;
                case "case":
                    position = checkElementOrder("case", 22, position, false);
                    builder._case(parseRegulatedAuthorizationCase("case", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RegulatedAuthorization.Case parseRegulatedAuthorizationCase(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RegulatedAuthorization.Case.Builder builder = RegulatedAuthorization.Case.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, applicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 4, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "datePeriod":
                    position = checkElementOrder("date[x]", 5, position, false);
                    builder.date(parsePeriod("datePeriod", reader, -1));
                    break;
                case "dateDateTime":
                    position = checkElementOrder("date[x]", 5, position, false);
                    builder.date(parseDateTime("dateDateTime", reader, -1));
                    break;
                case "application":
                    position = checkElementOrder("application", 6, position, true);
                    builder.application(parseRegulatedAuthorizationCase("application", reader, applicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RelatedArtifact parseRelatedArtifact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RelatedArtifact.Builder builder = RelatedArtifact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, classifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, false);
                    builder.type((RelatedArtifactType) parseString(RelatedArtifactType.builder(), "type", reader, -1));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 2, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                case "label":
                    position = checkElementOrder("label", 3, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "citation":
                    position = checkElementOrder("citation", 5, position, false);
                    builder.citation((Markdown) parseString(Markdown.builder(), "citation", reader, -1));
                    break;
                case "document":
                    position = checkElementOrder("document", 6, position, false);
                    builder.document(parseAttachment("document", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 7, position, false);
                    builder.resource((Canonical) parseUri(Canonical.builder(), "resource", reader, -1));
                    break;
                case "resourceReference":
                    position = checkElementOrder("resourceReference", 8, position, false);
                    builder.resourceReference(parseReference("resourceReference", reader, -1));
                    break;
                case "publicationStatus":
                    position = checkElementOrder("publicationStatus", 9, position, false);
                    builder.publicationStatus((RelatedArtifactPublicationStatus) parseString(RelatedArtifactPublicationStatus.builder(), "publicationStatus", reader, -1));
                    break;
                case "publicationDate":
                    position = checkElementOrder("publicationDate", 10, position, false);
                    builder.publicationDate(parseDate("publicationDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RelatedPerson parseRelatedPerson(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RelatedPerson.Builder builder = RelatedPerson.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, relationshipElementIndex = 0, nameElementIndex = 0, telecomElementIndex = 0, addressElementIndex = 0, photoElementIndex = 0, communicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 10, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 11, position, true);
                    builder.relationship(parseCodeableConcept("relationship", reader, relationshipElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, true);
                    builder.name(parseHumanName("name", reader, nameElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 13, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 14, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "birthDate":
                    position = checkElementOrder("birthDate", 15, position, false);
                    builder.birthDate(parseDate("birthDate", reader, -1));
                    break;
                case "address":
                    position = checkElementOrder("address", 16, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 17, position, true);
                    builder.photo(parseAttachment("photo", reader, photoElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 18, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 19, position, true);
                    builder.communication(parseRelatedPersonCommunication("communication", reader, communicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RelatedPerson.Communication parseRelatedPersonCommunication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RelatedPerson.Communication.Builder builder = RelatedPerson.Communication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 3, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestOrchestration parseRequestOrchestration(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestOrchestration.Builder builder = RequestOrchestration.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, replacesElementIndex = 0, reasonElementIndex = 0, goalElementIndex = 0, noteElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 12, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 13, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((RequestStatus) parseString(RequestStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((RequestIntent) parseString(RequestIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 16, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 17, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 18, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 19, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 20, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 21, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 22, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "goal":
                    position = checkElementOrder("goal", 23, position, true);
                    builder.goal(parseReference("goal", reader, goalElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 24, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 25, position, true);
                    builder.action(parseRequestOrchestrationAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestOrchestration.Action parseRequestOrchestrationAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestOrchestration.Action.Builder builder = RequestOrchestration.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, documentationElementIndex = 0, goalElementIndex = 0, conditionElementIndex = 0, inputElementIndex = 0, outputElementIndex = 0, relatedActionElementIndex = 0, participantElementIndex = 0, dynamicValueElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "prefix":
                    position = checkElementOrder("prefix", 3, position, false);
                    builder.prefix(parseString("prefix", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 4, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "textEquivalent":
                    position = checkElementOrder("textEquivalent", 6, position, false);
                    builder.textEquivalent((Markdown) parseString(Markdown.builder(), "textEquivalent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 7, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 8, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 9, position, true);
                    builder.documentation(parseRelatedArtifact("documentation", reader, documentationElementIndex++));
                    break;
                case "goal":
                    position = checkElementOrder("goal", 10, position, true);
                    builder.goal(parseReference("goal", reader, goalElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 11, position, true);
                    builder.condition(parseRequestOrchestrationActionCondition("condition", reader, conditionElementIndex++));
                    break;
                case "input":
                    position = checkElementOrder("input", 12, position, true);
                    builder.input(parseRequestOrchestrationActionInput("input", reader, inputElementIndex++));
                    break;
                case "output":
                    position = checkElementOrder("output", 13, position, true);
                    builder.output(parseRequestOrchestrationActionOutput("output", reader, outputElementIndex++));
                    break;
                case "relatedAction":
                    position = checkElementOrder("relatedAction", 14, position, true);
                    builder.relatedAction(parseRequestOrchestrationActionRelatedAction("relatedAction", reader, relatedActionElementIndex++));
                    break;
                case "timingDateTime":
                    position = checkElementOrder("timing[x]", 15, position, false);
                    builder.timing(parseDateTime("timingDateTime", reader, -1));
                    break;
                case "timingAge":
                    position = checkElementOrder("timing[x]", 15, position, false);
                    builder.timing((Age) parseQuantity(Age.builder(), "timingAge", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 15, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "timingDuration":
                    position = checkElementOrder("timing[x]", 15, position, false);
                    builder.timing((Duration) parseQuantity(Duration.builder(), "timingDuration", reader, -1));
                    break;
                case "timingRange":
                    position = checkElementOrder("timing[x]", 15, position, false);
                    builder.timing(parseRange("timingRange", reader, -1));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 15, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 16, position, false);
                    builder.location(parseCodeableReference("location", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 17, position, true);
                    builder.participant(parseRequestOrchestrationActionParticipant("participant", reader, participantElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 18, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "groupingBehavior":
                    position = checkElementOrder("groupingBehavior", 19, position, false);
                    builder.groupingBehavior((ActionGroupingBehavior) parseString(ActionGroupingBehavior.builder(), "groupingBehavior", reader, -1));
                    break;
                case "selectionBehavior":
                    position = checkElementOrder("selectionBehavior", 20, position, false);
                    builder.selectionBehavior((ActionSelectionBehavior) parseString(ActionSelectionBehavior.builder(), "selectionBehavior", reader, -1));
                    break;
                case "requiredBehavior":
                    position = checkElementOrder("requiredBehavior", 21, position, false);
                    builder.requiredBehavior((ActionRequiredBehavior) parseString(ActionRequiredBehavior.builder(), "requiredBehavior", reader, -1));
                    break;
                case "precheckBehavior":
                    position = checkElementOrder("precheckBehavior", 22, position, false);
                    builder.precheckBehavior((ActionPrecheckBehavior) parseString(ActionPrecheckBehavior.builder(), "precheckBehavior", reader, -1));
                    break;
                case "cardinalityBehavior":
                    position = checkElementOrder("cardinalityBehavior", 23, position, false);
                    builder.cardinalityBehavior((ActionCardinalityBehavior) parseString(ActionCardinalityBehavior.builder(), "cardinalityBehavior", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 24, position, false);
                    builder.resource(parseReference("resource", reader, -1));
                    break;
                case "definitionCanonical":
                    position = checkElementOrder("definition[x]", 25, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definitionCanonical", reader, -1));
                    break;
                case "definitionUri":
                    position = checkElementOrder("definition[x]", 25, position, false);
                    builder.definition(parseUri("definitionUri", reader, -1));
                    break;
                case "transform":
                    position = checkElementOrder("transform", 26, position, false);
                    builder.transform((Canonical) parseUri(Canonical.builder(), "transform", reader, -1));
                    break;
                case "dynamicValue":
                    position = checkElementOrder("dynamicValue", 27, position, true);
                    builder.dynamicValue(parseRequestOrchestrationActionDynamicValue("dynamicValue", reader, dynamicValueElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 28, position, true);
                    builder.action(parseRequestOrchestrationAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestOrchestration.Action.Condition parseRequestOrchestrationActionCondition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestOrchestration.Action.Condition.Builder builder = RequestOrchestration.Action.Condition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 2, position, false);
                    builder.kind((ActionConditionKind) parseString(ActionConditionKind.builder(), "kind", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestOrchestration.Action.DynamicValue parseRequestOrchestrationActionDynamicValue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestOrchestration.Action.DynamicValue.Builder builder = RequestOrchestration.Action.DynamicValue.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestOrchestration.Action.Input parseRequestOrchestrationActionInput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestOrchestration.Action.Input.Builder builder = RequestOrchestration.Action.Input.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 3, position, false);
                    builder.requirement(parseDataRequirement("requirement", reader, -1));
                    break;
                case "relatedData":
                    position = checkElementOrder("relatedData", 4, position, false);
                    builder.relatedData((Id) parseString(Id.builder(), "relatedData", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestOrchestration.Action.Output parseRequestOrchestrationActionOutput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestOrchestration.Action.Output.Builder builder = RequestOrchestration.Action.Output.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 3, position, false);
                    builder.requirement(parseDataRequirement("requirement", reader, -1));
                    break;
                case "relatedData":
                    position = checkElementOrder("relatedData", 4, position, false);
                    builder.relatedData(parseString("relatedData", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestOrchestration.Action.Participant parseRequestOrchestrationActionParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestOrchestration.Action.Participant.Builder builder = RequestOrchestration.Action.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ActivityParticipantType) parseString(ActivityParticipantType.builder(), "type", reader, -1));
                    break;
                case "typeCanonical":
                    position = checkElementOrder("typeCanonical", 3, position, false);
                    builder.typeCanonical((Canonical) parseUri(Canonical.builder(), "typeCanonical", reader, -1));
                    break;
                case "typeReference":
                    position = checkElementOrder("typeReference", 4, position, false);
                    builder.typeReference(parseReference("typeReference", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 5, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "function":
                    position = checkElementOrder("function", 6, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actorCanonical":
                    position = checkElementOrder("actor[x]", 7, position, false);
                    builder.actor((Canonical) parseUri(Canonical.builder(), "actorCanonical", reader, -1));
                    break;
                case "actorReference":
                    position = checkElementOrder("actor[x]", 7, position, false);
                    builder.actor(parseReference("actorReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestOrchestration.Action.RelatedAction parseRequestOrchestrationActionRelatedAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestOrchestration.Action.RelatedAction.Builder builder = RequestOrchestration.Action.RelatedAction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "targetId":
                    position = checkElementOrder("targetId", 2, position, false);
                    builder.targetId((Id) parseString(Id.builder(), "targetId", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 3, position, false);
                    builder.relationship((ActionRelationshipType) parseString(ActionRelationshipType.builder(), "relationship", reader, -1));
                    break;
                case "endRelationship":
                    position = checkElementOrder("endRelationship", 4, position, false);
                    builder.endRelationship((ActionRelationshipType) parseString(ActionRelationshipType.builder(), "endRelationship", reader, -1));
                    break;
                case "offsetDuration":
                    position = checkElementOrder("offset[x]", 5, position, false);
                    builder.offset((Duration) parseQuantity(Duration.builder(), "offsetDuration", reader, -1));
                    break;
                case "offsetRange":
                    position = checkElementOrder("offset[x]", 5, position, false);
                    builder.offset(parseRange("offsetRange", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Requirements parseRequirements(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Requirements.Builder builder = Requirements.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, derivedFromElementIndex = 0, referenceElementIndex = 0, actorElementIndex = 0, statementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 25, position, true);
                    builder.derivedFrom((Canonical) parseUri(Canonical.builder(), "derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 26, position, true);
                    builder.reference((Url) parseUri(Url.builder(), "reference", reader, referenceElementIndex++));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 27, position, true);
                    builder.actor((Canonical) parseUri(Canonical.builder(), "actor", reader, actorElementIndex++));
                    break;
                case "statement":
                    position = checkElementOrder("statement", 28, position, true);
                    builder.statement(parseRequirementsStatement("statement", reader, statementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Requirements.Statement parseRequirementsStatement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Requirements.Statement.Builder builder = Requirements.Statement.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, conformanceElementIndex = 0, satisfiedByElementIndex = 0, referenceElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "key":
                    position = checkElementOrder("key", 2, position, false);
                    builder.key((Id) parseString(Id.builder(), "key", reader, -1));
                    break;
                case "label":
                    position = checkElementOrder("label", 3, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "conformance":
                    position = checkElementOrder("conformance", 4, position, true);
                    builder.conformance((ConformanceExpectation) parseString(ConformanceExpectation.builder(), "conformance", reader, conformanceElementIndex++));
                    break;
                case "conditionality":
                    position = checkElementOrder("conditionality", 5, position, false);
                    builder.conditionality(parseBoolean("conditionality", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 6, position, false);
                    builder.requirement((Markdown) parseString(Markdown.builder(), "requirement", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 7, position, false);
                    builder.derivedFrom(parseString("derivedFrom", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 8, position, false);
                    builder.parent(parseString("parent", reader, -1));
                    break;
                case "satisfiedBy":
                    position = checkElementOrder("satisfiedBy", 9, position, true);
                    builder.satisfiedBy((Url) parseUri(Url.builder(), "satisfiedBy", reader, satisfiedByElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 10, position, true);
                    builder.reference((Url) parseUri(Url.builder(), "reference", reader, referenceElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 11, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy parseResearchStudy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.Builder builder = ResearchStudy.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, labelElementIndex = 0, protocolElementIndex = 0, partOfElementIndex = 0, relatedArtifactElementIndex = 0, studyDesignElementIndex = 0, focusElementIndex = 0, conditionElementIndex = 0, keywordElementIndex = 0, regionElementIndex = 0, siteElementIndex = 0, noteElementIndex = 0, classifierElementIndex = 0, associatedPartyElementIndex = 0, progressStatusElementIndex = 0, comparisonGroupElementIndex = 0, objectiveElementIndex = 0, outcomeMeasureElementIndex = 0, resultElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "label":
                    position = checkElementOrder("label", 13, position, true);
                    builder.label(parseResearchStudyLabel("label", reader, labelElementIndex++));
                    break;
                case "protocol":
                    position = checkElementOrder("protocol", 14, position, true);
                    builder.protocol(parseReference("protocol", reader, protocolElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 15, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 16, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 18, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "primaryPurposeType":
                    position = checkElementOrder("primaryPurposeType", 19, position, false);
                    builder.primaryPurposeType(parseCodeableConcept("primaryPurposeType", reader, -1));
                    break;
                case "phase":
                    position = checkElementOrder("phase", 20, position, false);
                    builder.phase(parseCodeableConcept("phase", reader, -1));
                    break;
                case "studyDesign":
                    position = checkElementOrder("studyDesign", 21, position, true);
                    builder.studyDesign(parseCodeableConcept("studyDesign", reader, studyDesignElementIndex++));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 22, position, true);
                    builder.focus(parseCodeableReference("focus", reader, focusElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 23, position, true);
                    builder.condition(parseCodeableConcept("condition", reader, conditionElementIndex++));
                    break;
                case "keyword":
                    position = checkElementOrder("keyword", 24, position, true);
                    builder.keyword(parseCodeableConcept("keyword", reader, keywordElementIndex++));
                    break;
                case "region":
                    position = checkElementOrder("region", 25, position, true);
                    builder.region(parseCodeableConcept("region", reader, regionElementIndex++));
                    break;
                case "descriptionSummary":
                    position = checkElementOrder("descriptionSummary", 26, position, false);
                    builder.descriptionSummary((Markdown) parseString(Markdown.builder(), "descriptionSummary", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 27, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 28, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "site":
                    position = checkElementOrder("site", 29, position, true);
                    builder.site(parseReference("site", reader, siteElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 30, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 31, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                case "associatedParty":
                    position = checkElementOrder("associatedParty", 32, position, true);
                    builder.associatedParty(parseResearchStudyAssociatedParty("associatedParty", reader, associatedPartyElementIndex++));
                    break;
                case "progressStatus":
                    position = checkElementOrder("progressStatus", 33, position, true);
                    builder.progressStatus(parseResearchStudyProgressStatus("progressStatus", reader, progressStatusElementIndex++));
                    break;
                case "whyStopped":
                    position = checkElementOrder("whyStopped", 34, position, false);
                    builder.whyStopped(parseCodeableConcept("whyStopped", reader, -1));
                    break;
                case "recruitment":
                    position = checkElementOrder("recruitment", 35, position, false);
                    builder.recruitment(parseResearchStudyRecruitment("recruitment", reader, -1));
                    break;
                case "comparisonGroup":
                    position = checkElementOrder("comparisonGroup", 36, position, true);
                    builder.comparisonGroup(parseResearchStudyComparisonGroup("comparisonGroup", reader, comparisonGroupElementIndex++));
                    break;
                case "objective":
                    position = checkElementOrder("objective", 37, position, true);
                    builder.objective(parseResearchStudyObjective("objective", reader, objectiveElementIndex++));
                    break;
                case "outcomeMeasure":
                    position = checkElementOrder("outcomeMeasure", 38, position, true);
                    builder.outcomeMeasure(parseResearchStudyOutcomeMeasure("outcomeMeasure", reader, outcomeMeasureElementIndex++));
                    break;
                case "result":
                    position = checkElementOrder("result", 39, position, true);
                    builder.result(parseReference("result", reader, resultElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy.AssociatedParty parseResearchStudyAssociatedParty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.AssociatedParty.Builder builder = ResearchStudy.AssociatedParty.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, periodElementIndex = 0, classifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, true);
                    builder.period(parsePeriod("period", reader, periodElementIndex++));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 5, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                case "party":
                    position = checkElementOrder("party", 6, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy.ComparisonGroup parseResearchStudyComparisonGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.ComparisonGroup.Builder builder = ResearchStudy.ComparisonGroup.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, intendedExposureElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId((Id) parseString(Id.builder(), "linkId", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "intendedExposure":
                    position = checkElementOrder("intendedExposure", 6, position, true);
                    builder.intendedExposure(parseReference("intendedExposure", reader, intendedExposureElementIndex++));
                    break;
                case "observedGroup":
                    position = checkElementOrder("observedGroup", 7, position, false);
                    builder.observedGroup(parseReference("observedGroup", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy.Label parseResearchStudyLabel(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.Label.Builder builder = ResearchStudy.Label.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy.Objective parseResearchStudyObjective(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.Objective.Builder builder = ResearchStudy.Objective.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy.OutcomeMeasure parseResearchStudyOutcomeMeasure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.OutcomeMeasure.Builder builder = ResearchStudy.OutcomeMeasure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 5, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy.ProgressStatus parseResearchStudyProgressStatus(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.ProgressStatus.Builder builder = ResearchStudy.ProgressStatus.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "state":
                    position = checkElementOrder("state", 2, position, false);
                    builder.state(parseCodeableConcept("state", reader, -1));
                    break;
                case "actual":
                    position = checkElementOrder("actual", 3, position, false);
                    builder.actual(parseBoolean("actual", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy.Recruitment parseResearchStudyRecruitment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.Recruitment.Builder builder = ResearchStudy.Recruitment.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "targetNumber":
                    position = checkElementOrder("targetNumber", 2, position, false);
                    builder.targetNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "targetNumber", reader, -1));
                    break;
                case "actualNumber":
                    position = checkElementOrder("actualNumber", 3, position, false);
                    builder.actualNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "actualNumber", reader, -1));
                    break;
                case "eligibility":
                    position = checkElementOrder("eligibility", 4, position, false);
                    builder.eligibility(parseReference("eligibility", reader, -1));
                    break;
                case "actualGroup":
                    position = checkElementOrder("actualGroup", 5, position, false);
                    builder.actualGroup(parseReference("actualGroup", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchSubject parseResearchSubject(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchSubject.Builder builder = ResearchSubject.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, progressElementIndex = 0, consentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "progress":
                    position = checkElementOrder("progress", 10, position, true);
                    builder.progress(parseResearchSubjectProgress("progress", reader, progressElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 11, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "study":
                    position = checkElementOrder("study", 12, position, false);
                    builder.study(parseReference("study", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "assignedComparisonGroup":
                    position = checkElementOrder("assignedComparisonGroup", 14, position, false);
                    builder.assignedComparisonGroup((Id) parseString(Id.builder(), "assignedComparisonGroup", reader, -1));
                    break;
                case "actualComparisonGroup":
                    position = checkElementOrder("actualComparisonGroup", 15, position, false);
                    builder.actualComparisonGroup((Id) parseString(Id.builder(), "actualComparisonGroup", reader, -1));
                    break;
                case "consent":
                    position = checkElementOrder("consent", 16, position, true);
                    builder.consent(parseReference("consent", reader, consentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchSubject.Progress parseResearchSubjectProgress(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchSubject.Progress.Builder builder = ResearchSubject.Progress.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subjectState":
                    position = checkElementOrder("subjectState", 3, position, false);
                    builder.subjectState(parseCodeableConcept("subjectState", reader, -1));
                    break;
                case "milestone":
                    position = checkElementOrder("milestone", 4, position, false);
                    builder.milestone(parseCodeableConcept("milestone", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 5, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                case "startDate":
                    position = checkElementOrder("startDate", 6, position, false);
                    builder.startDate(parseDateTime("startDate", reader, -1));
                    break;
                case "endDate":
                    position = checkElementOrder("endDate", 7, position, false);
                    builder.endDate(parseDateTime("endDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RiskAssessment parseRiskAssessment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RiskAssessment.Builder builder = RiskAssessment.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, reasonElementIndex = 0, basisElementIndex = 0, predictionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, false);
                    builder.basedOn(parseReference("basedOn", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 10, position, false);
                    builder.parent(parseReference("parent", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((RiskAssessmentStatus) parseString(RiskAssessmentStatus.builder(), "status", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 12, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 13, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 15, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 17, position, false);
                    builder.condition(parseReference("condition", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 18, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 19, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 20, position, true);
                    builder.basis(parseReference("basis", reader, basisElementIndex++));
                    break;
                case "prediction":
                    position = checkElementOrder("prediction", 21, position, true);
                    builder.prediction(parseRiskAssessmentPrediction("prediction", reader, predictionElementIndex++));
                    break;
                case "mitigation":
                    position = checkElementOrder("mitigation", 22, position, false);
                    builder.mitigation(parseString("mitigation", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 23, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RiskAssessment.Prediction parseRiskAssessmentPrediction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RiskAssessment.Prediction.Builder builder = RiskAssessment.Prediction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 2, position, false);
                    builder.outcome(parseCodeableConcept("outcome", reader, -1));
                    break;
                case "probabilityDecimal":
                    position = checkElementOrder("probability[x]", 3, position, false);
                    builder.probability(parseDecimal("probabilityDecimal", reader, -1));
                    break;
                case "probabilityRange":
                    position = checkElementOrder("probability[x]", 3, position, false);
                    builder.probability(parseRange("probabilityRange", reader, -1));
                    break;
                case "qualitativeRisk":
                    position = checkElementOrder("qualitativeRisk", 4, position, false);
                    builder.qualitativeRisk(parseCodeableConcept("qualitativeRisk", reader, -1));
                    break;
                case "relativeRisk":
                    position = checkElementOrder("relativeRisk", 5, position, false);
                    builder.relativeRisk(parseDecimal("relativeRisk", reader, -1));
                    break;
                case "whenPeriod":
                    position = checkElementOrder("when[x]", 6, position, false);
                    builder.when(parsePeriod("whenPeriod", reader, -1));
                    break;
                case "whenRange":
                    position = checkElementOrder("when[x]", 6, position, false);
                    builder.when(parseRange("whenRange", reader, -1));
                    break;
                case "rationale":
                    position = checkElementOrder("rationale", 7, position, false);
                    builder.rationale(parseString("rationale", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SampledData parseSampledData(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SampledData.Builder builder = SampledData.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 1, position, false);
                    builder.origin((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "origin", reader, -1));
                    break;
                case "interval":
                    position = checkElementOrder("interval", 2, position, false);
                    builder.interval(parseDecimal("interval", reader, -1));
                    break;
                case "intervalUnit":
                    position = checkElementOrder("intervalUnit", 3, position, false);
                    builder.intervalUnit((Code) parseString(Code.builder(), "intervalUnit", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 4, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "lowerLimit":
                    position = checkElementOrder("lowerLimit", 5, position, false);
                    builder.lowerLimit(parseDecimal("lowerLimit", reader, -1));
                    break;
                case "upperLimit":
                    position = checkElementOrder("upperLimit", 6, position, false);
                    builder.upperLimit(parseDecimal("upperLimit", reader, -1));
                    break;
                case "dimensions":
                    position = checkElementOrder("dimensions", 7, position, false);
                    builder.dimensions((PositiveInt) parseInteger(PositiveInt.builder(), "dimensions", reader, -1));
                    break;
                case "codeMap":
                    position = checkElementOrder("codeMap", 8, position, false);
                    builder.codeMap((Canonical) parseUri(Canonical.builder(), "codeMap", reader, -1));
                    break;
                case "offsets":
                    position = checkElementOrder("offsets", 9, position, false);
                    builder.offsets(parseString("offsets", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 10, position, false);
                    builder.data(parseString("data", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Schedule parseSchedule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Schedule.Builder builder = Schedule.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, serviceCategoryElementIndex = 0, serviceTypeElementIndex = 0, specialtyElementIndex = 0, actorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "serviceCategory":
                    position = checkElementOrder("serviceCategory", 10, position, true);
                    builder.serviceCategory(parseCodeableConcept("serviceCategory", reader, serviceCategoryElementIndex++));
                    break;
                case "serviceType":
                    position = checkElementOrder("serviceType", 11, position, true);
                    builder.serviceType(parseCodeableReference("serviceType", reader, serviceTypeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 12, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 13, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 14, position, true);
                    builder.actor(parseReference("actor", reader, actorElementIndex++));
                    break;
                case "planningHorizon":
                    position = checkElementOrder("planningHorizon", 15, position, false);
                    builder.planningHorizon(parsePeriod("planningHorizon", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 16, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SearchParameter parseSearchParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SearchParameter.Builder builder = SearchParameter.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, baseElementIndex = 0, targetElementIndex = 0, comparatorElementIndex = 0, modifierElementIndex = 0, chainElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 14, position, false);
                    builder.derivedFrom((Canonical) parseUri(Canonical.builder(), "derivedFrom", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 24, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 25, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 26, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 27, position, true);
                    builder.base((FHIRTypes) parseString(FHIRTypes.builder(), "base", reader, baseElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 28, position, false);
                    builder.type((SearchParamType) parseString(SearchParamType.builder(), "type", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 29, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "processingMode":
                    position = checkElementOrder("processingMode", 30, position, false);
                    builder.processingMode((SearchProcessingModeType) parseString(SearchProcessingModeType.builder(), "processingMode", reader, -1));
                    break;
                case "constraint":
                    position = checkElementOrder("constraint", 31, position, false);
                    builder.constraint(parseString("constraint", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 32, position, true);
                    builder.target((FHIRTypes) parseString(FHIRTypes.builder(), "target", reader, targetElementIndex++));
                    break;
                case "multipleOr":
                    position = checkElementOrder("multipleOr", 33, position, false);
                    builder.multipleOr(parseBoolean("multipleOr", reader, -1));
                    break;
                case "multipleAnd":
                    position = checkElementOrder("multipleAnd", 34, position, false);
                    builder.multipleAnd(parseBoolean("multipleAnd", reader, -1));
                    break;
                case "comparator":
                    position = checkElementOrder("comparator", 35, position, true);
                    builder.comparator((SearchComparator) parseString(SearchComparator.builder(), "comparator", reader, comparatorElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 36, position, true);
                    builder.modifier((SearchModifierCode) parseString(SearchModifierCode.builder(), "modifier", reader, modifierElementIndex++));
                    break;
                case "chain":
                    position = checkElementOrder("chain", 37, position, true);
                    builder.chain(parseString("chain", reader, chainElementIndex++));
                    break;
                case "component":
                    position = checkElementOrder("component", 38, position, true);
                    builder.component(parseSearchParameterComponent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SearchParameter.Component parseSearchParameterComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SearchParameter.Component.Builder builder = SearchParameter.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 2, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ServiceRequest parseServiceRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ServiceRequest.Builder builder = ServiceRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, replacesElementIndex = 0, categoryElementIndex = 0, orderDetailElementIndex = 0, focusElementIndex = 0, performerElementIndex = 0, locationElementIndex = 0, reasonElementIndex = 0, insuranceElementIndex = 0, supportingInfoElementIndex = 0, specimenElementIndex = 0, bodySiteElementIndex = 0, noteElementIndex = 0, patientInstructionElementIndex = 0, relevantHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 12, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "requisition":
                    position = checkElementOrder("requisition", 13, position, false);
                    builder.requisition(parseIdentifier("requisition", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((ServiceRequestStatus) parseString(ServiceRequestStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((ServiceRequestIntent) parseString(ServiceRequestIntent.builder(), "intent", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 16, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 17, position, false);
                    builder.priority((ServiceRequestPriority) parseString(ServiceRequestPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 18, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 19, position, false);
                    builder.code(parseCodeableReference("code", reader, -1));
                    break;
                case "orderDetail":
                    position = checkElementOrder("orderDetail", 20, position, true);
                    builder.orderDetail(parseServiceRequestOrderDetail("orderDetail", reader, orderDetailElementIndex++));
                    break;
                case "quantityQuantity":
                    position = checkElementOrder("quantity[x]", 21, position, false);
                    builder.quantity(parseQuantity("quantityQuantity", reader, -1));
                    break;
                case "quantityRatio":
                    position = checkElementOrder("quantity[x]", 21, position, false);
                    builder.quantity(parseRatio("quantityRatio", reader, -1));
                    break;
                case "quantityRange":
                    position = checkElementOrder("quantity[x]", 21, position, false);
                    builder.quantity(parseRange("quantityRange", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 22, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 23, position, true);
                    builder.focus(parseReference("focus", reader, focusElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 24, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 25, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 25, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 25, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "asNeededBoolean":
                    position = checkElementOrder("asNeeded[x]", 26, position, false);
                    builder.asNeeded(parseBoolean("asNeededBoolean", reader, -1));
                    break;
                case "asNeededCodeableConcept":
                    position = checkElementOrder("asNeeded[x]", 26, position, false);
                    builder.asNeeded(parseCodeableConcept("asNeededCodeableConcept", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 27, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 28, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 29, position, false);
                    builder.performerType(parseCodeableConcept("performerType", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 30, position, true);
                    builder.performer(parseReference("performer", reader, performerElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 31, position, true);
                    builder.location(parseCodeableReference("location", reader, locationElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 32, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 33, position, true);
                    builder.insurance(parseReference("insurance", reader, insuranceElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 34, position, true);
                    builder.supportingInfo(parseCodeableReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 35, position, true);
                    builder.specimen(parseReference("specimen", reader, specimenElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 36, position, true);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "bodyStructure":
                    position = checkElementOrder("bodyStructure", 37, position, false);
                    builder.bodyStructure(parseReference("bodyStructure", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 38, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "patientInstruction":
                    position = checkElementOrder("patientInstruction", 39, position, true);
                    builder.patientInstruction(parseServiceRequestPatientInstruction("patientInstruction", reader, patientInstructionElementIndex++));
                    break;
                case "relevantHistory":
                    position = checkElementOrder("relevantHistory", 40, position, true);
                    builder.relevantHistory(parseReference("relevantHistory", reader, relevantHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ServiceRequest.OrderDetail parseServiceRequestOrderDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ServiceRequest.OrderDetail.Builder builder = ServiceRequest.OrderDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, parameterElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "parameterFocus":
                    position = checkElementOrder("parameterFocus", 2, position, false);
                    builder.parameterFocus(parseCodeableReference("parameterFocus", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 3, position, true);
                    builder.parameter(parseServiceRequestOrderDetailParameter("parameter", reader, parameterElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ServiceRequest.OrderDetail.Parameter parseServiceRequestOrderDetailParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ServiceRequest.OrderDetail.Parameter.Builder builder = ServiceRequest.OrderDetail.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ServiceRequest.PatientInstruction parseServiceRequestPatientInstruction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ServiceRequest.PatientInstruction.Builder builder = ServiceRequest.PatientInstruction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "instructionMarkdown":
                    position = checkElementOrder("instruction[x]", 2, position, false);
                    builder.instruction((Markdown) parseString(Markdown.builder(), "instructionMarkdown", reader, -1));
                    break;
                case "instructionReference":
                    position = checkElementOrder("instruction[x]", 2, position, false);
                    builder.instruction(parseReference("instructionReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Signature parseSignature(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Signature.Builder builder = Signature.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, true);
                    builder.type(parseCoding("type", reader, typeElementIndex++));
                    break;
                case "when":
                    position = checkElementOrder("when", 2, position, false);
                    builder.when(parseInstant("when", reader, -1));
                    break;
                case "who":
                    position = checkElementOrder("who", 3, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 4, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                case "targetFormat":
                    position = checkElementOrder("targetFormat", 5, position, false);
                    builder.targetFormat((Code) parseString(Code.builder(), "targetFormat", reader, -1));
                    break;
                case "sigFormat":
                    position = checkElementOrder("sigFormat", 6, position, false);
                    builder.sigFormat((Code) parseString(Code.builder(), "sigFormat", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 7, position, false);
                    builder.data(parseBase64Binary("data", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Slot parseSlot(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Slot.Builder builder = Slot.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, serviceCategoryElementIndex = 0, serviceTypeElementIndex = 0, specialtyElementIndex = 0, appointmentTypeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "serviceCategory":
                    position = checkElementOrder("serviceCategory", 9, position, true);
                    builder.serviceCategory(parseCodeableConcept("serviceCategory", reader, serviceCategoryElementIndex++));
                    break;
                case "serviceType":
                    position = checkElementOrder("serviceType", 10, position, true);
                    builder.serviceType(parseCodeableReference("serviceType", reader, serviceTypeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 11, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "appointmentType":
                    position = checkElementOrder("appointmentType", 12, position, true);
                    builder.appointmentType(parseCodeableConcept("appointmentType", reader, appointmentTypeElementIndex++));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 13, position, false);
                    builder.schedule(parseReference("schedule", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((SlotStatus) parseString(SlotStatus.builder(), "status", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 15, position, false);
                    builder.start(parseInstant("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 16, position, false);
                    builder.end(parseInstant("end", reader, -1));
                    break;
                case "overbooked":
                    position = checkElementOrder("overbooked", 17, position, false);
                    builder.overbooked(parseBoolean("overbooked", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 18, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Specimen parseSpecimen(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Specimen.Builder builder = Specimen.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, parentElementIndex = 0, requestElementIndex = 0, roleElementIndex = 0, featureElementIndex = 0, processingElementIndex = 0, containerElementIndex = 0, conditionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "accessionIdentifier":
                    position = checkElementOrder("accessionIdentifier", 9, position, false);
                    builder.accessionIdentifier(parseIdentifier("accessionIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((SpecimenStatus) parseString(SpecimenStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "receivedTime":
                    position = checkElementOrder("receivedTime", 13, position, false);
                    builder.receivedTime(parseDateTime("receivedTime", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 14, position, true);
                    builder.parent(parseReference("parent", reader, parentElementIndex++));
                    break;
                case "request":
                    position = checkElementOrder("request", 15, position, true);
                    builder.request(parseReference("request", reader, requestElementIndex++));
                    break;
                case "combined":
                    position = checkElementOrder("combined", 16, position, false);
                    builder.combined((PublicationStatus) parseString(PublicationStatus.builder(), "combined", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 17, position, true);
                    builder.role(parseCodeableConcept("role", reader, roleElementIndex++));
                    break;
                case "feature":
                    position = checkElementOrder("feature", 18, position, true);
                    builder.feature(parseSpecimenFeature("feature", reader, featureElementIndex++));
                    break;
                case "collection":
                    position = checkElementOrder("collection", 19, position, false);
                    builder.collection(parseSpecimenCollection("collection", reader, -1));
                    break;
                case "processing":
                    position = checkElementOrder("processing", 20, position, true);
                    builder.processing(parseSpecimenProcessing("processing", reader, processingElementIndex++));
                    break;
                case "container":
                    position = checkElementOrder("container", 21, position, true);
                    builder.container(parseSpecimenContainer("container", reader, containerElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 22, position, true);
                    builder.condition(parseCodeableConcept("condition", reader, conditionElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 23, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Specimen.Collection parseSpecimenCollection(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Specimen.Collection.Builder builder = Specimen.Collection.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "collector":
                    position = checkElementOrder("collector", 2, position, false);
                    builder.collector(parseReference("collector", reader, -1));
                    break;
                case "collectedDateTime":
                    position = checkElementOrder("collected[x]", 3, position, false);
                    builder.collected(parseDateTime("collectedDateTime", reader, -1));
                    break;
                case "collectedPeriod":
                    position = checkElementOrder("collected[x]", 3, position, false);
                    builder.collected(parsePeriod("collectedPeriod", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 4, position, false);
                    builder.duration((Duration) parseQuantity(Duration.builder(), "duration", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 6, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 7, position, false);
                    builder.device(parseCodeableReference("device", reader, -1));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 8, position, false);
                    builder.procedure(parseReference("procedure", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 9, position, false);
                    builder.bodySite(parseCodeableReference("bodySite", reader, -1));
                    break;
                case "fastingStatusCodeableConcept":
                    position = checkElementOrder("fastingStatus[x]", 10, position, false);
                    builder.fastingStatus(parseCodeableConcept("fastingStatusCodeableConcept", reader, -1));
                    break;
                case "fastingStatusDuration":
                    position = checkElementOrder("fastingStatus[x]", 10, position, false);
                    builder.fastingStatus((Duration) parseQuantity(Duration.builder(), "fastingStatusDuration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Specimen.Container parseSpecimenContainer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Specimen.Container.Builder builder = Specimen.Container.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 2, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 3, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "specimenQuantity":
                    position = checkElementOrder("specimenQuantity", 4, position, false);
                    builder.specimenQuantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "specimenQuantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Specimen.Feature parseSpecimenFeature(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Specimen.Feature.Builder builder = Specimen.Feature.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Specimen.Processing parseSpecimenProcessing(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Specimen.Processing.Builder builder = Specimen.Processing.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additiveElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 3, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "additive":
                    position = checkElementOrder("additive", 4, position, true);
                    builder.additive(parseReference("additive", reader, additiveElementIndex++));
                    break;
                case "timeDateTime":
                    position = checkElementOrder("time[x]", 5, position, false);
                    builder.time(parseDateTime("timeDateTime", reader, -1));
                    break;
                case "timePeriod":
                    position = checkElementOrder("time[x]", 5, position, false);
                    builder.time(parsePeriod("timePeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition parseSpecimenDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.Builder builder = SpecimenDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, derivedFromCanonicalElementIndex = 0, derivedFromUriElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, patientPreparationElementIndex = 0, collectionElementIndex = 0, typeTestedElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "derivedFromCanonical":
                    position = checkElementOrder("derivedFromCanonical", 14, position, true);
                    builder.derivedFromCanonical((Canonical) parseUri(Canonical.builder(), "derivedFromCanonical", reader, derivedFromCanonicalElementIndex++));
                    break;
                case "derivedFromUri":
                    position = checkElementOrder("derivedFromUri", 15, position, true);
                    builder.derivedFromUri(parseUri("derivedFromUri", reader, derivedFromUriElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 16, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 17, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 18, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 18, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 19, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 20, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 21, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 22, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 23, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 24, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 25, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 26, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 27, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 28, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 29, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 30, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "typeCollected":
                    position = checkElementOrder("typeCollected", 31, position, false);
                    builder.typeCollected(parseCodeableConcept("typeCollected", reader, -1));
                    break;
                case "patientPreparation":
                    position = checkElementOrder("patientPreparation", 32, position, true);
                    builder.patientPreparation(parseCodeableConcept("patientPreparation", reader, patientPreparationElementIndex++));
                    break;
                case "timeAspect":
                    position = checkElementOrder("timeAspect", 33, position, false);
                    builder.timeAspect(parseString("timeAspect", reader, -1));
                    break;
                case "collection":
                    position = checkElementOrder("collection", 34, position, true);
                    builder.collection(parseCodeableConcept("collection", reader, collectionElementIndex++));
                    break;
                case "typeTested":
                    position = checkElementOrder("typeTested", 35, position, true);
                    builder.typeTested(parseSpecimenDefinitionTypeTested("typeTested", reader, typeTestedElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition.TypeTested parseSpecimenDefinitionTypeTested(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.TypeTested.Builder builder = SpecimenDefinition.TypeTested.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, rejectionCriterionElementIndex = 0, handlingElementIndex = 0, testingDestinationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "isDerived":
                    position = checkElementOrder("isDerived", 2, position, false);
                    builder.isDerived(parseBoolean("isDerived", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "preference":
                    position = checkElementOrder("preference", 4, position, false);
                    builder.preference((SpecimenContainedPreference) parseString(SpecimenContainedPreference.builder(), "preference", reader, -1));
                    break;
                case "container":
                    position = checkElementOrder("container", 5, position, false);
                    builder.container(parseSpecimenDefinitionTypeTestedContainer("container", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 6, position, false);
                    builder.requirement((Markdown) parseString(Markdown.builder(), "requirement", reader, -1));
                    break;
                case "retentionTime":
                    position = checkElementOrder("retentionTime", 7, position, false);
                    builder.retentionTime((Duration) parseQuantity(Duration.builder(), "retentionTime", reader, -1));
                    break;
                case "singleUse":
                    position = checkElementOrder("singleUse", 8, position, false);
                    builder.singleUse(parseBoolean("singleUse", reader, -1));
                    break;
                case "rejectionCriterion":
                    position = checkElementOrder("rejectionCriterion", 9, position, true);
                    builder.rejectionCriterion(parseCodeableConcept("rejectionCriterion", reader, rejectionCriterionElementIndex++));
                    break;
                case "handling":
                    position = checkElementOrder("handling", 10, position, true);
                    builder.handling(parseSpecimenDefinitionTypeTestedHandling("handling", reader, handlingElementIndex++));
                    break;
                case "testingDestination":
                    position = checkElementOrder("testingDestination", 11, position, true);
                    builder.testingDestination(parseCodeableConcept("testingDestination", reader, testingDestinationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition.TypeTested.Container parseSpecimenDefinitionTypeTestedContainer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.TypeTested.Container.Builder builder = SpecimenDefinition.TypeTested.Container.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additiveElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "material":
                    position = checkElementOrder("material", 2, position, false);
                    builder.material(parseCodeableConcept("material", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "cap":
                    position = checkElementOrder("cap", 4, position, false);
                    builder.cap(parseCodeableConcept("cap", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "capacity":
                    position = checkElementOrder("capacity", 6, position, false);
                    builder.capacity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "capacity", reader, -1));
                    break;
                case "minimumVolumeQuantity":
                    position = checkElementOrder("minimumVolume[x]", 7, position, false);
                    builder.minimumVolume((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "minimumVolumeQuantity", reader, -1));
                    break;
                case "minimumVolumeString":
                    position = checkElementOrder("minimumVolume[x]", 7, position, false);
                    builder.minimumVolume(parseString("minimumVolumeString", reader, -1));
                    break;
                case "additive":
                    position = checkElementOrder("additive", 8, position, true);
                    builder.additive(parseSpecimenDefinitionTypeTestedContainerAdditive("additive", reader, additiveElementIndex++));
                    break;
                case "preparation":
                    position = checkElementOrder("preparation", 9, position, false);
                    builder.preparation((Markdown) parseString(Markdown.builder(), "preparation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition.TypeTested.Container.Additive parseSpecimenDefinitionTypeTestedContainerAdditive(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.TypeTested.Container.Additive.Builder builder = SpecimenDefinition.TypeTested.Container.Additive.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "additiveCodeableConcept":
                    position = checkElementOrder("additive[x]", 2, position, false);
                    builder.additive(parseCodeableConcept("additiveCodeableConcept", reader, -1));
                    break;
                case "additiveReference":
                    position = checkElementOrder("additive[x]", 2, position, false);
                    builder.additive(parseReference("additiveReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition.TypeTested.Handling parseSpecimenDefinitionTypeTestedHandling(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.TypeTested.Handling.Builder builder = SpecimenDefinition.TypeTested.Handling.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "temperatureQualifier":
                    position = checkElementOrder("temperatureQualifier", 2, position, false);
                    builder.temperatureQualifier(parseCodeableConcept("temperatureQualifier", reader, -1));
                    break;
                case "temperatureRange":
                    position = checkElementOrder("temperatureRange", 3, position, false);
                    builder.temperatureRange(parseRange("temperatureRange", reader, -1));
                    break;
                case "maxDuration":
                    position = checkElementOrder("maxDuration", 4, position, false);
                    builder.maxDuration((Duration) parseQuantity(Duration.builder(), "maxDuration", reader, -1));
                    break;
                case "instruction":
                    position = checkElementOrder("instruction", 5, position, false);
                    builder.instruction((Markdown) parseString(Markdown.builder(), "instruction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private String parseString(String.Builder builder, java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private String parseString(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        return parseString(String.builder(), elementName, reader, elementIndex);
    }

    private StructureDefinition parseStructureDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Builder builder = StructureDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, keywordElementIndex = 0, mappingElementIndex = 0, contextElementIndex = 0, contextInvariantElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "keyword":
                    position = checkElementOrder("keyword", 25, position, true);
                    builder.keyword(parseCoding("keyword", reader, keywordElementIndex++));
                    break;
                case "fhirVersion":
                    position = checkElementOrder("fhirVersion", 26, position, false);
                    builder.fhirVersion((FHIRVersion) parseString(FHIRVersion.builder(), "fhirVersion", reader, -1));
                    break;
                case "mapping":
                    position = checkElementOrder("mapping", 27, position, true);
                    builder.mapping(parseStructureDefinitionMapping("mapping", reader, mappingElementIndex++));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 28, position, false);
                    builder.kind((StructureDefinitionKind) parseString(StructureDefinitionKind.builder(), "kind", reader, -1));
                    break;
                case "abstract":
                    position = checkElementOrder("abstract", 29, position, false);
                    builder._abstract(parseBoolean("abstract", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 30, position, true);
                    builder.context(parseStructureDefinitionContext("context", reader, contextElementIndex++));
                    break;
                case "contextInvariant":
                    position = checkElementOrder("contextInvariant", 31, position, true);
                    builder.contextInvariant(parseString("contextInvariant", reader, contextInvariantElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 32, position, false);
                    builder.type(parseUri("type", reader, -1));
                    break;
                case "baseDefinition":
                    position = checkElementOrder("baseDefinition", 33, position, false);
                    builder.baseDefinition((Canonical) parseUri(Canonical.builder(), "baseDefinition", reader, -1));
                    break;
                case "derivation":
                    position = checkElementOrder("derivation", 34, position, false);
                    builder.derivation((TypeDerivationRule) parseString(TypeDerivationRule.builder(), "derivation", reader, -1));
                    break;
                case "snapshot":
                    position = checkElementOrder("snapshot", 35, position, false);
                    builder.snapshot(parseStructureDefinitionSnapshot("snapshot", reader, -1));
                    break;
                case "differential":
                    position = checkElementOrder("differential", 36, position, false);
                    builder.differential(parseStructureDefinitionDifferential("differential", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureDefinition.Context parseStructureDefinitionContext(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Context.Builder builder = StructureDefinition.Context.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ExtensionContextType) parseString(ExtensionContextType.builder(), "type", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureDefinition.Differential parseStructureDefinitionDifferential(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Differential.Builder builder = StructureDefinition.Differential.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, elementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "element":
                    position = checkElementOrder("element", 2, position, true);
                    builder.element(parseElementDefinition("element", reader, elementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureDefinition.Mapping parseStructureDefinitionMapping(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Mapping.Builder builder = StructureDefinition.Mapping.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identity":
                    position = checkElementOrder("identity", 2, position, false);
                    builder.identity((Id) parseString(Id.builder(), "identity", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 5, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureDefinition.Snapshot parseStructureDefinitionSnapshot(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Snapshot.Builder builder = StructureDefinition.Snapshot.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, elementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "element":
                    position = checkElementOrder("element", 2, position, true);
                    builder.element(parseElementDefinition("element", reader, elementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap parseStructureMap(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Builder builder = StructureMap.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, structureElementIndex = 0, importElementIndex = 0, constElementIndex = 0, groupElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "structure":
                    position = checkElementOrder("structure", 25, position, true);
                    builder.structure(parseStructureMapStructure("structure", reader, structureElementIndex++));
                    break;
                case "import":
                    position = checkElementOrder("import", 26, position, true);
                    builder._import((Canonical) parseUri(Canonical.builder(), "import", reader, importElementIndex++));
                    break;
                case "const":
                    position = checkElementOrder("const", 27, position, true);
                    builder._const(parseStructureMapConst("const", reader, constElementIndex++));
                    break;
                case "group":
                    position = checkElementOrder("group", 28, position, true);
                    builder.group(parseStructureMapGroup("group", reader, groupElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Const parseStructureMapConst(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Const.Builder builder = StructureMap.Const.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group parseStructureMapGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Builder builder = StructureMap.Group.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, inputElementIndex = 0, ruleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "extends":
                    position = checkElementOrder("extends", 3, position, false);
                    builder._extends((Id) parseString(Id.builder(), "extends", reader, -1));
                    break;
                case "typeMode":
                    position = checkElementOrder("typeMode", 4, position, false);
                    builder.typeMode((StructureMapGroupTypeMode) parseString(StructureMapGroupTypeMode.builder(), "typeMode", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                case "input":
                    position = checkElementOrder("input", 6, position, true);
                    builder.input(parseStructureMapGroupInput("input", reader, inputElementIndex++));
                    break;
                case "rule":
                    position = checkElementOrder("rule", 7, position, true);
                    builder.rule(parseStructureMapGroupRule("rule", reader, ruleElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Input parseStructureMapGroupInput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Input.Builder builder = StructureMap.Group.Input.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseString("type", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 4, position, false);
                    builder.mode((StructureMapInputMode) parseString(StructureMapInputMode.builder(), "mode", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule parseStructureMapGroupRule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Builder builder = StructureMap.Group.Rule.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, sourceElementIndex = 0, targetElementIndex = 0, ruleElementIndex = 0, dependentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, true);
                    builder.source(parseStructureMapGroupRuleSource("source", reader, sourceElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 4, position, true);
                    builder.target(parseStructureMapGroupRuleTarget("target", reader, targetElementIndex++));
                    break;
                case "rule":
                    position = checkElementOrder("rule", 5, position, true);
                    builder.rule(parseStructureMapGroupRule("rule", reader, ruleElementIndex++));
                    break;
                case "dependent":
                    position = checkElementOrder("dependent", 6, position, true);
                    builder.dependent(parseStructureMapGroupRuleDependent("dependent", reader, dependentElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 7, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule.Dependent parseStructureMapGroupRuleDependent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Dependent.Builder builder = StructureMap.Group.Rule.Dependent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, parameterElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 3, position, true);
                    builder.parameter(parseStructureMapGroupRuleTargetParameter("parameter", reader, parameterElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule.Source parseStructureMapGroupRuleSource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Source.Builder builder = StructureMap.Group.Rule.Source.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "context":
                    position = checkElementOrder("context", 2, position, false);
                    builder.context((Id) parseString(Id.builder(), "context", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 3, position, false);
                    builder.min(parseInteger("min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 4, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type(parseString("type", reader, -1));
                    break;
                case "defaultValue":
                    position = checkElementOrder("defaultValue", 6, position, false);
                    builder.defaultValue(parseString("defaultValue", reader, -1));
                    break;
                case "element":
                    position = checkElementOrder("element", 7, position, false);
                    builder.element(parseString("element", reader, -1));
                    break;
                case "listMode":
                    position = checkElementOrder("listMode", 8, position, false);
                    builder.listMode((StructureMapSourceListMode) parseString(StructureMapSourceListMode.builder(), "listMode", reader, -1));
                    break;
                case "variable":
                    position = checkElementOrder("variable", 9, position, false);
                    builder.variable((Id) parseString(Id.builder(), "variable", reader, -1));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 10, position, false);
                    builder.condition(parseString("condition", reader, -1));
                    break;
                case "check":
                    position = checkElementOrder("check", 11, position, false);
                    builder.check(parseString("check", reader, -1));
                    break;
                case "logMessage":
                    position = checkElementOrder("logMessage", 12, position, false);
                    builder.logMessage(parseString("logMessage", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule.Target parseStructureMapGroupRuleTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Target.Builder builder = StructureMap.Group.Rule.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, listModeElementIndex = 0, parameterElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "context":
                    position = checkElementOrder("context", 2, position, false);
                    builder.context(parseString("context", reader, -1));
                    break;
                case "element":
                    position = checkElementOrder("element", 3, position, false);
                    builder.element(parseString("element", reader, -1));
                    break;
                case "variable":
                    position = checkElementOrder("variable", 4, position, false);
                    builder.variable((Id) parseString(Id.builder(), "variable", reader, -1));
                    break;
                case "listMode":
                    position = checkElementOrder("listMode", 5, position, true);
                    builder.listMode((StructureMapTargetListMode) parseString(StructureMapTargetListMode.builder(), "listMode", reader, listModeElementIndex++));
                    break;
                case "listRuleId":
                    position = checkElementOrder("listRuleId", 6, position, false);
                    builder.listRuleId((Id) parseString(Id.builder(), "listRuleId", reader, -1));
                    break;
                case "transform":
                    position = checkElementOrder("transform", 7, position, false);
                    builder.transform((StructureMapTransform) parseString(StructureMapTransform.builder(), "transform", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 8, position, true);
                    builder.parameter(parseStructureMapGroupRuleTargetParameter("parameter", reader, parameterElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule.Target.Parameter parseStructureMapGroupRuleTargetParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Target.Parameter.Builder builder = StructureMap.Group.Rule.Target.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Structure parseStructureMapStructure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Structure.Builder builder = StructureMap.Structure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 2, position, false);
                    builder.url((Canonical) parseUri(Canonical.builder(), "url", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 3, position, false);
                    builder.mode((StructureMapModelMode) parseString(StructureMapModelMode.builder(), "mode", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 4, position, false);
                    builder.alias(parseString("alias", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Subscription parseSubscription(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Subscription.Builder builder = Subscription.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, filterByElementIndex = 0, parameterElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 9, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((SubscriptionStatusCodes) parseString(SubscriptionStatusCodes.builder(), "status", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 11, position, false);
                    builder.topic((Canonical) parseUri(Canonical.builder(), "topic", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 12, position, true);
                    builder.contact(parseContactPoint("contact", reader, contactElementIndex++));
                    break;
                case "end":
                    position = checkElementOrder("end", 13, position, false);
                    builder.end(parseInstant("end", reader, -1));
                    break;
                case "managingEntity":
                    position = checkElementOrder("managingEntity", 14, position, false);
                    builder.managingEntity(parseReference("managingEntity", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 15, position, false);
                    builder.reason(parseString("reason", reader, -1));
                    break;
                case "filterBy":
                    position = checkElementOrder("filterBy", 16, position, true);
                    builder.filterBy(parseSubscriptionFilterBy("filterBy", reader, filterByElementIndex++));
                    break;
                case "channelType":
                    position = checkElementOrder("channelType", 17, position, false);
                    builder.channelType(parseCoding("channelType", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 18, position, false);
                    builder.endpoint((Url) parseUri(Url.builder(), "endpoint", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 19, position, true);
                    builder.parameter(parseSubscriptionParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "heartbeatPeriod":
                    position = checkElementOrder("heartbeatPeriod", 20, position, false);
                    builder.heartbeatPeriod((UnsignedInt) parseInteger(UnsignedInt.builder(), "heartbeatPeriod", reader, -1));
                    break;
                case "timeout":
                    position = checkElementOrder("timeout", 21, position, false);
                    builder.timeout((UnsignedInt) parseInteger(UnsignedInt.builder(), "timeout", reader, -1));
                    break;
                case "contentType":
                    position = checkElementOrder("contentType", 22, position, false);
                    builder.contentType((Code) parseString(Code.builder(), "contentType", reader, -1));
                    break;
                case "content":
                    position = checkElementOrder("content", 23, position, false);
                    builder.content((SubscriptionPayloadContent) parseString(SubscriptionPayloadContent.builder(), "content", reader, -1));
                    break;
                case "maxCount":
                    position = checkElementOrder("maxCount", 24, position, false);
                    builder.maxCount((PositiveInt) parseInteger(PositiveInt.builder(), "maxCount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Subscription.FilterBy parseSubscriptionFilterBy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Subscription.FilterBy.Builder builder = Subscription.FilterBy.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "resourceType":
                    position = checkElementOrder("resourceType", 2, position, false);
                    builder.resourceType(parseUri("resourceType", reader, -1));
                    break;
                case "filterParameter":
                    position = checkElementOrder("filterParameter", 3, position, false);
                    builder.filterParameter(parseString("filterParameter", reader, -1));
                    break;
                case "comparator":
                    position = checkElementOrder("comparator", 4, position, false);
                    builder.comparator((SearchComparator) parseString(SearchComparator.builder(), "comparator", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 5, position, false);
                    builder.modifier((SearchModifierCode) parseString(SearchModifierCode.builder(), "modifier", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 6, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Subscription.Parameter parseSubscriptionParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Subscription.Parameter.Builder builder = Subscription.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionStatus parseSubscriptionStatus(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionStatus.Builder builder = SubscriptionStatus.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, notificationEventElementIndex = 0, errorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 8, position, false);
                    builder.status((SubscriptionStatusCode) parseString(SubscriptionStatusCode.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type((SubscriptionNotificationType) parseString(SubscriptionNotificationType.builder(), "type", reader, -1));
                    break;
                case "eventsSinceSubscriptionStart":
                    position = checkElementOrder("eventsSinceSubscriptionStart", 10, position, false);
                    builder.eventsSinceSubscriptionStart(parseInteger64("eventsSinceSubscriptionStart", reader, -1));
                    break;
                case "notificationEvent":
                    position = checkElementOrder("notificationEvent", 11, position, true);
                    builder.notificationEvent(parseSubscriptionStatusNotificationEvent("notificationEvent", reader, notificationEventElementIndex++));
                    break;
                case "subscription":
                    position = checkElementOrder("subscription", 12, position, false);
                    builder.subscription(parseReference("subscription", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 13, position, false);
                    builder.topic((Canonical) parseUri(Canonical.builder(), "topic", reader, -1));
                    break;
                case "error":
                    position = checkElementOrder("error", 14, position, true);
                    builder.error(parseCodeableConcept("error", reader, errorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionStatus.NotificationEvent parseSubscriptionStatusNotificationEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionStatus.NotificationEvent.Builder builder = SubscriptionStatus.NotificationEvent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additionalContextElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "eventNumber":
                    position = checkElementOrder("eventNumber", 2, position, false);
                    builder.eventNumber(parseInteger64("eventNumber", reader, -1));
                    break;
                case "timestamp":
                    position = checkElementOrder("timestamp", 3, position, false);
                    builder.timestamp(parseInstant("timestamp", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 4, position, false);
                    builder.focus(parseReference("focus", reader, -1));
                    break;
                case "additionalContext":
                    position = checkElementOrder("additionalContext", 5, position, true);
                    builder.additionalContext(parseReference("additionalContext", reader, additionalContextElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic parseSubscriptionTopic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.Builder builder = SubscriptionTopic.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, derivedFromElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, resourceTriggerElementIndex = 0, eventTriggerElementIndex = 0, canFilterByElementIndex = 0, notificationShapeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 14, position, true);
                    builder.derivedFrom((Canonical) parseUri(Canonical.builder(), "derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 24, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 25, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 26, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 27, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 28, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "resourceTrigger":
                    position = checkElementOrder("resourceTrigger", 29, position, true);
                    builder.resourceTrigger(parseSubscriptionTopicResourceTrigger("resourceTrigger", reader, resourceTriggerElementIndex++));
                    break;
                case "eventTrigger":
                    position = checkElementOrder("eventTrigger", 30, position, true);
                    builder.eventTrigger(parseSubscriptionTopicEventTrigger("eventTrigger", reader, eventTriggerElementIndex++));
                    break;
                case "canFilterBy":
                    position = checkElementOrder("canFilterBy", 31, position, true);
                    builder.canFilterBy(parseSubscriptionTopicCanFilterBy("canFilterBy", reader, canFilterByElementIndex++));
                    break;
                case "notificationShape":
                    position = checkElementOrder("notificationShape", 32, position, true);
                    builder.notificationShape(parseSubscriptionTopicNotificationShape("notificationShape", reader, notificationShapeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.CanFilterBy parseSubscriptionTopicCanFilterBy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.CanFilterBy.Builder builder = SubscriptionTopic.CanFilterBy.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, comparatorElementIndex = 0, modifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                case "filterParameter":
                    position = checkElementOrder("filterParameter", 4, position, false);
                    builder.filterParameter(parseString("filterParameter", reader, -1));
                    break;
                case "filterDefinition":
                    position = checkElementOrder("filterDefinition", 5, position, false);
                    builder.filterDefinition(parseUri("filterDefinition", reader, -1));
                    break;
                case "comparator":
                    position = checkElementOrder("comparator", 6, position, true);
                    builder.comparator((SearchComparator) parseString(SearchComparator.builder(), "comparator", reader, comparatorElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 7, position, true);
                    builder.modifier((SearchModifierCode) parseString(SearchModifierCode.builder(), "modifier", reader, modifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.EventTrigger parseSubscriptionTopicEventTrigger(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.EventTrigger.Builder builder = SubscriptionTopic.EventTrigger.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "event":
                    position = checkElementOrder("event", 3, position, false);
                    builder.event(parseCodeableConcept("event", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 4, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.NotificationShape parseSubscriptionTopicNotificationShape(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.NotificationShape.Builder builder = SubscriptionTopic.NotificationShape.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, includeElementIndex = 0, revIncludeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 2, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                case "include":
                    position = checkElementOrder("include", 3, position, true);
                    builder.include(parseString("include", reader, includeElementIndex++));
                    break;
                case "revInclude":
                    position = checkElementOrder("revInclude", 4, position, true);
                    builder.revInclude(parseString("revInclude", reader, revIncludeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.ResourceTrigger parseSubscriptionTopicResourceTrigger(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.ResourceTrigger.Builder builder = SubscriptionTopic.ResourceTrigger.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, supportedInteractionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                case "supportedInteraction":
                    position = checkElementOrder("supportedInteraction", 4, position, true);
                    builder.supportedInteraction((MethodCode) parseString(MethodCode.builder(), "supportedInteraction", reader, supportedInteractionElementIndex++));
                    break;
                case "queryCriteria":
                    position = checkElementOrder("queryCriteria", 5, position, false);
                    builder.queryCriteria(parseSubscriptionTopicResourceTriggerQueryCriteria("queryCriteria", reader, -1));
                    break;
                case "fhirPathCriteria":
                    position = checkElementOrder("fhirPathCriteria", 6, position, false);
                    builder.fhirPathCriteria(parseString("fhirPathCriteria", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.ResourceTrigger.QueryCriteria parseSubscriptionTopicResourceTriggerQueryCriteria(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.ResourceTrigger.QueryCriteria.Builder builder = SubscriptionTopic.ResourceTrigger.QueryCriteria.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "previous":
                    position = checkElementOrder("previous", 2, position, false);
                    builder.previous(parseString("previous", reader, -1));
                    break;
                case "resultForCreate":
                    position = checkElementOrder("resultForCreate", 3, position, false);
                    builder.resultForCreate((CriteriaNotExistsBehavior) parseString(CriteriaNotExistsBehavior.builder(), "resultForCreate", reader, -1));
                    break;
                case "current":
                    position = checkElementOrder("current", 4, position, false);
                    builder.current(parseString("current", reader, -1));
                    break;
                case "resultForDelete":
                    position = checkElementOrder("resultForDelete", 5, position, false);
                    builder.resultForDelete((CriteriaNotExistsBehavior) parseString(CriteriaNotExistsBehavior.builder(), "resultForDelete", reader, -1));
                    break;
                case "requireBoth":
                    position = checkElementOrder("requireBoth", 6, position, false);
                    builder.requireBoth(parseBoolean("requireBoth", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Substance parseSubstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Substance.Builder builder = Substance.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, ingredientElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 9, position, false);
                    builder.instance(parseBoolean("instance", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((FHIRSubstanceStatus) parseString(FHIRSubstanceStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 12, position, false);
                    builder.code(parseCodeableReference("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 13, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "expiry":
                    position = checkElementOrder("expiry", 14, position, false);
                    builder.expiry(parseDateTime("expiry", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 15, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 16, position, true);
                    builder.ingredient(parseSubstanceIngredient("ingredient", reader, ingredientElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Substance.Ingredient parseSubstanceIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Substance.Ingredient.Builder builder = Substance.Ingredient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity(parseRatio("quantity", reader, -1));
                    break;
                case "substanceCodeableConcept":
                    position = checkElementOrder("substance[x]", 3, position, false);
                    builder.substance(parseCodeableConcept("substanceCodeableConcept", reader, -1));
                    break;
                case "substanceReference":
                    position = checkElementOrder("substance[x]", 3, position, false);
                    builder.substance(parseReference("substanceReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition parseSubstanceDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Builder builder = SubstanceDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, classificationElementIndex = 0, gradeElementIndex = 0, informationSourceElementIndex = 0, noteElementIndex = 0, manufacturerElementIndex = 0, supplierElementIndex = 0, moietyElementIndex = 0, characterizationElementIndex = 0, propertyElementIndex = 0, molecularWeightElementIndex = 0, codeElementIndex = 0, nameElementIndex = 0, relationshipElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 11, position, true);
                    builder.classification(parseCodeableConcept("classification", reader, classificationElementIndex++));
                    break;
                case "domain":
                    position = checkElementOrder("domain", 12, position, false);
                    builder.domain(parseCodeableConcept("domain", reader, -1));
                    break;
                case "grade":
                    position = checkElementOrder("grade", 13, position, true);
                    builder.grade(parseCodeableConcept("grade", reader, gradeElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 14, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "informationSource":
                    position = checkElementOrder("informationSource", 15, position, true);
                    builder.informationSource(parseReference("informationSource", reader, informationSourceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 16, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 17, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "supplier":
                    position = checkElementOrder("supplier", 18, position, true);
                    builder.supplier(parseReference("supplier", reader, supplierElementIndex++));
                    break;
                case "moiety":
                    position = checkElementOrder("moiety", 19, position, true);
                    builder.moiety(parseSubstanceDefinitionMoiety("moiety", reader, moietyElementIndex++));
                    break;
                case "characterization":
                    position = checkElementOrder("characterization", 20, position, true);
                    builder.characterization(parseSubstanceDefinitionCharacterization("characterization", reader, characterizationElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 21, position, true);
                    builder.property(parseSubstanceDefinitionProperty("property", reader, propertyElementIndex++));
                    break;
                case "referenceInformation":
                    position = checkElementOrder("referenceInformation", 22, position, false);
                    builder.referenceInformation(parseReference("referenceInformation", reader, -1));
                    break;
                case "molecularWeight":
                    position = checkElementOrder("molecularWeight", 23, position, true);
                    builder.molecularWeight(parseSubstanceDefinitionMolecularWeight("molecularWeight", reader, molecularWeightElementIndex++));
                    break;
                case "structure":
                    position = checkElementOrder("structure", 24, position, false);
                    builder.structure(parseSubstanceDefinitionStructure("structure", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 25, position, true);
                    builder.code(parseSubstanceDefinitionCode("code", reader, codeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 26, position, true);
                    builder.name(parseSubstanceDefinitionName("name", reader, nameElementIndex++));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 27, position, true);
                    builder.relationship(parseSubstanceDefinitionRelationship("relationship", reader, relationshipElementIndex++));
                    break;
                case "nucleicAcid":
                    position = checkElementOrder("nucleicAcid", 28, position, false);
                    builder.nucleicAcid(parseReference("nucleicAcid", reader, -1));
                    break;
                case "polymer":
                    position = checkElementOrder("polymer", 29, position, false);
                    builder.polymer(parseReference("polymer", reader, -1));
                    break;
                case "protein":
                    position = checkElementOrder("protein", 30, position, false);
                    builder.protein(parseReference("protein", reader, -1));
                    break;
                case "sourceMaterial":
                    position = checkElementOrder("sourceMaterial", 31, position, false);
                    builder.sourceMaterial(parseSubstanceDefinitionSourceMaterial("sourceMaterial", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Characterization parseSubstanceDefinitionCharacterization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Characterization.Builder builder = SubstanceDefinition.Characterization.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, fileElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "technique":
                    position = checkElementOrder("technique", 2, position, false);
                    builder.technique(parseCodeableConcept("technique", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 3, position, false);
                    builder.form(parseCodeableConcept("form", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "file":
                    position = checkElementOrder("file", 5, position, true);
                    builder.file(parseAttachment("file", reader, fileElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Code parseSubstanceDefinitionCode(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Code.Builder builder = SubstanceDefinition.Code.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 3, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 4, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 5, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 6, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Moiety parseSubstanceDefinitionMoiety(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Moiety.Builder builder = SubstanceDefinition.Moiety.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "stereochemistry":
                    position = checkElementOrder("stereochemistry", 5, position, false);
                    builder.stereochemistry(parseCodeableConcept("stereochemistry", reader, -1));
                    break;
                case "opticalActivity":
                    position = checkElementOrder("opticalActivity", 6, position, false);
                    builder.opticalActivity(parseCodeableConcept("opticalActivity", reader, -1));
                    break;
                case "molecularFormula":
                    position = checkElementOrder("molecularFormula", 7, position, false);
                    builder.molecularFormula(parseString("molecularFormula", reader, -1));
                    break;
                case "amountQuantity":
                    position = checkElementOrder("amount[x]", 8, position, false);
                    builder.amount(parseQuantity("amountQuantity", reader, -1));
                    break;
                case "amountString":
                    position = checkElementOrder("amount[x]", 8, position, false);
                    builder.amount(parseString("amountString", reader, -1));
                    break;
                case "measurementType":
                    position = checkElementOrder("measurementType", 9, position, false);
                    builder.measurementType(parseCodeableConcept("measurementType", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.MolecularWeight parseSubstanceDefinitionMolecularWeight(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.MolecularWeight.Builder builder = SubstanceDefinition.MolecularWeight.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "method":
                    position = checkElementOrder("method", 2, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 4, position, false);
                    builder.amount(parseQuantity("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Name parseSubstanceDefinitionName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Name.Builder builder = SubstanceDefinition.Name.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, languageElementIndex = 0, domainElementIndex = 0, jurisdictionElementIndex = 0, synonymElementIndex = 0, translationElementIndex = 0, officialElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 4, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 5, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 6, position, true);
                    builder.language(parseCodeableConcept("language", reader, languageElementIndex++));
                    break;
                case "domain":
                    position = checkElementOrder("domain", 7, position, true);
                    builder.domain(parseCodeableConcept("domain", reader, domainElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 8, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "synonym":
                    position = checkElementOrder("synonym", 9, position, true);
                    builder.synonym(parseSubstanceDefinitionName("synonym", reader, synonymElementIndex++));
                    break;
                case "translation":
                    position = checkElementOrder("translation", 10, position, true);
                    builder.translation(parseSubstanceDefinitionName("translation", reader, translationElementIndex++));
                    break;
                case "official":
                    position = checkElementOrder("official", 11, position, true);
                    builder.official(parseSubstanceDefinitionNameOfficial("official", reader, officialElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 12, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Name.Official parseSubstanceDefinitionNameOfficial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Name.Official.Builder builder = SubstanceDefinition.Name.Official.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 2, position, false);
                    builder.authority(parseCodeableConcept("authority", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 3, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 4, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Property parseSubstanceDefinitionProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Property.Builder builder = SubstanceDefinition.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Relationship parseSubstanceDefinitionRelationship(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Relationship.Builder builder = SubstanceDefinition.Relationship.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "substanceDefinitionReference":
                    position = checkElementOrder("substanceDefinition[x]", 2, position, false);
                    builder.substanceDefinition(parseReference("substanceDefinitionReference", reader, -1));
                    break;
                case "substanceDefinitionCodeableConcept":
                    position = checkElementOrder("substanceDefinition[x]", 2, position, false);
                    builder.substanceDefinition(parseCodeableConcept("substanceDefinitionCodeableConcept", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "isDefining":
                    position = checkElementOrder("isDefining", 4, position, false);
                    builder.isDefining(parseBoolean("isDefining", reader, -1));
                    break;
                case "amountQuantity":
                    position = checkElementOrder("amount[x]", 5, position, false);
                    builder.amount(parseQuantity("amountQuantity", reader, -1));
                    break;
                case "amountRatio":
                    position = checkElementOrder("amount[x]", 5, position, false);
                    builder.amount(parseRatio("amountRatio", reader, -1));
                    break;
                case "amountString":
                    position = checkElementOrder("amount[x]", 5, position, false);
                    builder.amount(parseString("amountString", reader, -1));
                    break;
                case "ratioHighLimitAmount":
                    position = checkElementOrder("ratioHighLimitAmount", 6, position, false);
                    builder.ratioHighLimitAmount(parseRatio("ratioHighLimitAmount", reader, -1));
                    break;
                case "comparator":
                    position = checkElementOrder("comparator", 7, position, false);
                    builder.comparator(parseCodeableConcept("comparator", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 8, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.SourceMaterial parseSubstanceDefinitionSourceMaterial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.SourceMaterial.Builder builder = SubstanceDefinition.SourceMaterial.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, countryOfOriginElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "genus":
                    position = checkElementOrder("genus", 3, position, false);
                    builder.genus(parseCodeableConcept("genus", reader, -1));
                    break;
                case "species":
                    position = checkElementOrder("species", 4, position, false);
                    builder.species(parseCodeableConcept("species", reader, -1));
                    break;
                case "part":
                    position = checkElementOrder("part", 5, position, false);
                    builder.part(parseCodeableConcept("part", reader, -1));
                    break;
                case "countryOfOrigin":
                    position = checkElementOrder("countryOfOrigin", 6, position, true);
                    builder.countryOfOrigin(parseCodeableConcept("countryOfOrigin", reader, countryOfOriginElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Structure parseSubstanceDefinitionStructure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Structure.Builder builder = SubstanceDefinition.Structure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, techniqueElementIndex = 0, sourceDocumentElementIndex = 0, representationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "stereochemistry":
                    position = checkElementOrder("stereochemistry", 2, position, false);
                    builder.stereochemistry(parseCodeableConcept("stereochemistry", reader, -1));
                    break;
                case "opticalActivity":
                    position = checkElementOrder("opticalActivity", 3, position, false);
                    builder.opticalActivity(parseCodeableConcept("opticalActivity", reader, -1));
                    break;
                case "molecularFormula":
                    position = checkElementOrder("molecularFormula", 4, position, false);
                    builder.molecularFormula(parseString("molecularFormula", reader, -1));
                    break;
                case "molecularFormulaByMoiety":
                    position = checkElementOrder("molecularFormulaByMoiety", 5, position, false);
                    builder.molecularFormulaByMoiety(parseString("molecularFormulaByMoiety", reader, -1));
                    break;
                case "molecularWeight":
                    position = checkElementOrder("molecularWeight", 6, position, false);
                    builder.molecularWeight(parseSubstanceDefinitionMolecularWeight("molecularWeight", reader, -1));
                    break;
                case "technique":
                    position = checkElementOrder("technique", 7, position, true);
                    builder.technique(parseCodeableConcept("technique", reader, techniqueElementIndex++));
                    break;
                case "sourceDocument":
                    position = checkElementOrder("sourceDocument", 8, position, true);
                    builder.sourceDocument(parseReference("sourceDocument", reader, sourceDocumentElementIndex++));
                    break;
                case "representation":
                    position = checkElementOrder("representation", 9, position, true);
                    builder.representation(parseSubstanceDefinitionStructureRepresentation("representation", reader, representationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Structure.Representation parseSubstanceDefinitionStructureRepresentation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Structure.Representation.Builder builder = SubstanceDefinition.Structure.Representation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "representation":
                    position = checkElementOrder("representation", 3, position, false);
                    builder.representation(parseString("representation", reader, -1));
                    break;
                case "format":
                    position = checkElementOrder("format", 4, position, false);
                    builder.format(parseCodeableConcept("format", reader, -1));
                    break;
                case "document":
                    position = checkElementOrder("document", 5, position, false);
                    builder.document(parseReference("document", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceNucleicAcid parseSubstanceNucleicAcid(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceNucleicAcid.Builder builder = SubstanceNucleicAcid.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, subunitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequenceType":
                    position = checkElementOrder("sequenceType", 8, position, false);
                    builder.sequenceType(parseCodeableConcept("sequenceType", reader, -1));
                    break;
                case "numberOfSubunits":
                    position = checkElementOrder("numberOfSubunits", 9, position, false);
                    builder.numberOfSubunits(parseInteger("numberOfSubunits", reader, -1));
                    break;
                case "areaOfHybridisation":
                    position = checkElementOrder("areaOfHybridisation", 10, position, false);
                    builder.areaOfHybridisation(parseString("areaOfHybridisation", reader, -1));
                    break;
                case "oligoNucleotideType":
                    position = checkElementOrder("oligoNucleotideType", 11, position, false);
                    builder.oligoNucleotideType(parseCodeableConcept("oligoNucleotideType", reader, -1));
                    break;
                case "subunit":
                    position = checkElementOrder("subunit", 12, position, true);
                    builder.subunit(parseSubstanceNucleicAcidSubunit("subunit", reader, subunitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceNucleicAcid.Subunit parseSubstanceNucleicAcidSubunit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceNucleicAcid.Subunit.Builder builder = SubstanceNucleicAcid.Subunit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, linkageElementIndex = 0, sugarElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "subunit":
                    position = checkElementOrder("subunit", 2, position, false);
                    builder.subunit(parseInteger("subunit", reader, -1));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 3, position, false);
                    builder.sequence(parseString("sequence", reader, -1));
                    break;
                case "length":
                    position = checkElementOrder("length", 4, position, false);
                    builder.length(parseInteger("length", reader, -1));
                    break;
                case "sequenceAttachment":
                    position = checkElementOrder("sequenceAttachment", 5, position, false);
                    builder.sequenceAttachment(parseAttachment("sequenceAttachment", reader, -1));
                    break;
                case "fivePrime":
                    position = checkElementOrder("fivePrime", 6, position, false);
                    builder.fivePrime(parseCodeableConcept("fivePrime", reader, -1));
                    break;
                case "threePrime":
                    position = checkElementOrder("threePrime", 7, position, false);
                    builder.threePrime(parseCodeableConcept("threePrime", reader, -1));
                    break;
                case "linkage":
                    position = checkElementOrder("linkage", 8, position, true);
                    builder.linkage(parseSubstanceNucleicAcidSubunitLinkage("linkage", reader, linkageElementIndex++));
                    break;
                case "sugar":
                    position = checkElementOrder("sugar", 9, position, true);
                    builder.sugar(parseSubstanceNucleicAcidSubunitSugar("sugar", reader, sugarElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceNucleicAcid.Subunit.Linkage parseSubstanceNucleicAcidSubunitLinkage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceNucleicAcid.Subunit.Linkage.Builder builder = SubstanceNucleicAcid.Subunit.Linkage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "connectivity":
                    position = checkElementOrder("connectivity", 2, position, false);
                    builder.connectivity(parseString("connectivity", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "residueSite":
                    position = checkElementOrder("residueSite", 5, position, false);
                    builder.residueSite(parseString("residueSite", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceNucleicAcid.Subunit.Sugar parseSubstanceNucleicAcidSubunitSugar(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceNucleicAcid.Subunit.Sugar.Builder builder = SubstanceNucleicAcid.Subunit.Sugar.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "residueSite":
                    position = checkElementOrder("residueSite", 4, position, false);
                    builder.residueSite(parseString("residueSite", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstancePolymer parseSubstancePolymer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstancePolymer.Builder builder = SubstancePolymer.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, copolymerConnectivityElementIndex = 0, monomerSetElementIndex = 0, repeatElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "class":
                    position = checkElementOrder("class", 9, position, false);
                    builder.clazz(parseCodeableConcept("class", reader, -1));
                    break;
                case "geometry":
                    position = checkElementOrder("geometry", 10, position, false);
                    builder.geometry(parseCodeableConcept("geometry", reader, -1));
                    break;
                case "copolymerConnectivity":
                    position = checkElementOrder("copolymerConnectivity", 11, position, true);
                    builder.copolymerConnectivity(parseCodeableConcept("copolymerConnectivity", reader, copolymerConnectivityElementIndex++));
                    break;
                case "modification":
                    position = checkElementOrder("modification", 12, position, false);
                    builder.modification(parseString("modification", reader, -1));
                    break;
                case "monomerSet":
                    position = checkElementOrder("monomerSet", 13, position, true);
                    builder.monomerSet(parseSubstancePolymerMonomerSet("monomerSet", reader, monomerSetElementIndex++));
                    break;
                case "repeat":
                    position = checkElementOrder("repeat", 14, position, true);
                    builder.repeat(parseSubstancePolymerRepeat("repeat", reader, repeatElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstancePolymer.MonomerSet parseSubstancePolymerMonomerSet(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstancePolymer.MonomerSet.Builder builder = SubstancePolymer.MonomerSet.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, startingMaterialElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "ratioType":
                    position = checkElementOrder("ratioType", 2, position, false);
                    builder.ratioType(parseCodeableConcept("ratioType", reader, -1));
                    break;
                case "startingMaterial":
                    position = checkElementOrder("startingMaterial", 3, position, true);
                    builder.startingMaterial(parseSubstancePolymerMonomerSetStartingMaterial("startingMaterial", reader, startingMaterialElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstancePolymer.MonomerSet.StartingMaterial parseSubstancePolymerMonomerSetStartingMaterial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstancePolymer.MonomerSet.StartingMaterial.Builder builder = SubstancePolymer.MonomerSet.StartingMaterial.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 3, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "isDefining":
                    position = checkElementOrder("isDefining", 4, position, false);
                    builder.isDefining(parseBoolean("isDefining", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 5, position, false);
                    builder.amount(parseQuantity("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstancePolymer.Repeat parseSubstancePolymerRepeat(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstancePolymer.Repeat.Builder builder = SubstancePolymer.Repeat.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, repeatUnitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "averageMolecularFormula":
                    position = checkElementOrder("averageMolecularFormula", 2, position, false);
                    builder.averageMolecularFormula(parseString("averageMolecularFormula", reader, -1));
                    break;
                case "repeatUnitAmountType":
                    position = checkElementOrder("repeatUnitAmountType", 3, position, false);
                    builder.repeatUnitAmountType(parseCodeableConcept("repeatUnitAmountType", reader, -1));
                    break;
                case "repeatUnit":
                    position = checkElementOrder("repeatUnit", 4, position, true);
                    builder.repeatUnit(parseSubstancePolymerRepeatRepeatUnit("repeatUnit", reader, repeatUnitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstancePolymer.Repeat.RepeatUnit parseSubstancePolymerRepeatRepeatUnit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstancePolymer.Repeat.RepeatUnit.Builder builder = SubstancePolymer.Repeat.RepeatUnit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, degreeOfPolymerisationElementIndex = 0, structuralRepresentationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 2, position, false);
                    builder.unit(parseString("unit", reader, -1));
                    break;
                case "orientation":
                    position = checkElementOrder("orientation", 3, position, false);
                    builder.orientation(parseCodeableConcept("orientation", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 4, position, false);
                    builder.amount(parseInteger("amount", reader, -1));
                    break;
                case "degreeOfPolymerisation":
                    position = checkElementOrder("degreeOfPolymerisation", 5, position, true);
                    builder.degreeOfPolymerisation(parseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation("degreeOfPolymerisation", reader, degreeOfPolymerisationElementIndex++));
                    break;
                case "structuralRepresentation":
                    position = checkElementOrder("structuralRepresentation", 6, position, true);
                    builder.structuralRepresentation(parseSubstancePolymerRepeatRepeatUnitStructuralRepresentation("structuralRepresentation", reader, structuralRepresentationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstancePolymer.Repeat.RepeatUnit.DegreeOfPolymerisation parseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstancePolymer.Repeat.RepeatUnit.DegreeOfPolymerisation.Builder builder = SubstancePolymer.Repeat.RepeatUnit.DegreeOfPolymerisation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "average":
                    position = checkElementOrder("average", 3, position, false);
                    builder.average(parseInteger("average", reader, -1));
                    break;
                case "low":
                    position = checkElementOrder("low", 4, position, false);
                    builder.low(parseInteger("low", reader, -1));
                    break;
                case "high":
                    position = checkElementOrder("high", 5, position, false);
                    builder.high(parseInteger("high", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstancePolymer.Repeat.RepeatUnit.StructuralRepresentation parseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstancePolymer.Repeat.RepeatUnit.StructuralRepresentation.Builder builder = SubstancePolymer.Repeat.RepeatUnit.StructuralRepresentation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "representation":
                    position = checkElementOrder("representation", 3, position, false);
                    builder.representation(parseString("representation", reader, -1));
                    break;
                case "format":
                    position = checkElementOrder("format", 4, position, false);
                    builder.format(parseCodeableConcept("format", reader, -1));
                    break;
                case "attachment":
                    position = checkElementOrder("attachment", 5, position, false);
                    builder.attachment(parseAttachment("attachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceProtein parseSubstanceProtein(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceProtein.Builder builder = SubstanceProtein.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, disulfideLinkageElementIndex = 0, subunitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequenceType":
                    position = checkElementOrder("sequenceType", 8, position, false);
                    builder.sequenceType(parseCodeableConcept("sequenceType", reader, -1));
                    break;
                case "numberOfSubunits":
                    position = checkElementOrder("numberOfSubunits", 9, position, false);
                    builder.numberOfSubunits(parseInteger("numberOfSubunits", reader, -1));
                    break;
                case "disulfideLinkage":
                    position = checkElementOrder("disulfideLinkage", 10, position, true);
                    builder.disulfideLinkage(parseString("disulfideLinkage", reader, disulfideLinkageElementIndex++));
                    break;
                case "subunit":
                    position = checkElementOrder("subunit", 11, position, true);
                    builder.subunit(parseSubstanceProteinSubunit("subunit", reader, subunitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceProtein.Subunit parseSubstanceProteinSubunit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceProtein.Subunit.Builder builder = SubstanceProtein.Subunit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "subunit":
                    position = checkElementOrder("subunit", 2, position, false);
                    builder.subunit(parseInteger("subunit", reader, -1));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 3, position, false);
                    builder.sequence(parseString("sequence", reader, -1));
                    break;
                case "length":
                    position = checkElementOrder("length", 4, position, false);
                    builder.length(parseInteger("length", reader, -1));
                    break;
                case "sequenceAttachment":
                    position = checkElementOrder("sequenceAttachment", 5, position, false);
                    builder.sequenceAttachment(parseAttachment("sequenceAttachment", reader, -1));
                    break;
                case "nTerminalModificationId":
                    position = checkElementOrder("nTerminalModificationId", 6, position, false);
                    builder.nTerminalModificationId(parseIdentifier("nTerminalModificationId", reader, -1));
                    break;
                case "nTerminalModification":
                    position = checkElementOrder("nTerminalModification", 7, position, false);
                    builder.nTerminalModification(parseString("nTerminalModification", reader, -1));
                    break;
                case "cTerminalModificationId":
                    position = checkElementOrder("cTerminalModificationId", 8, position, false);
                    builder.cTerminalModificationId(parseIdentifier("cTerminalModificationId", reader, -1));
                    break;
                case "cTerminalModification":
                    position = checkElementOrder("cTerminalModification", 9, position, false);
                    builder.cTerminalModification(parseString("cTerminalModification", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceReferenceInformation parseSubstanceReferenceInformation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceReferenceInformation.Builder builder = SubstanceReferenceInformation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, geneElementIndex = 0, geneElementElementIndex = 0, targetElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 8, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                case "gene":
                    position = checkElementOrder("gene", 9, position, true);
                    builder.gene(parseSubstanceReferenceInformationGene("gene", reader, geneElementIndex++));
                    break;
                case "geneElement":
                    position = checkElementOrder("geneElement", 10, position, true);
                    builder.geneElement(parseSubstanceReferenceInformationGeneElement("geneElement", reader, geneElementElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 11, position, true);
                    builder.target(parseSubstanceReferenceInformationTarget("target", reader, targetElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceReferenceInformation.Gene parseSubstanceReferenceInformationGene(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceReferenceInformation.Gene.Builder builder = SubstanceReferenceInformation.Gene.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "geneSequenceOrigin":
                    position = checkElementOrder("geneSequenceOrigin", 2, position, false);
                    builder.geneSequenceOrigin(parseCodeableConcept("geneSequenceOrigin", reader, -1));
                    break;
                case "gene":
                    position = checkElementOrder("gene", 3, position, false);
                    builder.gene(parseCodeableConcept("gene", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 4, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceReferenceInformation.GeneElement parseSubstanceReferenceInformationGeneElement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceReferenceInformation.GeneElement.Builder builder = SubstanceReferenceInformation.GeneElement.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "element":
                    position = checkElementOrder("element", 3, position, false);
                    builder.element(parseIdentifier("element", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 4, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceReferenceInformation.Target parseSubstanceReferenceInformationTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceReferenceInformation.Target.Builder builder = SubstanceReferenceInformation.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 2, position, false);
                    builder.target(parseIdentifier("target", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "interaction":
                    position = checkElementOrder("interaction", 4, position, false);
                    builder.interaction(parseCodeableConcept("interaction", reader, -1));
                    break;
                case "organism":
                    position = checkElementOrder("organism", 5, position, false);
                    builder.organism(parseCodeableConcept("organism", reader, -1));
                    break;
                case "organismType":
                    position = checkElementOrder("organismType", 6, position, false);
                    builder.organismType(parseCodeableConcept("organismType", reader, -1));
                    break;
                case "amountQuantity":
                    position = checkElementOrder("amount[x]", 7, position, false);
                    builder.amount(parseQuantity("amountQuantity", reader, -1));
                    break;
                case "amountRange":
                    position = checkElementOrder("amount[x]", 7, position, false);
                    builder.amount(parseRange("amountRange", reader, -1));
                    break;
                case "amountString":
                    position = checkElementOrder("amount[x]", 7, position, false);
                    builder.amount(parseString("amountString", reader, -1));
                    break;
                case "amountType":
                    position = checkElementOrder("amountType", 8, position, false);
                    builder.amountType(parseCodeableConcept("amountType", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 9, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceSourceMaterial parseSubstanceSourceMaterial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceSourceMaterial.Builder builder = SubstanceSourceMaterial.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, parentSubstanceIdElementIndex = 0, parentSubstanceNameElementIndex = 0, countryOfOriginElementIndex = 0, geographicalLocationElementIndex = 0, fractionDescriptionElementIndex = 0, partDescriptionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sourceMaterialClass":
                    position = checkElementOrder("sourceMaterialClass", 8, position, false);
                    builder.sourceMaterialClass(parseCodeableConcept("sourceMaterialClass", reader, -1));
                    break;
                case "sourceMaterialType":
                    position = checkElementOrder("sourceMaterialType", 9, position, false);
                    builder.sourceMaterialType(parseCodeableConcept("sourceMaterialType", reader, -1));
                    break;
                case "sourceMaterialState":
                    position = checkElementOrder("sourceMaterialState", 10, position, false);
                    builder.sourceMaterialState(parseCodeableConcept("sourceMaterialState", reader, -1));
                    break;
                case "organismId":
                    position = checkElementOrder("organismId", 11, position, false);
                    builder.organismId(parseIdentifier("organismId", reader, -1));
                    break;
                case "organismName":
                    position = checkElementOrder("organismName", 12, position, false);
                    builder.organismName(parseString("organismName", reader, -1));
                    break;
                case "parentSubstanceId":
                    position = checkElementOrder("parentSubstanceId", 13, position, true);
                    builder.parentSubstanceId(parseIdentifier("parentSubstanceId", reader, parentSubstanceIdElementIndex++));
                    break;
                case "parentSubstanceName":
                    position = checkElementOrder("parentSubstanceName", 14, position, true);
                    builder.parentSubstanceName(parseString("parentSubstanceName", reader, parentSubstanceNameElementIndex++));
                    break;
                case "countryOfOrigin":
                    position = checkElementOrder("countryOfOrigin", 15, position, true);
                    builder.countryOfOrigin(parseCodeableConcept("countryOfOrigin", reader, countryOfOriginElementIndex++));
                    break;
                case "geographicalLocation":
                    position = checkElementOrder("geographicalLocation", 16, position, true);
                    builder.geographicalLocation(parseString("geographicalLocation", reader, geographicalLocationElementIndex++));
                    break;
                case "developmentStage":
                    position = checkElementOrder("developmentStage", 17, position, false);
                    builder.developmentStage(parseCodeableConcept("developmentStage", reader, -1));
                    break;
                case "fractionDescription":
                    position = checkElementOrder("fractionDescription", 18, position, true);
                    builder.fractionDescription(parseSubstanceSourceMaterialFractionDescription("fractionDescription", reader, fractionDescriptionElementIndex++));
                    break;
                case "organism":
                    position = checkElementOrder("organism", 19, position, false);
                    builder.organism(parseSubstanceSourceMaterialOrganism("organism", reader, -1));
                    break;
                case "partDescription":
                    position = checkElementOrder("partDescription", 20, position, true);
                    builder.partDescription(parseSubstanceSourceMaterialPartDescription("partDescription", reader, partDescriptionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceSourceMaterial.FractionDescription parseSubstanceSourceMaterialFractionDescription(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceSourceMaterial.FractionDescription.Builder builder = SubstanceSourceMaterial.FractionDescription.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "fraction":
                    position = checkElementOrder("fraction", 2, position, false);
                    builder.fraction(parseString("fraction", reader, -1));
                    break;
                case "materialType":
                    position = checkElementOrder("materialType", 3, position, false);
                    builder.materialType(parseCodeableConcept("materialType", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceSourceMaterial.Organism parseSubstanceSourceMaterialOrganism(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceSourceMaterial.Organism.Builder builder = SubstanceSourceMaterial.Organism.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, authorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "family":
                    position = checkElementOrder("family", 2, position, false);
                    builder.family(parseCodeableConcept("family", reader, -1));
                    break;
                case "genus":
                    position = checkElementOrder("genus", 3, position, false);
                    builder.genus(parseCodeableConcept("genus", reader, -1));
                    break;
                case "species":
                    position = checkElementOrder("species", 4, position, false);
                    builder.species(parseCodeableConcept("species", reader, -1));
                    break;
                case "intraspecificType":
                    position = checkElementOrder("intraspecificType", 5, position, false);
                    builder.intraspecificType(parseCodeableConcept("intraspecificType", reader, -1));
                    break;
                case "intraspecificDescription":
                    position = checkElementOrder("intraspecificDescription", 6, position, false);
                    builder.intraspecificDescription(parseString("intraspecificDescription", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 7, position, true);
                    builder.author(parseSubstanceSourceMaterialOrganismAuthor("author", reader, authorElementIndex++));
                    break;
                case "hybrid":
                    position = checkElementOrder("hybrid", 8, position, false);
                    builder.hybrid(parseSubstanceSourceMaterialOrganismHybrid("hybrid", reader, -1));
                    break;
                case "organismGeneral":
                    position = checkElementOrder("organismGeneral", 9, position, false);
                    builder.organismGeneral(parseSubstanceSourceMaterialOrganismOrganismGeneral("organismGeneral", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceSourceMaterial.Organism.Author parseSubstanceSourceMaterialOrganismAuthor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceSourceMaterial.Organism.Author.Builder builder = SubstanceSourceMaterial.Organism.Author.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "authorType":
                    position = checkElementOrder("authorType", 2, position, false);
                    builder.authorType(parseCodeableConcept("authorType", reader, -1));
                    break;
                case "authorDescription":
                    position = checkElementOrder("authorDescription", 3, position, false);
                    builder.authorDescription(parseString("authorDescription", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceSourceMaterial.Organism.Hybrid parseSubstanceSourceMaterialOrganismHybrid(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceSourceMaterial.Organism.Hybrid.Builder builder = SubstanceSourceMaterial.Organism.Hybrid.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "maternalOrganismId":
                    position = checkElementOrder("maternalOrganismId", 2, position, false);
                    builder.maternalOrganismId(parseString("maternalOrganismId", reader, -1));
                    break;
                case "maternalOrganismName":
                    position = checkElementOrder("maternalOrganismName", 3, position, false);
                    builder.maternalOrganismName(parseString("maternalOrganismName", reader, -1));
                    break;
                case "paternalOrganismId":
                    position = checkElementOrder("paternalOrganismId", 4, position, false);
                    builder.paternalOrganismId(parseString("paternalOrganismId", reader, -1));
                    break;
                case "paternalOrganismName":
                    position = checkElementOrder("paternalOrganismName", 5, position, false);
                    builder.paternalOrganismName(parseString("paternalOrganismName", reader, -1));
                    break;
                case "hybridType":
                    position = checkElementOrder("hybridType", 6, position, false);
                    builder.hybridType(parseCodeableConcept("hybridType", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceSourceMaterial.Organism.OrganismGeneral parseSubstanceSourceMaterialOrganismOrganismGeneral(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceSourceMaterial.Organism.OrganismGeneral.Builder builder = SubstanceSourceMaterial.Organism.OrganismGeneral.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "kingdom":
                    position = checkElementOrder("kingdom", 2, position, false);
                    builder.kingdom(parseCodeableConcept("kingdom", reader, -1));
                    break;
                case "phylum":
                    position = checkElementOrder("phylum", 3, position, false);
                    builder.phylum(parseCodeableConcept("phylum", reader, -1));
                    break;
                case "class":
                    position = checkElementOrder("class", 4, position, false);
                    builder.clazz(parseCodeableConcept("class", reader, -1));
                    break;
                case "order":
                    position = checkElementOrder("order", 5, position, false);
                    builder.order(parseCodeableConcept("order", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceSourceMaterial.PartDescription parseSubstanceSourceMaterialPartDescription(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceSourceMaterial.PartDescription.Builder builder = SubstanceSourceMaterial.PartDescription.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "part":
                    position = checkElementOrder("part", 2, position, false);
                    builder.part(parseCodeableConcept("part", reader, -1));
                    break;
                case "partLocation":
                    position = checkElementOrder("partLocation", 3, position, false);
                    builder.partLocation(parseCodeableConcept("partLocation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SupplyDelivery parseSupplyDelivery(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SupplyDelivery.Builder builder = SupplyDelivery.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, suppliedItemElementIndex = 0, receiverElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((SupplyDeliveryStatus) parseString(SupplyDeliveryStatus.builder(), "status", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 12, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 13, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "suppliedItem":
                    position = checkElementOrder("suppliedItem", 14, position, true);
                    builder.suppliedItem(parseSupplyDeliverySuppliedItem("suppliedItem", reader, suppliedItemElementIndex++));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "supplier":
                    position = checkElementOrder("supplier", 16, position, false);
                    builder.supplier(parseReference("supplier", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 17, position, false);
                    builder.destination(parseReference("destination", reader, -1));
                    break;
                case "receiver":
                    position = checkElementOrder("receiver", 18, position, true);
                    builder.receiver(parseReference("receiver", reader, receiverElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SupplyDelivery.SuppliedItem parseSupplyDeliverySuppliedItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SupplyDelivery.SuppliedItem.Builder builder = SupplyDelivery.SuppliedItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 3, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 3, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SupplyRequest parseSupplyRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SupplyRequest.Builder builder = SupplyRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, parameterElementIndex = 0, supplierElementIndex = 0, reasonElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((SupplyRequestStatus) parseString(SupplyRequestStatus.builder(), "status", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 10, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 12, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "deliverFor":
                    position = checkElementOrder("deliverFor", 13, position, false);
                    builder.deliverFor(parseReference("deliverFor", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 14, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 15, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 16, position, true);
                    builder.parameter(parseSupplyRequestParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 17, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 17, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 17, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 18, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 19, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "supplier":
                    position = checkElementOrder("supplier", 20, position, true);
                    builder.supplier(parseReference("supplier", reader, supplierElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 21, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "deliverFrom":
                    position = checkElementOrder("deliverFrom", 22, position, false);
                    builder.deliverFrom(parseReference("deliverFrom", reader, -1));
                    break;
                case "deliverTo":
                    position = checkElementOrder("deliverTo", 23, position, false);
                    builder.deliverTo(parseReference("deliverTo", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SupplyRequest.Parameter parseSupplyRequestParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SupplyRequest.Parameter.Builder builder = SupplyRequest.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Task parseTask(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Task.Builder builder = Task.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, requestedPerformerElementIndex = 0, performerElementIndex = 0, reasonElementIndex = 0, insuranceElementIndex = 0, noteElementIndex = 0, relevantHistoryElementIndex = 0, inputElementIndex = 0, outputElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, false);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, -1));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, false);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 12, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 13, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((TaskStatus) parseString(TaskStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 15, position, false);
                    builder.statusReason(parseCodeableReference("statusReason", reader, -1));
                    break;
                case "businessStatus":
                    position = checkElementOrder("businessStatus", 16, position, false);
                    builder.businessStatus(parseCodeableConcept("businessStatus", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 17, position, false);
                    builder.intent((TaskIntent) parseString(TaskIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 18, position, false);
                    builder.priority((TaskPriority) parseString(TaskPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 19, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 20, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 21, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 22, position, false);
                    builder.focus(parseReference("focus", reader, -1));
                    break;
                case "for":
                    position = checkElementOrder("for", 23, position, false);
                    builder._for(parseReference("for", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 24, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "requestedPeriod":
                    position = checkElementOrder("requestedPeriod", 25, position, false);
                    builder.requestedPeriod(parsePeriod("requestedPeriod", reader, -1));
                    break;
                case "executionPeriod":
                    position = checkElementOrder("executionPeriod", 26, position, false);
                    builder.executionPeriod(parsePeriod("executionPeriod", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 27, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "lastModified":
                    position = checkElementOrder("lastModified", 28, position, false);
                    builder.lastModified(parseDateTime("lastModified", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 29, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "requestedPerformer":
                    position = checkElementOrder("requestedPerformer", 30, position, true);
                    builder.requestedPerformer(parseCodeableReference("requestedPerformer", reader, requestedPerformerElementIndex++));
                    break;
                case "owner":
                    position = checkElementOrder("owner", 31, position, false);
                    builder.owner(parseReference("owner", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 32, position, true);
                    builder.performer(parseTaskPerformer("performer", reader, performerElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 33, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 34, position, true);
                    builder.reason(parseCodeableReference("reason", reader, reasonElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 35, position, true);
                    builder.insurance(parseReference("insurance", reader, insuranceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 36, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "relevantHistory":
                    position = checkElementOrder("relevantHistory", 37, position, true);
                    builder.relevantHistory(parseReference("relevantHistory", reader, relevantHistoryElementIndex++));
                    break;
                case "restriction":
                    position = checkElementOrder("restriction", 38, position, false);
                    builder.restriction(parseTaskRestriction("restriction", reader, -1));
                    break;
                case "input":
                    position = checkElementOrder("input", 39, position, true);
                    builder.input(parseTaskInput("input", reader, inputElementIndex++));
                    break;
                case "output":
                    position = checkElementOrder("output", 40, position, true);
                    builder.output(parseTaskOutput("output", reader, outputElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Task.Input parseTaskInput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Task.Input.Builder builder = Task.Input.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueInteger64":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger64("valueInteger64", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCodeableReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableReference("valueCodeableReference", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRatioRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatioRange("valueRatioRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueAvailability":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAvailability("valueAvailability", reader, -1));
                    break;
                case "valueExtendedContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExtendedContactDetail("valueExtendedContactDetail", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Task.Output parseTaskOutput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Task.Output.Builder builder = Task.Output.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueInteger64":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger64("valueInteger64", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCodeableReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableReference("valueCodeableReference", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRatioRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatioRange("valueRatioRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueAvailability":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAvailability("valueAvailability", reader, -1));
                    break;
                case "valueExtendedContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExtendedContactDetail("valueExtendedContactDetail", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Task.Performer parseTaskPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Task.Performer.Builder builder = Task.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Task.Restriction parseTaskRestriction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Task.Restriction.Builder builder = Task.Restriction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, recipientElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "repetitions":
                    position = checkElementOrder("repetitions", 2, position, false);
                    builder.repetitions((PositiveInt) parseInteger(PositiveInt.builder(), "repetitions", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 4, position, true);
                    builder.recipient(parseReference("recipient", reader, recipientElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities parseTerminologyCapabilities(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Builder builder = TerminologyCapabilities.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, codeSystemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 25, position, false);
                    builder.kind((CapabilityStatementKind) parseString(CapabilityStatementKind.builder(), "kind", reader, -1));
                    break;
                case "software":
                    position = checkElementOrder("software", 26, position, false);
                    builder.software(parseTerminologyCapabilitiesSoftware("software", reader, -1));
                    break;
                case "implementation":
                    position = checkElementOrder("implementation", 27, position, false);
                    builder.implementation(parseTerminologyCapabilitiesImplementation("implementation", reader, -1));
                    break;
                case "lockedDate":
                    position = checkElementOrder("lockedDate", 28, position, false);
                    builder.lockedDate(parseBoolean("lockedDate", reader, -1));
                    break;
                case "codeSystem":
                    position = checkElementOrder("codeSystem", 29, position, true);
                    builder.codeSystem(parseTerminologyCapabilitiesCodeSystem("codeSystem", reader, codeSystemElementIndex++));
                    break;
                case "expansion":
                    position = checkElementOrder("expansion", 30, position, false);
                    builder.expansion(parseTerminologyCapabilitiesExpansion("expansion", reader, -1));
                    break;
                case "codeSearch":
                    position = checkElementOrder("codeSearch", 31, position, false);
                    builder.codeSearch((CodeSearchSupport) parseString(CodeSearchSupport.builder(), "codeSearch", reader, -1));
                    break;
                case "validateCode":
                    position = checkElementOrder("validateCode", 32, position, false);
                    builder.validateCode(parseTerminologyCapabilitiesValidateCode("validateCode", reader, -1));
                    break;
                case "translation":
                    position = checkElementOrder("translation", 33, position, false);
                    builder.translation(parseTerminologyCapabilitiesTranslation("translation", reader, -1));
                    break;
                case "closure":
                    position = checkElementOrder("closure", 34, position, false);
                    builder.closure(parseTerminologyCapabilitiesClosure("closure", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Closure parseTerminologyCapabilitiesClosure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Closure.Builder builder = TerminologyCapabilities.Closure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "translation":
                    position = checkElementOrder("translation", 2, position, false);
                    builder.translation(parseBoolean("translation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.CodeSystem parseTerminologyCapabilitiesCodeSystem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.CodeSystem.Builder builder = TerminologyCapabilities.CodeSystem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, versionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 2, position, false);
                    builder.uri((Canonical) parseUri(Canonical.builder(), "uri", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, true);
                    builder.version(parseTerminologyCapabilitiesCodeSystemVersion("version", reader, versionElementIndex++));
                    break;
                case "content":
                    position = checkElementOrder("content", 4, position, false);
                    builder.content((CodeSystemContentMode) parseString(CodeSystemContentMode.builder(), "content", reader, -1));
                    break;
                case "subsumption":
                    position = checkElementOrder("subsumption", 5, position, false);
                    builder.subsumption(parseBoolean("subsumption", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.CodeSystem.Version parseTerminologyCapabilitiesCodeSystemVersion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.CodeSystem.Version.Builder builder = TerminologyCapabilities.CodeSystem.Version.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, languageElementIndex = 0, filterElementIndex = 0, propertyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseString("code", reader, -1));
                    break;
                case "isDefault":
                    position = checkElementOrder("isDefault", 3, position, false);
                    builder.isDefault(parseBoolean("isDefault", reader, -1));
                    break;
                case "compositional":
                    position = checkElementOrder("compositional", 4, position, false);
                    builder.compositional(parseBoolean("compositional", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 5, position, true);
                    builder.language((Language) parseString(Language.builder(), "language", reader, languageElementIndex++));
                    break;
                case "filter":
                    position = checkElementOrder("filter", 6, position, true);
                    builder.filter(parseTerminologyCapabilitiesCodeSystemVersionFilter("filter", reader, filterElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 7, position, true);
                    builder.property((Code) parseString(Code.builder(), "property", reader, propertyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.CodeSystem.Version.Filter parseTerminologyCapabilitiesCodeSystemVersionFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.CodeSystem.Version.Filter.Builder builder = TerminologyCapabilities.CodeSystem.Version.Filter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, opElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "op":
                    position = checkElementOrder("op", 3, position, true);
                    builder.op((Code) parseString(Code.builder(), "op", reader, opElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Expansion parseTerminologyCapabilitiesExpansion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Expansion.Builder builder = TerminologyCapabilities.Expansion.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, parameterElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "hierarchical":
                    position = checkElementOrder("hierarchical", 2, position, false);
                    builder.hierarchical(parseBoolean("hierarchical", reader, -1));
                    break;
                case "paging":
                    position = checkElementOrder("paging", 3, position, false);
                    builder.paging(parseBoolean("paging", reader, -1));
                    break;
                case "incomplete":
                    position = checkElementOrder("incomplete", 4, position, false);
                    builder.incomplete(parseBoolean("incomplete", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 5, position, true);
                    builder.parameter(parseTerminologyCapabilitiesExpansionParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "textFilter":
                    position = checkElementOrder("textFilter", 6, position, false);
                    builder.textFilter((Markdown) parseString(Markdown.builder(), "textFilter", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Expansion.Parameter parseTerminologyCapabilitiesExpansionParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Expansion.Parameter.Builder builder = TerminologyCapabilities.Expansion.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Code) parseString(Code.builder(), "name", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Implementation parseTerminologyCapabilitiesImplementation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Implementation.Builder builder = TerminologyCapabilities.Implementation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Software parseTerminologyCapabilitiesSoftware(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Software.Builder builder = TerminologyCapabilities.Software.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Translation parseTerminologyCapabilitiesTranslation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Translation.Builder builder = TerminologyCapabilities.Translation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "needsMap":
                    position = checkElementOrder("needsMap", 2, position, false);
                    builder.needsMap(parseBoolean("needsMap", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.ValidateCode parseTerminologyCapabilitiesValidateCode(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.ValidateCode.Builder builder = TerminologyCapabilities.ValidateCode.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "translations":
                    position = checkElementOrder("translations", 2, position, false);
                    builder.translations(parseBoolean("translations", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestPlan parseTestPlan(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestPlan.Builder builder = TestPlan.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, categoryElementIndex = 0, scopeElementIndex = 0, dependencyElementIndex = 0, testCaseElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 25, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 26, position, true);
                    builder.scope(parseReference("scope", reader, scopeElementIndex++));
                    break;
                case "testTools":
                    position = checkElementOrder("testTools", 27, position, false);
                    builder.testTools((Markdown) parseString(Markdown.builder(), "testTools", reader, -1));
                    break;
                case "dependency":
                    position = checkElementOrder("dependency", 28, position, true);
                    builder.dependency(parseTestPlanDependency("dependency", reader, dependencyElementIndex++));
                    break;
                case "exitCriteria":
                    position = checkElementOrder("exitCriteria", 29, position, false);
                    builder.exitCriteria((Markdown) parseString(Markdown.builder(), "exitCriteria", reader, -1));
                    break;
                case "testCase":
                    position = checkElementOrder("testCase", 30, position, true);
                    builder.testCase(parseTestPlanTestCase("testCase", reader, testCaseElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestPlan.Dependency parseTestPlanDependency(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestPlan.Dependency.Builder builder = TestPlan.Dependency.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "predecessor":
                    position = checkElementOrder("predecessor", 3, position, false);
                    builder.predecessor(parseReference("predecessor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestPlan.TestCase parseTestPlanTestCase(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestPlan.TestCase.Builder builder = TestPlan.TestCase.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, scopeElementIndex = 0, dependencyElementIndex = 0, testRunElementIndex = 0, testDataElementIndex = 0, assertionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence(parseInteger("sequence", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 3, position, true);
                    builder.scope(parseReference("scope", reader, scopeElementIndex++));
                    break;
                case "dependency":
                    position = checkElementOrder("dependency", 4, position, true);
                    builder.dependency(parseTestPlanTestCaseDependency("dependency", reader, dependencyElementIndex++));
                    break;
                case "testRun":
                    position = checkElementOrder("testRun", 5, position, true);
                    builder.testRun(parseTestPlanTestCaseTestRun("testRun", reader, testRunElementIndex++));
                    break;
                case "testData":
                    position = checkElementOrder("testData", 6, position, true);
                    builder.testData(parseTestPlanTestCaseTestData("testData", reader, testDataElementIndex++));
                    break;
                case "assertion":
                    position = checkElementOrder("assertion", 7, position, true);
                    builder.assertion(parseTestPlanTestCaseAssertion("assertion", reader, assertionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestPlan.TestCase.Assertion parseTestPlanTestCaseAssertion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestPlan.TestCase.Assertion.Builder builder = TestPlan.TestCase.Assertion.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, objectElementIndex = 0, resultElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "object":
                    position = checkElementOrder("object", 3, position, true);
                    builder.object(parseCodeableReference("object", reader, objectElementIndex++));
                    break;
                case "result":
                    position = checkElementOrder("result", 4, position, true);
                    builder.result(parseCodeableReference("result", reader, resultElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestPlan.TestCase.Dependency parseTestPlanTestCaseDependency(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestPlan.TestCase.Dependency.Builder builder = TestPlan.TestCase.Dependency.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "predecessor":
                    position = checkElementOrder("predecessor", 3, position, false);
                    builder.predecessor(parseReference("predecessor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestPlan.TestCase.TestData parseTestPlanTestCaseTestData(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestPlan.TestCase.TestData.Builder builder = TestPlan.TestCase.TestData.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCoding("type", reader, -1));
                    break;
                case "content":
                    position = checkElementOrder("content", 3, position, false);
                    builder.content(parseReference("content", reader, -1));
                    break;
                case "sourceString":
                    position = checkElementOrder("source[x]", 4, position, false);
                    builder.source(parseString("sourceString", reader, -1));
                    break;
                case "sourceReference":
                    position = checkElementOrder("source[x]", 4, position, false);
                    builder.source(parseReference("sourceReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestPlan.TestCase.TestRun parseTestPlanTestCaseTestRun(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestPlan.TestCase.TestRun.Builder builder = TestPlan.TestCase.TestRun.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "narrative":
                    position = checkElementOrder("narrative", 2, position, false);
                    builder.narrative((Markdown) parseString(Markdown.builder(), "narrative", reader, -1));
                    break;
                case "script":
                    position = checkElementOrder("script", 3, position, false);
                    builder.script(parseTestPlanTestCaseTestRunScript("script", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestPlan.TestCase.TestRun.Script parseTestPlanTestCaseTestRunScript(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestPlan.TestCase.TestRun.Script.Builder builder = TestPlan.TestCase.TestRun.Script.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "sourceString":
                    position = checkElementOrder("source[x]", 3, position, false);
                    builder.source(parseString("sourceString", reader, -1));
                    break;
                case "sourceReference":
                    position = checkElementOrder("source[x]", 3, position, false);
                    builder.source(parseReference("sourceReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport parseTestReport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Builder builder = TestReport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, participantElementIndex = 0, testElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 9, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((TestReportStatus) parseString(TestReportStatus.builder(), "status", reader, -1));
                    break;
                case "testScript":
                    position = checkElementOrder("testScript", 11, position, false);
                    builder.testScript((Canonical) parseUri(Canonical.builder(), "testScript", reader, -1));
                    break;
                case "result":
                    position = checkElementOrder("result", 12, position, false);
                    builder.result((TestReportResult) parseString(TestReportResult.builder(), "result", reader, -1));
                    break;
                case "score":
                    position = checkElementOrder("score", 13, position, false);
                    builder.score(parseDecimal("score", reader, -1));
                    break;
                case "tester":
                    position = checkElementOrder("tester", 14, position, false);
                    builder.tester(parseString("tester", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 15, position, false);
                    builder.issued(parseDateTime("issued", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 16, position, true);
                    builder.participant(parseTestReportParticipant("participant", reader, participantElementIndex++));
                    break;
                case "setup":
                    position = checkElementOrder("setup", 17, position, false);
                    builder.setup(parseTestReportSetup("setup", reader, -1));
                    break;
                case "test":
                    position = checkElementOrder("test", 18, position, true);
                    builder.test(parseTestReportTest("test", reader, testElementIndex++));
                    break;
                case "teardown":
                    position = checkElementOrder("teardown", 19, position, false);
                    builder.teardown(parseTestReportTeardown("teardown", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Participant parseTestReportParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Participant.Builder builder = TestReport.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((TestReportParticipantType) parseString(TestReportParticipantType.builder(), "type", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Setup parseTestReportSetup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Setup.Builder builder = TestReport.Setup.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, true);
                    builder.action(parseTestReportSetupAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Setup.Action parseTestReportSetupAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Setup.Action.Builder builder = TestReport.Setup.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestReportSetupActionOperation("operation", reader, -1));
                    break;
                case "assert":
                    position = checkElementOrder("assert", 3, position, false);
                    builder._assert(parseTestReportSetupActionAssert("assert", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Setup.Action.Assert parseTestReportSetupActionAssert(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Setup.Action.Assert.Builder builder = TestReport.Setup.Action.Assert.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, requirementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "result":
                    position = checkElementOrder("result", 2, position, false);
                    builder.result((TestReportActionResult) parseString(TestReportActionResult.builder(), "result", reader, -1));
                    break;
                case "message":
                    position = checkElementOrder("message", 3, position, false);
                    builder.message((Markdown) parseString(Markdown.builder(), "message", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 4, position, false);
                    builder.detail(parseString("detail", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 5, position, true);
                    builder.requirement(parseTestReportSetupActionAssertRequirement("requirement", reader, requirementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Setup.Action.Assert.Requirement parseTestReportSetupActionAssertRequirement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Setup.Action.Assert.Requirement.Builder builder = TestReport.Setup.Action.Assert.Requirement.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkUri":
                    position = checkElementOrder("link[x]", 2, position, false);
                    builder.link(parseUri("linkUri", reader, -1));
                    break;
                case "linkCanonical":
                    position = checkElementOrder("link[x]", 2, position, false);
                    builder.link((Canonical) parseUri(Canonical.builder(), "linkCanonical", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Setup.Action.Operation parseTestReportSetupActionOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Setup.Action.Operation.Builder builder = TestReport.Setup.Action.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "result":
                    position = checkElementOrder("result", 2, position, false);
                    builder.result((TestReportActionResult) parseString(TestReportActionResult.builder(), "result", reader, -1));
                    break;
                case "message":
                    position = checkElementOrder("message", 3, position, false);
                    builder.message((Markdown) parseString(Markdown.builder(), "message", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 4, position, false);
                    builder.detail(parseUri("detail", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Teardown parseTestReportTeardown(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Teardown.Builder builder = TestReport.Teardown.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, true);
                    builder.action(parseTestReportTeardownAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Teardown.Action parseTestReportTeardownAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Teardown.Action.Builder builder = TestReport.Teardown.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestReportSetupActionOperation("operation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Test parseTestReportTest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Test.Builder builder = TestReport.Test.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "action":
                    position = checkElementOrder("action", 4, position, true);
                    builder.action(parseTestReportTestAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Test.Action parseTestReportTestAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Test.Action.Builder builder = TestReport.Test.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestReportSetupActionOperation("operation", reader, -1));
                    break;
                case "assert":
                    position = checkElementOrder("assert", 3, position, false);
                    builder._assert(parseTestReportSetupActionAssert("assert", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript parseTestScript(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Builder builder = TestScript.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, originElementIndex = 0, destinationElementIndex = 0, scopeElementIndex = 0, fixtureElementIndex = 0, profileElementIndex = 0, variableElementIndex = 0, testElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 24, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 25, position, true);
                    builder.origin(parseTestScriptOrigin("origin", reader, originElementIndex++));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 26, position, true);
                    builder.destination(parseTestScriptDestination("destination", reader, destinationElementIndex++));
                    break;
                case "metadata":
                    position = checkElementOrder("metadata", 27, position, false);
                    builder.metadata(parseTestScriptMetadata("metadata", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 28, position, true);
                    builder.scope(parseTestScriptScope("scope", reader, scopeElementIndex++));
                    break;
                case "fixture":
                    position = checkElementOrder("fixture", 29, position, true);
                    builder.fixture(parseTestScriptFixture("fixture", reader, fixtureElementIndex++));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 30, position, true);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, profileElementIndex++));
                    break;
                case "variable":
                    position = checkElementOrder("variable", 31, position, true);
                    builder.variable(parseTestScriptVariable("variable", reader, variableElementIndex++));
                    break;
                case "setup":
                    position = checkElementOrder("setup", 32, position, false);
                    builder.setup(parseTestScriptSetup("setup", reader, -1));
                    break;
                case "test":
                    position = checkElementOrder("test", 33, position, true);
                    builder.test(parseTestScriptTest("test", reader, testElementIndex++));
                    break;
                case "teardown":
                    position = checkElementOrder("teardown", 34, position, false);
                    builder.teardown(parseTestScriptTeardown("teardown", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Destination parseTestScriptDestination(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Destination.Builder builder = TestScript.Destination.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "index":
                    position = checkElementOrder("index", 2, position, false);
                    builder.index(parseInteger("index", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile(parseCoding("profile", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 4, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Fixture parseTestScriptFixture(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Fixture.Builder builder = TestScript.Fixture.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "autocreate":
                    position = checkElementOrder("autocreate", 2, position, false);
                    builder.autocreate(parseBoolean("autocreate", reader, -1));
                    break;
                case "autodelete":
                    position = checkElementOrder("autodelete", 3, position, false);
                    builder.autodelete(parseBoolean("autodelete", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 4, position, false);
                    builder.resource(parseReference("resource", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Metadata parseTestScriptMetadata(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Metadata.Builder builder = TestScript.Metadata.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, linkElementIndex = 0, capabilityElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "link":
                    position = checkElementOrder("link", 2, position, true);
                    builder.link(parseTestScriptMetadataLink("link", reader, linkElementIndex++));
                    break;
                case "capability":
                    position = checkElementOrder("capability", 3, position, true);
                    builder.capability(parseTestScriptMetadataCapability("capability", reader, capabilityElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Metadata.Capability parseTestScriptMetadataCapability(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Metadata.Capability.Builder builder = TestScript.Metadata.Capability.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, originElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "required":
                    position = checkElementOrder("required", 2, position, false);
                    builder.required(parseBoolean("required", reader, -1));
                    break;
                case "validated":
                    position = checkElementOrder("validated", 3, position, false);
                    builder.validated(parseBoolean("validated", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 5, position, true);
                    builder.origin(parseInteger("origin", reader, originElementIndex++));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 6, position, false);
                    builder.destination(parseInteger("destination", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 7, position, true);
                    builder.link(parseUri("link", reader, linkElementIndex++));
                    break;
                case "capabilities":
                    position = checkElementOrder("capabilities", 8, position, false);
                    builder.capabilities((Canonical) parseUri(Canonical.builder(), "capabilities", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Metadata.Link parseTestScriptMetadataLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Metadata.Link.Builder builder = TestScript.Metadata.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 2, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Origin parseTestScriptOrigin(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Origin.Builder builder = TestScript.Origin.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "index":
                    position = checkElementOrder("index", 2, position, false);
                    builder.index(parseInteger("index", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile(parseCoding("profile", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 4, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Scope parseTestScriptScope(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Scope.Builder builder = TestScript.Scope.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "artifact":
                    position = checkElementOrder("artifact", 2, position, false);
                    builder.artifact((Canonical) parseUri(Canonical.builder(), "artifact", reader, -1));
                    break;
                case "conformance":
                    position = checkElementOrder("conformance", 3, position, false);
                    builder.conformance(parseCodeableConcept("conformance", reader, -1));
                    break;
                case "phase":
                    position = checkElementOrder("phase", 4, position, false);
                    builder.phase(parseCodeableConcept("phase", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup parseTestScriptSetup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Builder builder = TestScript.Setup.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, true);
                    builder.action(parseTestScriptSetupAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup.Action parseTestScriptSetupAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Action.Builder builder = TestScript.Setup.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestScriptSetupActionOperation("operation", reader, -1));
                    break;
                case "assert":
                    position = checkElementOrder("assert", 3, position, false);
                    builder._assert(parseTestScriptSetupActionAssert("assert", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup.Action.Assert parseTestScriptSetupActionAssert(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Action.Assert.Builder builder = TestScript.Setup.Action.Assert.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, requirementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "label":
                    position = checkElementOrder("label", 2, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "direction":
                    position = checkElementOrder("direction", 4, position, false);
                    builder.direction((AssertionDirectionType) parseString(AssertionDirectionType.builder(), "direction", reader, -1));
                    break;
                case "compareToSourceId":
                    position = checkElementOrder("compareToSourceId", 5, position, false);
                    builder.compareToSourceId(parseString("compareToSourceId", reader, -1));
                    break;
                case "compareToSourceExpression":
                    position = checkElementOrder("compareToSourceExpression", 6, position, false);
                    builder.compareToSourceExpression(parseString("compareToSourceExpression", reader, -1));
                    break;
                case "compareToSourcePath":
                    position = checkElementOrder("compareToSourcePath", 7, position, false);
                    builder.compareToSourcePath(parseString("compareToSourcePath", reader, -1));
                    break;
                case "contentType":
                    position = checkElementOrder("contentType", 8, position, false);
                    builder.contentType((Code) parseString(Code.builder(), "contentType", reader, -1));
                    break;
                case "defaultManualCompletion":
                    position = checkElementOrder("defaultManualCompletion", 9, position, false);
                    builder.defaultManualCompletion((AssertionManualCompletionType) parseString(AssertionManualCompletionType.builder(), "defaultManualCompletion", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 10, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "headerField":
                    position = checkElementOrder("headerField", 11, position, false);
                    builder.headerField(parseString("headerField", reader, -1));
                    break;
                case "minimumId":
                    position = checkElementOrder("minimumId", 12, position, false);
                    builder.minimumId(parseString("minimumId", reader, -1));
                    break;
                case "navigationLinks":
                    position = checkElementOrder("navigationLinks", 13, position, false);
                    builder.navigationLinks(parseBoolean("navigationLinks", reader, -1));
                    break;
                case "operator":
                    position = checkElementOrder("operator", 14, position, false);
                    builder.operator((AssertionOperatorType) parseString(AssertionOperatorType.builder(), "operator", reader, -1));
                    break;
                case "path":
                    position = checkElementOrder("path", 15, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "requestMethod":
                    position = checkElementOrder("requestMethod", 16, position, false);
                    builder.requestMethod((TestScriptRequestMethodCode) parseString(TestScriptRequestMethodCode.builder(), "requestMethod", reader, -1));
                    break;
                case "requestURL":
                    position = checkElementOrder("requestURL", 17, position, false);
                    builder.requestURL(parseString("requestURL", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 18, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 19, position, false);
                    builder.response((AssertionResponseTypes) parseString(AssertionResponseTypes.builder(), "response", reader, -1));
                    break;
                case "responseCode":
                    position = checkElementOrder("responseCode", 20, position, false);
                    builder.responseCode(parseString("responseCode", reader, -1));
                    break;
                case "sourceId":
                    position = checkElementOrder("sourceId", 21, position, false);
                    builder.sourceId((Id) parseString(Id.builder(), "sourceId", reader, -1));
                    break;
                case "stopTestOnFail":
                    position = checkElementOrder("stopTestOnFail", 22, position, false);
                    builder.stopTestOnFail(parseBoolean("stopTestOnFail", reader, -1));
                    break;
                case "validateProfileId":
                    position = checkElementOrder("validateProfileId", 23, position, false);
                    builder.validateProfileId((Id) parseString(Id.builder(), "validateProfileId", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 24, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "warningOnly":
                    position = checkElementOrder("warningOnly", 25, position, false);
                    builder.warningOnly(parseBoolean("warningOnly", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 26, position, true);
                    builder.requirement(parseTestScriptSetupActionAssertRequirement("requirement", reader, requirementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup.Action.Assert.Requirement parseTestScriptSetupActionAssertRequirement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Action.Assert.Requirement.Builder builder = TestScript.Setup.Action.Assert.Requirement.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkUri":
                    position = checkElementOrder("link[x]", 2, position, false);
                    builder.link(parseUri("linkUri", reader, -1));
                    break;
                case "linkCanonical":
                    position = checkElementOrder("link[x]", 2, position, false);
                    builder.link((Canonical) parseUri(Canonical.builder(), "linkCanonical", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup.Action.Operation parseTestScriptSetupActionOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Action.Operation.Builder builder = TestScript.Setup.Action.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, requestHeaderElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCoding("type", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                case "label":
                    position = checkElementOrder("label", 4, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "accept":
                    position = checkElementOrder("accept", 6, position, false);
                    builder.accept((Code) parseString(Code.builder(), "accept", reader, -1));
                    break;
                case "contentType":
                    position = checkElementOrder("contentType", 7, position, false);
                    builder.contentType((Code) parseString(Code.builder(), "contentType", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 8, position, false);
                    builder.destination(parseInteger("destination", reader, -1));
                    break;
                case "encodeRequestUrl":
                    position = checkElementOrder("encodeRequestUrl", 9, position, false);
                    builder.encodeRequestUrl(parseBoolean("encodeRequestUrl", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 10, position, false);
                    builder.method((TestScriptRequestMethodCode) parseString(TestScriptRequestMethodCode.builder(), "method", reader, -1));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 11, position, false);
                    builder.origin(parseInteger("origin", reader, -1));
                    break;
                case "params":
                    position = checkElementOrder("params", 12, position, false);
                    builder.params(parseString("params", reader, -1));
                    break;
                case "requestHeader":
                    position = checkElementOrder("requestHeader", 13, position, true);
                    builder.requestHeader(parseTestScriptSetupActionOperationRequestHeader("requestHeader", reader, requestHeaderElementIndex++));
                    break;
                case "requestId":
                    position = checkElementOrder("requestId", 14, position, false);
                    builder.requestId((Id) parseString(Id.builder(), "requestId", reader, -1));
                    break;
                case "responseId":
                    position = checkElementOrder("responseId", 15, position, false);
                    builder.responseId((Id) parseString(Id.builder(), "responseId", reader, -1));
                    break;
                case "sourceId":
                    position = checkElementOrder("sourceId", 16, position, false);
                    builder.sourceId((Id) parseString(Id.builder(), "sourceId", reader, -1));
                    break;
                case "targetId":
                    position = checkElementOrder("targetId", 17, position, false);
                    builder.targetId((Id) parseString(Id.builder(), "targetId", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 18, position, false);
                    builder.url(parseString("url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup.Action.Operation.RequestHeader parseTestScriptSetupActionOperationRequestHeader(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Action.Operation.RequestHeader.Builder builder = TestScript.Setup.Action.Operation.RequestHeader.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "field":
                    position = checkElementOrder("field", 2, position, false);
                    builder.field(parseString("field", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Teardown parseTestScriptTeardown(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Teardown.Builder builder = TestScript.Teardown.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, true);
                    builder.action(parseTestScriptTeardownAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Teardown.Action parseTestScriptTeardownAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Teardown.Action.Builder builder = TestScript.Teardown.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestScriptSetupActionOperation("operation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Test parseTestScriptTest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Test.Builder builder = TestScript.Test.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "action":
                    position = checkElementOrder("action", 4, position, true);
                    builder.action(parseTestScriptTestAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Test.Action parseTestScriptTestAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Test.Action.Builder builder = TestScript.Test.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestScriptSetupActionOperation("operation", reader, -1));
                    break;
                case "assert":
                    position = checkElementOrder("assert", 3, position, false);
                    builder._assert(parseTestScriptSetupActionAssert("assert", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Variable parseTestScriptVariable(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Variable.Builder builder = TestScript.Variable.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "defaultValue":
                    position = checkElementOrder("defaultValue", 3, position, false);
                    builder.defaultValue(parseString("defaultValue", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 5, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "headerField":
                    position = checkElementOrder("headerField", 6, position, false);
                    builder.headerField(parseString("headerField", reader, -1));
                    break;
                case "hint":
                    position = checkElementOrder("hint", 7, position, false);
                    builder.hint(parseString("hint", reader, -1));
                    break;
                case "path":
                    position = checkElementOrder("path", 8, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "sourceId":
                    position = checkElementOrder("sourceId", 9, position, false);
                    builder.sourceId((Id) parseString(Id.builder(), "sourceId", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Time parseTime(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Time.Builder builder = Time.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Timing parseTiming(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Timing.Builder builder = Timing.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, eventElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "event":
                    position = checkElementOrder("event", 2, position, true);
                    builder.event(parseDateTime("event", reader, eventElementIndex++));
                    break;
                case "repeat":
                    position = checkElementOrder("repeat", 3, position, false);
                    builder.repeat(parseTimingRepeat("repeat", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 4, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Timing.Repeat parseTimingRepeat(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Timing.Repeat.Builder builder = Timing.Repeat.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dayOfWeekElementIndex = 0, timeOfDayElementIndex = 0, whenElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "boundsDuration":
                    position = checkElementOrder("bounds[x]", 2, position, false);
                    builder.bounds((Duration) parseQuantity(Duration.builder(), "boundsDuration", reader, -1));
                    break;
                case "boundsRange":
                    position = checkElementOrder("bounds[x]", 2, position, false);
                    builder.bounds(parseRange("boundsRange", reader, -1));
                    break;
                case "boundsPeriod":
                    position = checkElementOrder("bounds[x]", 2, position, false);
                    builder.bounds(parsePeriod("boundsPeriod", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 3, position, false);
                    builder.count((PositiveInt) parseInteger(PositiveInt.builder(), "count", reader, -1));
                    break;
                case "countMax":
                    position = checkElementOrder("countMax", 4, position, false);
                    builder.countMax((PositiveInt) parseInteger(PositiveInt.builder(), "countMax", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 5, position, false);
                    builder.duration(parseDecimal("duration", reader, -1));
                    break;
                case "durationMax":
                    position = checkElementOrder("durationMax", 6, position, false);
                    builder.durationMax(parseDecimal("durationMax", reader, -1));
                    break;
                case "durationUnit":
                    position = checkElementOrder("durationUnit", 7, position, false);
                    builder.durationUnit((UnitsOfTime) parseString(UnitsOfTime.builder(), "durationUnit", reader, -1));
                    break;
                case "frequency":
                    position = checkElementOrder("frequency", 8, position, false);
                    builder.frequency((PositiveInt) parseInteger(PositiveInt.builder(), "frequency", reader, -1));
                    break;
                case "frequencyMax":
                    position = checkElementOrder("frequencyMax", 9, position, false);
                    builder.frequencyMax((PositiveInt) parseInteger(PositiveInt.builder(), "frequencyMax", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parseDecimal("period", reader, -1));
                    break;
                case "periodMax":
                    position = checkElementOrder("periodMax", 11, position, false);
                    builder.periodMax(parseDecimal("periodMax", reader, -1));
                    break;
                case "periodUnit":
                    position = checkElementOrder("periodUnit", 12, position, false);
                    builder.periodUnit((UnitsOfTime) parseString(UnitsOfTime.builder(), "periodUnit", reader, -1));
                    break;
                case "dayOfWeek":
                    position = checkElementOrder("dayOfWeek", 13, position, true);
                    builder.dayOfWeek((DayOfWeek) parseString(DayOfWeek.builder(), "dayOfWeek", reader, dayOfWeekElementIndex++));
                    break;
                case "timeOfDay":
                    position = checkElementOrder("timeOfDay", 14, position, true);
                    builder.timeOfDay(parseTime("timeOfDay", reader, timeOfDayElementIndex++));
                    break;
                case "when":
                    position = checkElementOrder("when", 15, position, true);
                    builder.when((EventTiming) parseString(EventTiming.builder(), "when", reader, whenElementIndex++));
                    break;
                case "offset":
                    position = checkElementOrder("offset", 16, position, false);
                    builder.offset((UnsignedInt) parseInteger(UnsignedInt.builder(), "offset", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Transport parseTransport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Transport.Builder builder = Transport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, performerTypeElementIndex = 0, insuranceElementIndex = 0, noteElementIndex = 0, relevantHistoryElementIndex = 0, inputElementIndex = 0, outputElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, false);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, -1));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, false);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 12, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 13, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((TransportStatus) parseString(TransportStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 15, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 16, position, false);
                    builder.intent((TransportIntent) parseString(TransportIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 17, position, false);
                    builder.priority((TransportPriority) parseString(TransportPriority.builder(), "priority", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 18, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 20, position, false);
                    builder.focus(parseReference("focus", reader, -1));
                    break;
                case "for":
                    position = checkElementOrder("for", 21, position, false);
                    builder._for(parseReference("for", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 22, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "completionTime":
                    position = checkElementOrder("completionTime", 23, position, false);
                    builder.completionTime(parseDateTime("completionTime", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 24, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "lastModified":
                    position = checkElementOrder("lastModified", 25, position, false);
                    builder.lastModified(parseDateTime("lastModified", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 26, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 27, position, true);
                    builder.performerType(parseCodeableConcept("performerType", reader, performerTypeElementIndex++));
                    break;
                case "owner":
                    position = checkElementOrder("owner", 28, position, false);
                    builder.owner(parseReference("owner", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 29, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 30, position, true);
                    builder.insurance(parseReference("insurance", reader, insuranceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 31, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "relevantHistory":
                    position = checkElementOrder("relevantHistory", 32, position, true);
                    builder.relevantHistory(parseReference("relevantHistory", reader, relevantHistoryElementIndex++));
                    break;
                case "restriction":
                    position = checkElementOrder("restriction", 33, position, false);
                    builder.restriction(parseTransportRestriction("restriction", reader, -1));
                    break;
                case "input":
                    position = checkElementOrder("input", 34, position, true);
                    builder.input(parseTransportInput("input", reader, inputElementIndex++));
                    break;
                case "output":
                    position = checkElementOrder("output", 35, position, true);
                    builder.output(parseTransportOutput("output", reader, outputElementIndex++));
                    break;
                case "requestedLocation":
                    position = checkElementOrder("requestedLocation", 36, position, false);
                    builder.requestedLocation(parseReference("requestedLocation", reader, -1));
                    break;
                case "currentLocation":
                    position = checkElementOrder("currentLocation", 37, position, false);
                    builder.currentLocation(parseReference("currentLocation", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 38, position, false);
                    builder.reason(parseCodeableReference("reason", reader, -1));
                    break;
                case "history":
                    position = checkElementOrder("history", 39, position, false);
                    builder.history(parseReference("history", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Transport.Input parseTransportInput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Transport.Input.Builder builder = Transport.Input.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueInteger64":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger64("valueInteger64", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCodeableReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableReference("valueCodeableReference", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRatioRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatioRange("valueRatioRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueAvailability":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAvailability("valueAvailability", reader, -1));
                    break;
                case "valueExtendedContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExtendedContactDetail("valueExtendedContactDetail", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Transport.Output parseTransportOutput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Transport.Output.Builder builder = Transport.Output.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueInteger64":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger64("valueInteger64", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCodeableReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableReference("valueCodeableReference", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRatioRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatioRange("valueRatioRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueAvailability":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAvailability("valueAvailability", reader, -1));
                    break;
                case "valueExtendedContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExtendedContactDetail("valueExtendedContactDetail", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Transport.Restriction parseTransportRestriction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Transport.Restriction.Builder builder = Transport.Restriction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, recipientElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "repetitions":
                    position = checkElementOrder("repetitions", 2, position, false);
                    builder.repetitions((PositiveInt) parseInteger(PositiveInt.builder(), "repetitions", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 4, position, true);
                    builder.recipient(parseReference("recipient", reader, recipientElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TriggerDefinition parseTriggerDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TriggerDefinition.Builder builder = TriggerDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, dataElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, false);
                    builder.type((TriggerType) parseString(TriggerType.builder(), "type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subscriptionTopic":
                    position = checkElementOrder("subscriptionTopic", 4, position, false);
                    builder.subscriptionTopic((Canonical) parseUri(Canonical.builder(), "subscriptionTopic", reader, -1));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "timingReference":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parseReference("timingReference", reader, -1));
                    break;
                case "timingDate":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parseDate("timingDate", reader, -1));
                    break;
                case "timingDateTime":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parseDateTime("timingDateTime", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 6, position, true);
                    builder.data(parseDataRequirement("data", reader, dataElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 7, position, false);
                    builder.condition(parseExpression("condition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Uri parseUri(Uri.Builder builder, java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Uri parseUri(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        return parseUri(Uri.builder(), elementName, reader, elementIndex);
    }

    private UsageContext parseUsageContext(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        UsageContext.Builder builder = UsageContext.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 1, position, false);
                    builder.code(parseCoding("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet parseValueSet(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Builder builder = ValueSet.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "versionAlgorithmString":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseString("versionAlgorithmString", reader, -1));
                    break;
                case "versionAlgorithmCoding":
                    position = checkElementOrder("versionAlgorithm[x]", 11, position, false);
                    builder.versionAlgorithm(parseCoding("versionAlgorithmCoding", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 13, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "immutable":
                    position = checkElementOrder("immutable", 22, position, false);
                    builder.immutable(parseBoolean("immutable", reader, -1));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 24, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "copyrightLabel":
                    position = checkElementOrder("copyrightLabel", 25, position, false);
                    builder.copyrightLabel(parseString("copyrightLabel", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 26, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 27, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 28, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 29, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 30, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 31, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 32, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 33, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 34, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "compose":
                    position = checkElementOrder("compose", 35, position, false);
                    builder.compose(parseValueSetCompose("compose", reader, -1));
                    break;
                case "expansion":
                    position = checkElementOrder("expansion", 36, position, false);
                    builder.expansion(parseValueSetExpansion("expansion", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 37, position, false);
                    builder.scope(parseValueSetScope("scope", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose parseValueSetCompose(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Builder builder = ValueSet.Compose.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, includeElementIndex = 0, excludeElementIndex = 0, propertyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "lockedDate":
                    position = checkElementOrder("lockedDate", 2, position, false);
                    builder.lockedDate(parseDate("lockedDate", reader, -1));
                    break;
                case "inactive":
                    position = checkElementOrder("inactive", 3, position, false);
                    builder.inactive(parseBoolean("inactive", reader, -1));
                    break;
                case "include":
                    position = checkElementOrder("include", 4, position, true);
                    builder.include(parseValueSetComposeInclude("include", reader, includeElementIndex++));
                    break;
                case "exclude":
                    position = checkElementOrder("exclude", 5, position, true);
                    builder.exclude(parseValueSetComposeInclude("exclude", reader, excludeElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 6, position, true);
                    builder.property(parseString("property", reader, propertyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose.Include parseValueSetComposeInclude(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Include.Builder builder = ValueSet.Compose.Include.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, conceptElementIndex = 0, filterElementIndex = 0, valueSetElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 2, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "concept":
                    position = checkElementOrder("concept", 4, position, true);
                    builder.concept(parseValueSetComposeIncludeConcept("concept", reader, conceptElementIndex++));
                    break;
                case "filter":
                    position = checkElementOrder("filter", 5, position, true);
                    builder.filter(parseValueSetComposeIncludeFilter("filter", reader, filterElementIndex++));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 6, position, true);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, valueSetElementIndex++));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 7, position, false);
                    builder.copyright(parseString("copyright", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose.Include.Concept parseValueSetComposeIncludeConcept(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Include.Concept.Builder builder = ValueSet.Compose.Include.Concept.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, designationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 3, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "designation":
                    position = checkElementOrder("designation", 4, position, true);
                    builder.designation(parseValueSetComposeIncludeConceptDesignation("designation", reader, designationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose.Include.Concept.Designation parseValueSetComposeIncludeConceptDesignation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Include.Concept.Designation.Builder builder = ValueSet.Compose.Include.Concept.Designation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additionalUseElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use(parseCoding("use", reader, -1));
                    break;
                case "additionalUse":
                    position = checkElementOrder("additionalUse", 4, position, true);
                    builder.additionalUse(parseCoding("additionalUse", reader, additionalUseElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose.Include.Filter parseValueSetComposeIncludeFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Include.Filter.Builder builder = ValueSet.Compose.Include.Filter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 2, position, false);
                    builder.property((Code) parseString(Code.builder(), "property", reader, -1));
                    break;
                case "op":
                    position = checkElementOrder("op", 3, position, false);
                    builder.op((FilterOperator) parseString(FilterOperator.builder(), "op", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 4, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Expansion parseValueSetExpansion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Expansion.Builder builder = ValueSet.Expansion.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, parameterElementIndex = 0, propertyElementIndex = 0, containsElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseUri("identifier", reader, -1));
                    break;
                case "next":
                    position = checkElementOrder("next", 3, position, false);
                    builder.next(parseUri("next", reader, -1));
                    break;
                case "timestamp":
                    position = checkElementOrder("timestamp", 4, position, false);
                    builder.timestamp(parseDateTime("timestamp", reader, -1));
                    break;
                case "total":
                    position = checkElementOrder("total", 5, position, false);
                    builder.total(parseInteger("total", reader, -1));
                    break;
                case "offset":
                    position = checkElementOrder("offset", 6, position, false);
                    builder.offset(parseInteger("offset", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 7, position, true);
                    builder.parameter(parseValueSetExpansionParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 8, position, true);
                    builder.property(parseValueSetExpansionProperty("property", reader, propertyElementIndex++));
                    break;
                case "contains":
                    position = checkElementOrder("contains", 9, position, true);
                    builder.contains(parseValueSetExpansionContains("contains", reader, containsElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Expansion.Contains parseValueSetExpansionContains(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Expansion.Contains.Builder builder = ValueSet.Expansion.Contains.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, designationElementIndex = 0, propertyElementIndex = 0, containsElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 2, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "abstract":
                    position = checkElementOrder("abstract", 3, position, false);
                    builder._abstract(parseBoolean("abstract", reader, -1));
                    break;
                case "inactive":
                    position = checkElementOrder("inactive", 4, position, false);
                    builder.inactive(parseBoolean("inactive", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 5, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 6, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 7, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "designation":
                    position = checkElementOrder("designation", 8, position, true);
                    builder.designation(parseValueSetComposeIncludeConceptDesignation("designation", reader, designationElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 9, position, true);
                    builder.property(parseValueSetExpansionContainsProperty("property", reader, propertyElementIndex++));
                    break;
                case "contains":
                    position = checkElementOrder("contains", 10, position, true);
                    builder.contains(parseValueSetExpansionContains("contains", reader, containsElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Expansion.Contains.Property parseValueSetExpansionContainsProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Expansion.Contains.Property.Builder builder = ValueSet.Expansion.Contains.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, subPropertyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "subProperty":
                    position = checkElementOrder("subProperty", 4, position, true);
                    builder.subProperty(parseValueSetExpansionContainsPropertySubProperty("subProperty", reader, subPropertyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Expansion.Contains.Property.SubProperty parseValueSetExpansionContainsPropertySubProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Expansion.Contains.Property.SubProperty.Builder builder = ValueSet.Expansion.Contains.Property.SubProperty.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Expansion.Parameter parseValueSetExpansionParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Expansion.Parameter.Builder builder = ValueSet.Expansion.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Expansion.Property parseValueSetExpansionProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Expansion.Property.Builder builder = ValueSet.Expansion.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Scope parseValueSetScope(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Scope.Builder builder = ValueSet.Scope.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "inclusionCriteria":
                    position = checkElementOrder("inclusionCriteria", 2, position, false);
                    builder.inclusionCriteria(parseString("inclusionCriteria", reader, -1));
                    break;
                case "exclusionCriteria":
                    position = checkElementOrder("exclusionCriteria", 3, position, false);
                    builder.exclusionCriteria(parseString("exclusionCriteria", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VerificationResult parseVerificationResult(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VerificationResult.Builder builder = VerificationResult.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetElementIndex = 0, targetLocationElementIndex = 0, validationProcessElementIndex = 0, primarySourceElementIndex = 0, validatorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 8, position, true);
                    builder.target(parseReference("target", reader, targetElementIndex++));
                    break;
                case "targetLocation":
                    position = checkElementOrder("targetLocation", 9, position, true);
                    builder.targetLocation(parseString("targetLocation", reader, targetLocationElementIndex++));
                    break;
                case "need":
                    position = checkElementOrder("need", 10, position, false);
                    builder.need(parseCodeableConcept("need", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((Status) parseString(Status.builder(), "status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 12, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "validationType":
                    position = checkElementOrder("validationType", 13, position, false);
                    builder.validationType(parseCodeableConcept("validationType", reader, -1));
                    break;
                case "validationProcess":
                    position = checkElementOrder("validationProcess", 14, position, true);
                    builder.validationProcess(parseCodeableConcept("validationProcess", reader, validationProcessElementIndex++));
                    break;
                case "frequency":
                    position = checkElementOrder("frequency", 15, position, false);
                    builder.frequency(parseTiming("frequency", reader, -1));
                    break;
                case "lastPerformed":
                    position = checkElementOrder("lastPerformed", 16, position, false);
                    builder.lastPerformed(parseDateTime("lastPerformed", reader, -1));
                    break;
                case "nextScheduled":
                    position = checkElementOrder("nextScheduled", 17, position, false);
                    builder.nextScheduled(parseDate("nextScheduled", reader, -1));
                    break;
                case "failureAction":
                    position = checkElementOrder("failureAction", 18, position, false);
                    builder.failureAction(parseCodeableConcept("failureAction", reader, -1));
                    break;
                case "primarySource":
                    position = checkElementOrder("primarySource", 19, position, true);
                    builder.primarySource(parseVerificationResultPrimarySource("primarySource", reader, primarySourceElementIndex++));
                    break;
                case "attestation":
                    position = checkElementOrder("attestation", 20, position, false);
                    builder.attestation(parseVerificationResultAttestation("attestation", reader, -1));
                    break;
                case "validator":
                    position = checkElementOrder("validator", 21, position, true);
                    builder.validator(parseVerificationResultValidator("validator", reader, validatorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VerificationResult.Attestation parseVerificationResultAttestation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VerificationResult.Attestation.Builder builder = VerificationResult.Attestation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "who":
                    position = checkElementOrder("who", 2, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 3, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                case "communicationMethod":
                    position = checkElementOrder("communicationMethod", 4, position, false);
                    builder.communicationMethod(parseCodeableConcept("communicationMethod", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 5, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "sourceIdentityCertificate":
                    position = checkElementOrder("sourceIdentityCertificate", 6, position, false);
                    builder.sourceIdentityCertificate(parseString("sourceIdentityCertificate", reader, -1));
                    break;
                case "proxyIdentityCertificate":
                    position = checkElementOrder("proxyIdentityCertificate", 7, position, false);
                    builder.proxyIdentityCertificate(parseString("proxyIdentityCertificate", reader, -1));
                    break;
                case "proxySignature":
                    position = checkElementOrder("proxySignature", 8, position, false);
                    builder.proxySignature(parseSignature("proxySignature", reader, -1));
                    break;
                case "sourceSignature":
                    position = checkElementOrder("sourceSignature", 9, position, false);
                    builder.sourceSignature(parseSignature("sourceSignature", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VerificationResult.PrimarySource parseVerificationResultPrimarySource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VerificationResult.PrimarySource.Builder builder = VerificationResult.PrimarySource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, communicationMethodElementIndex = 0, pushTypeAvailableElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "who":
                    position = checkElementOrder("who", 2, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "communicationMethod":
                    position = checkElementOrder("communicationMethod", 4, position, true);
                    builder.communicationMethod(parseCodeableConcept("communicationMethod", reader, communicationMethodElementIndex++));
                    break;
                case "validationStatus":
                    position = checkElementOrder("validationStatus", 5, position, false);
                    builder.validationStatus(parseCodeableConcept("validationStatus", reader, -1));
                    break;
                case "validationDate":
                    position = checkElementOrder("validationDate", 6, position, false);
                    builder.validationDate(parseDateTime("validationDate", reader, -1));
                    break;
                case "canPushUpdates":
                    position = checkElementOrder("canPushUpdates", 7, position, false);
                    builder.canPushUpdates(parseCodeableConcept("canPushUpdates", reader, -1));
                    break;
                case "pushTypeAvailable":
                    position = checkElementOrder("pushTypeAvailable", 8, position, true);
                    builder.pushTypeAvailable(parseCodeableConcept("pushTypeAvailable", reader, pushTypeAvailableElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VerificationResult.Validator parseVerificationResultValidator(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VerificationResult.Validator.Builder builder = VerificationResult.Validator.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 2, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "identityCertificate":
                    position = checkElementOrder("identityCertificate", 3, position, false);
                    builder.identityCertificate(parseString("identityCertificate", reader, -1));
                    break;
                case "attestationSignature":
                    position = checkElementOrder("attestationSignature", 4, position, false);
                    builder.attestationSignature(parseSignature("attestationSignature", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VirtualServiceDetail parseVirtualServiceDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VirtualServiceDetail.Builder builder = VirtualServiceDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, additionalInfoElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "channelType":
                    position = checkElementOrder("channelType", 1, position, false);
                    builder.channelType(parseCoding("channelType", reader, -1));
                    break;
                case "addressUrl":
                    position = checkElementOrder("address[x]", 2, position, false);
                    builder.address((Url) parseUri(Url.builder(), "addressUrl", reader, -1));
                    break;
                case "addressString":
                    position = checkElementOrder("address[x]", 2, position, false);
                    builder.address(parseString("addressString", reader, -1));
                    break;
                case "addressContactPoint":
                    position = checkElementOrder("address[x]", 2, position, false);
                    builder.address(parseContactPoint("addressContactPoint", reader, -1));
                    break;
                case "addressExtendedContactDetail":
                    position = checkElementOrder("address[x]", 2, position, false);
                    builder.address(parseExtendedContactDetail("addressExtendedContactDetail", reader, -1));
                    break;
                case "additionalInfo":
                    position = checkElementOrder("additionalInfo", 3, position, true);
                    builder.additionalInfo((Url) parseUri(Url.builder(), "additionalInfo", reader, additionalInfoElementIndex++));
                    break;
                case "maxParticipants":
                    position = checkElementOrder("maxParticipants", 4, position, false);
                    builder.maxParticipants((PositiveInt) parseInteger(PositiveInt.builder(), "maxParticipants", reader, -1));
                    break;
                case "sessionKey":
                    position = checkElementOrder("sessionKey", 5, position, false);
                    builder.sessionKey(parseString("sessionKey", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VisionPrescription parseVisionPrescription(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VisionPrescription.Builder builder = VisionPrescription.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, lensSpecificationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((VisionStatus) parseString(VisionStatus.builder(), "status", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 10, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 11, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 12, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "dateWritten":
                    position = checkElementOrder("dateWritten", 13, position, false);
                    builder.dateWritten(parseDateTime("dateWritten", reader, -1));
                    break;
                case "prescriber":
                    position = checkElementOrder("prescriber", 14, position, false);
                    builder.prescriber(parseReference("prescriber", reader, -1));
                    break;
                case "lensSpecification":
                    position = checkElementOrder("lensSpecification", 15, position, true);
                    builder.lensSpecification(parseVisionPrescriptionLensSpecification("lensSpecification", reader, lensSpecificationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VisionPrescription.LensSpecification parseVisionPrescriptionLensSpecification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VisionPrescription.LensSpecification.Builder builder = VisionPrescription.LensSpecification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, prismElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "product":
                    position = checkElementOrder("product", 2, position, false);
                    builder.product(parseCodeableConcept("product", reader, -1));
                    break;
                case "eye":
                    position = checkElementOrder("eye", 3, position, false);
                    builder.eye((VisionEyes) parseString(VisionEyes.builder(), "eye", reader, -1));
                    break;
                case "sphere":
                    position = checkElementOrder("sphere", 4, position, false);
                    builder.sphere(parseDecimal("sphere", reader, -1));
                    break;
                case "cylinder":
                    position = checkElementOrder("cylinder", 5, position, false);
                    builder.cylinder(parseDecimal("cylinder", reader, -1));
                    break;
                case "axis":
                    position = checkElementOrder("axis", 6, position, false);
                    builder.axis(parseInteger("axis", reader, -1));
                    break;
                case "prism":
                    position = checkElementOrder("prism", 7, position, true);
                    builder.prism(parseVisionPrescriptionLensSpecificationPrism("prism", reader, prismElementIndex++));
                    break;
                case "add":
                    position = checkElementOrder("add", 8, position, false);
                    builder.add(parseDecimal("add", reader, -1));
                    break;
                case "power":
                    position = checkElementOrder("power", 9, position, false);
                    builder.power(parseDecimal("power", reader, -1));
                    break;
                case "backCurve":
                    position = checkElementOrder("backCurve", 10, position, false);
                    builder.backCurve(parseDecimal("backCurve", reader, -1));
                    break;
                case "diameter":
                    position = checkElementOrder("diameter", 11, position, false);
                    builder.diameter(parseDecimal("diameter", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 12, position, false);
                    builder.duration((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "duration", reader, -1));
                    break;
                case "color":
                    position = checkElementOrder("color", 13, position, false);
                    builder.color(parseString("color", reader, -1));
                    break;
                case "brand":
                    position = checkElementOrder("brand", 14, position, false);
                    builder.brand(parseString("brand", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 15, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VisionPrescription.LensSpecification.Prism parseVisionPrescriptionLensSpecificationPrism(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VisionPrescription.LensSpecification.Prism.Builder builder = VisionPrescription.LensSpecification.Prism.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 2, position, false);
                    builder.amount(parseDecimal("amount", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 3, position, false);
                    builder.base((VisionBase) parseString(VisionBase.builder(), "base", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Xhtml parseXhtml(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Xhtml.Builder builder = Xhtml.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        builder.value(parseDiv(reader));
        stackPop();
        return builder.build();
    }
    
    private Element parseElement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) {
		throw new UnsupportedOperationException("Element " + elementName + " is not modeled.");
	}

    private void stackPush(java.lang.String elementName, int elementIndex) {
        if (elementIndex != -1) {
            stack.push(elementName + "[" + elementIndex + "]");
        } else {
            stack.push(elementName);
        }
        if (DEBUG) {
            System.out.println(getPath());
        }
    }

    private void stackPop() {
        stack.pop();
    }

    private java.lang.String getPath() {
        StringJoiner joiner = new StringJoiner(".");
        for (java.lang.String s : stack) {
            joiner.add(s);
        }
        return joiner.toString();
    }

    private java.lang.String parseJavaString(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        java.lang.String javaString = reader.getAttributeValue(null, "value");
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return javaString;
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private java.lang.String getResourceType(XMLStreamReader reader) throws XMLStreamException {
        java.lang.String resourceType = reader.getLocalName();
        try {
            ResourceType.from(resourceType);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid resource type: '" + resourceType + "'");
        }
        return resourceType;
    }
}
